@page "/"
@using AutoPilot.App.Services
@using AutoPilot.App.Models
@using Markdig
@inject CopilotService CopilotService
@inject IJSRuntime JS
@inject NavigationManager Nav
@implements IDisposable

<div class="chat-container">
    @if (!CopilotService.IsInitialized)
    {
        <div class="initializing">
            <div class="spinner"></div>
            <p>Connecting to Copilot...</p>
            @if (!string.IsNullOrEmpty(initError))
            {
                <p class="error">@initError</p>
                <button @onclick="Initialize">Retry</button>
            }
        </div>
    }
    else if (activeSession == null)
    {
        <div class="no-session">
            <h2>Welcome to AutoPilot</h2>
            <p>Create a new session from the sidebar to start chatting with Copilot.</p>
        </div>
    }
    else
    {
        <div class="chat-header">
            <h2>@activeSession.Name</h2>
            <span class="model-badge">@activeSession.Model</span>
            @if (activeSession.SessionId != null)
            {
                <span class="session-id-badge" title="Click to copy: @activeSession.SessionId" @onclick="() => CopySessionId(activeSession.SessionId)"><svg class="icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> @activeSession.SessionId[..8] <svg class="icon copy-icon" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg></span>
            }
            @if (activeSession.IsProcessing)
            {
                <span class="typing-indicator">Copilot is typing...</span>
            }
        </div>

        <div class="messages" @ref="messagesContainer">
            @if (!activeSession.History.Any() && string.IsNullOrEmpty(streamingContent))
            {
                <div class="empty-chat">
                    <p>Start a conversation with Copilot!</p>
                </div>
            }
            else
            {
                @if (HasMoreMessages)
                {
                    <button class="load-more-btn" @onclick="LoadMoreMessages">
                        <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg>
                        Load @Math.Min(50, activeSession.History.Count - visibleMessageCount) older messages (@(activeSession.History.Count - visibleMessageCount) remaining)
                    </button>
                }

                @foreach (var message in VisibleHistory)
                {
                    @switch (message.MessageType)
                    {
                        case ChatMessageType.User:
                            <div class="message user">
                                <div class="message-avatar"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg></div>
                                <div class="message-content">
                                    <div class="message-text">@((MarkupString)FormatUserMessage(message.Content))</div>
                                    <div class="message-time">@message.Timestamp.ToString("HH:mm")</div>
                                </div>
                            </div>
                            break;

                        case ChatMessageType.Assistant:
                            <div class="message assistant">
                                <div class="message-avatar"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect x="2" y="8" width="20" height="8" rx="2"/><path d="M6 16v4"/><path d="M18 16v4"/><circle cx="9" cy="12" r="1" fill="currentColor"/><circle cx="15" cy="12" r="1" fill="currentColor"/></svg></div>
                                <div class="message-content">
                                    <div class="message-text markdown-body">@((MarkupString)RenderMarkdown(message.Content))</div>
                                    <div class="message-time">@message.Timestamp.ToString("HH:mm")</div>
                                </div>
                            </div>
                            break;

                        case ChatMessageType.Reasoning:
                            <div class="reasoning-block @(message.IsCollapsed && LineCount(message.Content) > 5 ? "collapsed" : "")">
                                <button class="reasoning-header" @onclick="() => message.IsCollapsed = !message.IsCollapsed">
                                    <span class="reasoning-title"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a8 8 0 0 0-8 8c0 3.4 2.1 6.3 5 7.4V20a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-2.6c2.9-1.1 5-4 5-7.4a8 8 0 0 0-8-8z"/><line x1="10" y1="22" x2="14" y2="22"/></svg> @(message.IsComplete ? "Thought" : "Thinking...")</span>
                                    @if (LineCount(message.Content) > 5)
                                    {
                                        <span class="collapse-icon">@(message.IsCollapsed ? "‚ñ∂" : "‚ñº")</span>
                                    }
                                </button>
                                @if (!message.IsCollapsed || LineCount(message.Content) <= 5)
                                {
                                    <div class="reasoning-content">@message.Content</div>
                                }
                                else
                                {
                                    <div class="reasoning-content preview">@FirstLines(message.Content, 3)</div>
                                }
                            </div>
                            break;

                        case ChatMessageType.ToolCall:
                            @if (message.ToolName == "task_complete")
                            {
                                <div class="task-complete-card">
                                    <svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#4ade80" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                                    <span class="task-complete-text">@(string.IsNullOrEmpty(message.Content) || IsUnusableResult(message.Content) ? "Task complete" : message.Content)</span>
                                </div>
                            }
                            else
                            {
                            <div class="tool-card @(message.IsComplete ? (message.IsSuccess ? "success" : "error") : "running")">
                                <div class="tool-header">
                                    <span class="tool-info"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg> @FormatToolName(message.ToolName ?? "")</span>
                                    <span class="tool-status">
                                        @if (!message.IsComplete)
                                        {
                                            <svg class="icon spin" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.22-8.56"/></svg> <text>Running</text>
                                        }
                                        else if (message.IsSuccess)
                                        {
                                            <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#4ade80" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg> <text>Done</text>
                                        }
                                        else
                                        {
                                            <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg> <text>Failed</text>
                                        }
                                    </span>
                                </div>
                                @if (message.IsComplete && !string.IsNullOrEmpty(message.Content) && !IsUnusableResult(message.Content))
                                {
                                    @if (GetImagePath(message.Content) is string imgPath && FileToDataUri(imgPath) is string dataUri)
                                    {
                                        <div class="tool-result-section tool-image-result">
                                            <img src="@dataUri" alt="@System.IO.Path.GetFileName(imgPath)" />
                                        </div>
                                    }
                                    else if (LineCount(message.Content) <= 5)
                                    {
                                        <div class="tool-result-section">
                                            <pre class="tool-result-content">@TruncateResult(message.Content)</pre>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="tool-result-section">
                                            <button class="tool-result-toggle" @onclick="() => message.IsCollapsed = !message.IsCollapsed">
                                                @(message.IsCollapsed ? "Show Full Result ‚ñ∂" : "Collapse ‚ñº")
                                            </button>
                                            @if (!message.IsCollapsed)
                                            {
                                                <pre class="tool-result-content">@TruncateResult(message.Content)</pre>
                                            }
                                            else
                                            {
                                                <pre class="tool-result-content preview">@FirstLines(message.Content, 3)</pre>
                                            }
                                        </div>
                                    }
                                }
                            </div>
                            }
                            break;

                        case ChatMessageType.Error:
                            <div class="error-card">
                                <span class="error-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></span>
                                <span class="error-text">@message.Content</span>
                            </div>
                            break;
                    }
                }

                @if (!string.IsNullOrEmpty(streamingContent))
                {
                    <div class="message assistant streaming">
                        <div class="message-avatar"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect x="2" y="8" width="20" height="8" rx="2"/><path d="M6 16v4"/><path d="M18 16v4"/><circle cx="9" cy="12" r="1" fill="currentColor"/><circle cx="15" cy="12" r="1" fill="currentColor"/></svg></div>
                        <div class="message-content">
                            <div class="message-text markdown-body">@((MarkupString)RenderMarkdown(streamingContent))</div>
                        </div>
                    </div>
                }
            }
        </div>

        @if (!string.IsNullOrEmpty(lastError))
        {
            <div class="error-bar">
                <span><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> @lastError</span>
                <button @onclick="() => lastError = null">√ó</button>
            </div>
        }

        <div class="input-area">
            @if (!string.IsNullOrEmpty(currentIntent))
            {
                <div class="intent-pill"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg> @currentIntent</div>
            }
            @if (activeSession.MessageQueue.Any())
            {
                <div class="message-queue">
                    <div class="queue-header">
                        <span><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg> Queued (@activeSession.MessageQueue.Count)</span>
                        <button class="queue-clear-btn" @onclick="ClearQueue">Clear</button>
                    </div>
                    @for (var i = 0; i < activeSession.MessageQueue.Count; i++)
                    {
                        var index = i;
                        var msg = activeSession.MessageQueue[i];
                        <div class="queue-item">
                            <span class="queue-index">@(index + 1)</span>
                            <span class="queue-text">@Truncate(msg, 80)</span>
                            <button class="queue-remove-btn" @onclick="() => RemoveQueuedMessage(index)">√ó</button>
                        </div>
                    }
                </div>
            }
            <div class="input-row">
                <textarea @bind="userInput" @bind:event="oninput" 
                          @onkeydown="HandleKeyDown" @onkeydown:preventDefault="shouldPreventDefault"
                          placeholder="@GetInputPlaceholder()"
                          rows="1"></textarea>
                <button @onclick="SendMessage" 
                        disabled="@(string.IsNullOrWhiteSpace(userInput))"
                        title="@(activeSession.IsProcessing ? "Queue message" : "Send message")">
                    @if (activeSession.IsProcessing)
                    {
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
                    }
                    else
                    {
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                    }
                </button>
            </div>
            <div class="input-status-bar">
                <button class="plan-icon-toggle @(isPlanMode ? "active" : "")" @onclick="() => isPlanMode = !isPlanMode" title="Toggle planning mode ‚Äî prefixes messages with [[PLAN]]">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="1.5" width="12" height="13" rx="1.5"/><line x1="5" y1="5" x2="5.01" y2="5"/><line x1="7.5" y1="5" x2="11" y2="5"/><line x1="5" y1="8" x2="5.01" y2="8"/><line x1="7.5" y1="8" x2="11" y2="8"/><line x1="5" y1="11" x2="5.01" y2="11"/><line x1="7.5" y1="11" x2="11" y2="11"/></svg>
                    <span>Planning</span>
                </button>
                <span class="status-sep">¬∑</span>
                <span class="status-model">@(currentUsage?.Model ?? activeSession.Model)</span>
                @if (currentUsage != null)
                {
                    @if (currentUsage.InputTokens.HasValue || currentUsage.OutputTokens.HasValue)
                    {
                        <span class="status-sep">¬∑</span>
                        <span class="status-tokens">‚Üë@FormatTokenCount(currentUsage.InputTokens ?? 0) ‚Üì@FormatTokenCount(currentUsage.OutputTokens ?? 0)</span>
                    }
                    @if (currentUsage.CurrentTokens.HasValue && currentUsage.TokenLimit.HasValue)
                    {
                        <span class="status-sep">¬∑</span>
                        <span class="status-ctx" title="@currentUsage.CurrentTokens.Value / @currentUsage.TokenLimit.Value tokens">@FormatTokenCount(currentUsage.CurrentTokens.Value)/@FormatTokenCount(currentUsage.TokenLimit.Value) ctx</span>
                    }
                }
                <span class="status-sep">¬∑</span>
                <span class="status-msgs">@activeSession.History.Count msgs</span>
                <span class="status-sep">¬∑</span>
                <button class="plan-icon-toggle @(showDebugPanel ? "active" : "")" @onclick="() => showDebugPanel = !showDebugPanel" title="Toggle debug log">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2l1.88 1.88"/><path d="M14.12 3.88L16 2"/><path d="M9 7.13v-1a3.003 3.003 0 1 1 6 0v1"/><path d="M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6"/><path d="M12 20v-9"/><path d="M6.53 9C4.6 8.8 3 7.1 3 5"/><path d="M6 13H2"/><path d="M3 21c0-2.1 1.7-3.9 3.8-4"/><path d="M20.97 5c0 2.1-1.6 3.8-3.5 4"/><path d="M22 13h-4"/><path d="M17.2 17c2.1.1 3.8 1.9 3.8 4"/></svg>
                    <span>Log</span>
                </button>
            </div>
        </div>
    }
    
    @if (showDebugPanel)
    {
        <div class="debug-panel">
            <div class="debug-header">
                <span>Debug Log</span>
                <div class="debug-actions">
                    <input type="text" class="debug-filter" placeholder="Filter..." @bind="debugFilter" @bind:event="oninput" />
                    <button @onclick="InspectDom" title="Inspect DOM">üîç</button>
                    <button @onclick="() => debugLog = string.Empty" title="Clear log">Clear</button>
                    <button @onclick="() => showDebugPanel = false" title="Close">‚úï</button>
                </div>
            </div>
            <pre>@FilteredDebugLog</pre>
        </div>
    }
</div>

@code {
    private static readonly MarkdownPipeline MdPipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .Build();

    private AgentSessionInfo? activeSession;
    private string userInput = "";
    private bool isPlanMode = false;
    private string streamingContent = "";
    private string currentIntent = "";
    private SessionUsageInfo? currentUsage;
    private string? initError;
    private string? lastError;
    private string debugLog = "";
    private string debugFilter = "";
    private bool showDebugPanel = false;
    private ElementReference messagesContainer;
    private bool _needsRedirect;
    private string? _redirectTo;
    private bool _needsScroll = true;
    private bool shouldPreventDefault;
    private int visibleMessageCount = 50;
    private static readonly Dictionary<string, string> _imageCache = new();
    private static readonly Dictionary<int, string> _markdownCache = new();

    private List<ChatMessage> VisibleHistory
    {
        get
        {
            if (activeSession == null) return new();
            var all = activeSession.History;
            if (all.Count <= visibleMessageCount) return all.ToList();
            return all.Skip(all.Count - visibleMessageCount).ToList();
        }
    }

    private bool HasMoreMessages => activeSession != null && activeSession.History.Count > visibleMessageCount;

    private void LoadMoreMessages()
    {
        visibleMessageCount += 50;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        CopilotService.OnStateChanged += RefreshState;
        CopilotService.OnContentReceived += HandleContentReceived;
        CopilotService.OnSessionComplete += HandleSessionComplete;
        CopilotService.OnError += HandleError;
        CopilotService.OnDebug += HandleDebug;
        CopilotService.OnToolStarted += HandleToolStarted;
        CopilotService.OnToolCompleted += HandleToolCompleted;
        CopilotService.OnReasoningReceived += HandleReasoningReceived;
        CopilotService.OnReasoningComplete += HandleReasoningComplete;
        CopilotService.OnIntentChanged += HandleIntentChanged;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        CopilotService.OnTurnStart += HandleTurnStart;
        CopilotService.OnTurnEnd += HandleTurnEnd;

        await Initialize();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_needsRedirect && _redirectTo != null)
        {
            _needsRedirect = false;
            Nav.NavigateTo(_redirectTo);
        }
        if (firstRender || _needsScroll)
        {
            _needsScroll = false;
            await ForceScrollToBottom();
        }
    }

    private void HandleToolStarted(string sessionName, string toolName, string callId)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        var msg = ChatMessage.ToolCallMessage(toolName, callId);
        activeSession?.History.Add(msg);
        InvokeAsync(async () => { StateHasChanged(); await ScrollToBottom(); });
    }

    private void HandleToolCompleted(string sessionName, string callId, string result, bool success)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        var msg = activeSession.History.LastOrDefault(m =>
            m.MessageType == ChatMessageType.ToolCall && !m.IsComplete &&
            (!string.IsNullOrEmpty(callId) ? m.ToolCallId == callId : true));
        if (msg == null)
            msg = activeSession.History.LastOrDefault(m => m.MessageType == ChatMessageType.ToolCall && !m.IsComplete);
        if (msg != null)
        {
            msg.IsComplete = true;
            msg.IsSuccess = success;
            msg.Content = result;
            msg.IsCollapsed = true;
        }
        InvokeAsync(async () => { StateHasChanged(); await ScrollToBottom(); });
    }

    private void HandleReasoningReceived(string sessionName, string reasoningId, string content)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        var msg = activeSession.History.LastOrDefault(m =>
            m.MessageType == ChatMessageType.Reasoning && m.ReasoningId == reasoningId);
        if (msg == null)
        {
            msg = activeSession.History.LastOrDefault(m => m.MessageType == ChatMessageType.Reasoning && !m.IsComplete);
        }
        if (msg == null)
        {
            msg = ChatMessage.ReasoningMessage(reasoningId);
            activeSession.History.Add(msg);
        }
        msg.Content += content;
        InvokeAsync(async () => { StateHasChanged(); await ScrollToBottom(); });
    }

    private void HandleReasoningComplete(string sessionName, string reasoningId)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        var msg = activeSession.History.LastOrDefault(m =>
            m.MessageType == ChatMessageType.Reasoning &&
            (m.ReasoningId == reasoningId || !m.IsComplete));
        if (msg != null)
        {
            msg.IsComplete = true;
            msg.IsCollapsed = true;
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleIntentChanged(string sessionName, string intent)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = intent;
        InvokeAsync(StateHasChanged);
    }

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        if (currentUsage == null)
        {
            currentUsage = info;
        }
        else
        {
            currentUsage = new SessionUsageInfo(
                info.Model ?? currentUsage.Model,
                info.CurrentTokens ?? currentUsage.CurrentTokens,
                info.TokenLimit ?? currentUsage.TokenLimit,
                info.InputTokens ?? currentUsage.InputTokens,
                info.OutputTokens ?? currentUsage.OutputTokens);
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnStart(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        // Complete any open reasoning blocks from prior turn
        foreach (var m in activeSession.History.Where(m => m.MessageType == ChatMessageType.Reasoning && !m.IsComplete))
        {
            m.IsComplete = true;
            m.IsCollapsed = true;
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnEnd(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = "";
        // Complete any open reasoning blocks
        if (activeSession != null)
        {
            foreach (var m in activeSession.History.Where(m => m.MessageType == ChatMessageType.Reasoning && !m.IsComplete))
            {
                m.IsComplete = true;
                m.IsCollapsed = true;
            }
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleDebug(string message)
    {
        debugLog = $"{DateTime.Now:HH:mm:ss} {message}\n{debugLog}";
        if (debugLog.Length > 10000) debugLog = debugLog[..10000];
        if (showDebugPanel) InvokeAsync(StateHasChanged);
    }

    private string FilteredDebugLog =>
        string.IsNullOrWhiteSpace(debugFilter) ? debugLog :
        string.Join("\n", debugLog.Split('\n')
            .Where(l => l.Contains(debugFilter, StringComparison.OrdinalIgnoreCase)));

    private async Task Initialize()
    {
        initError = null;
        try
        {
            await CopilotService.InitializeAsync();
            await CopilotService.RestorePreviousSessionsAsync();
            var uiState = CopilotService.LoadUiState();
            if (uiState != null)
            {
                if (!string.IsNullOrEmpty(uiState.ActiveSession))
                    CopilotService.SetActiveSession(uiState.ActiveSession);
                if (uiState.CurrentPage is "/dashboard")
                {
                    _needsRedirect = true;
                    _redirectTo = "/dashboard";
                }
            }
        }
        catch (Exception ex)
        {
            initError = $"Failed to connect: {ex.Message}";
        }
        RefreshState();
    }

    private void HandleError(string sessionName, string error)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            lastError = error;
            InvokeAsync(StateHasChanged);
        }
    }

    private void RefreshState()
    {
        var prev = activeSession?.Name;
        activeSession = CopilotService.GetActiveSession();
        if (activeSession?.Name != prev)
        {
            _needsScroll = true;
            visibleMessageCount = 50; // Reset window when switching sessions
        }
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    private void HandleContentReceived(string sessionName, string content)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            streamingContent += content;
            InvokeAsync(async () =>
            {
                StateHasChanged();
                await ScrollToBottom();
            });
        }
    }

    private void HandleSessionComplete(string sessionName, string summary)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            currentIntent = "";
        }
        InvokeAsync(async () =>
        {
            try { await JS.InvokeVoidAsync("showNotification", sessionName, summary); }
            catch { }
        });
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            shouldPreventDefault = true;
            await SendMessage();
            // Force-clear via JS to remove any residual newline
            await JS.InvokeVoidAsync("eval", "document.querySelector('.input-row textarea').value = ''");
        }
        else
        {
            shouldPreventDefault = false;
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput) || activeSession == null)
            return;

        var prompt = userInput.Trim();
        if (isPlanMode)
            prompt = $"[[PLAN]] {prompt}";
        userInput = "";

        if (activeSession.IsProcessing)
        {
            CopilotService.EnqueueMessage(activeSession.Name, prompt);
            return;
        }

        streamingContent = "";
        currentIntent = "";
        lastError = null;

        try
        {
            await CopilotService.SendPromptAsync(activeSession.Name, prompt);
            streamingContent = "";
        }
        catch (Exception ex)
        {
            lastError = $"Error: {ex.Message}";
        }
        await ForceScrollToBottom();
    }

    private void RemoveQueuedMessage(int index)
    {
        if (activeSession != null) CopilotService.RemoveQueuedMessage(activeSession.Name, index);
    }

    private void ClearQueue()
    {
        if (activeSession != null) CopilotService.ClearQueue(activeSession.Name);
    }

    private async Task CopySessionId(string sessionId)
    {
        await JS.InvokeVoidAsync("eval", $"navigator.clipboard.writeText('{sessionId}')");
    }

    private async Task InspectDom()
    {
        var result = await JS.InvokeAsync<string>("inspectMessages");
        debugLog += $"\n[DOM Inspect]\n{result}\n";
        StateHasChanged();
    }

    private string GetInputPlaceholder()
    {
        if (isPlanMode) return "Plan mode: describe what you want planned...";
        if (activeSession?.IsProcessing == true) return "Type to queue next message...";
        return "Message... (‚èé send, ‚áß‚èé newline)";
    }

    private string Truncate(string text, int maxLen)
    {
        text = text.Replace("\n", " ").Replace("\r", "");
        return text.Length > maxLen ? text[..maxLen] + "‚Ä¶" : text;
    }

    private static readonly System.Text.RegularExpressions.Regex ImagePathRegex = new(
        @"(?<!\(|""|\w)((?:/[\w\-. ]+)+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|tiff))(?!\)|""|\w)",
        System.Text.RegularExpressions.RegexOptions.IgnoreCase | System.Text.RegularExpressions.RegexOptions.Compiled);

    private static string RenderMarkdown(string content)
    {
        if (string.IsNullOrEmpty(content)) return "";

        var key = content.GetHashCode();
        if (_markdownCache.TryGetValue(key, out var cached)) return cached;

        try
        {
            var html = Markdig.Markdown.ToHtml(content, MdPipeline);
            html = ImagePathRegex.Replace(html, match =>
            {
                var path = match.Value;
                var dataUri = FileToDataUri(path);
                if (dataUri != null)
                    return $"<img src=\"{dataUri}\" alt=\"{System.IO.Path.GetFileName(path)}\" />";
                return match.Value;
            });

            // Only cache completed (non-streaming) content ‚Äî limit cache size
            if (_markdownCache.Count < 500)
                _markdownCache[key] = html;

            return html;
        }
        catch { return System.Net.WebUtility.HtmlEncode(content).Replace("\n", "<br/>"); }
    }

    private static string FormatUserMessage(string content)
    {
        var escaped = System.Net.WebUtility.HtmlEncode(content);
        return escaped.Replace("\n", "<br/>");
    }

    private static int LineCount(string? text)
    {
        if (string.IsNullOrEmpty(text)) return 0;
        var count = 1;
        foreach (var c in text) { if (c == '\n') count++; }
        return count;
    }

    private static string FirstLines(string? text, int lines)
    {
        if (string.IsNullOrEmpty(text)) return "";
        var idx = 0;
        for (var i = 0; i < lines && idx < text.Length; i++)
        {
            var next = text.IndexOf('\n', idx);
            if (next < 0) break;
            idx = next + 1;
        }
        if (idx <= 0 || idx >= text.Length) return text;
        return text[..idx] + "‚Ä¶";
    }

    private static string FormatToolName(string toolName)
    {
        if (string.IsNullOrEmpty(toolName)) return "";
        return string.Join(" ", toolName.Split('_').Select(w =>
            w.Length > 0 ? char.ToUpperInvariant(w[0]) + w[1..].ToLowerInvariant() : w));
    }

    private static string TruncateResult(string result, int maxLength = 1500)
    {
        if (string.IsNullOrEmpty(result) || result.Length <= maxLength) return result ?? "";
        return result[..maxLength] + "\n‚Ä¶ (truncated)";
    }

    private static bool IsUnusableResult(string? content)
    {
        if (string.IsNullOrEmpty(content)) return true;
        if (content.StartsWith("GitHub.Copilot.SDK.")) return true;
        if (content is "(no result)" or "Intent logged") return true;
        return false;
    }

    private static readonly string[] ImageExtensions = { ".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".bmp", ".tiff" };

    private static string? GetImagePath(string? content)
    {
        if (string.IsNullOrWhiteSpace(content)) return null;
        var trimmed = content.Trim();
        foreach (var ext in ImageExtensions)
        {
            var idx = trimmed.LastIndexOf(ext, StringComparison.OrdinalIgnoreCase);
            if (idx < 0) continue;
            var endIdx = idx + ext.Length;
            var pathStart = trimmed.LastIndexOf(' ', idx) + 1;
            if (pathStart < 0) pathStart = 0;
            var path = trimmed[pathStart..endIdx];
            if (path.StartsWith('/') && System.IO.File.Exists(path))
                return path;
        }
        return null;
    }

    private static string? FileToDataUri(string path)
    {
        if (_imageCache.TryGetValue(path, out var cached)) return cached;
        try
        {
            if (!System.IO.File.Exists(path)) return null;
            var bytes = System.IO.File.ReadAllBytes(path);
            var ext = System.IO.Path.GetExtension(path).ToLowerInvariant();
            var mime = ext switch
            {
                ".png" => "image/png",
                ".jpg" or ".jpeg" => "image/jpeg",
                ".gif" => "image/gif",
                ".webp" => "image/webp",
                ".svg" => "image/svg+xml",
                ".bmp" => "image/bmp",
                ".tiff" or ".tif" => "image/tiff",
                _ => "application/octet-stream"
            };
            var dataUri = $"data:{mime};base64,{Convert.ToBase64String(bytes)}";
            _imageCache[path] = dataUri;
            return dataUri;
        }
        catch { return null; }
    }

    private static string FormatTokenCount(int count) =>
        count >= 1000 ? $"{count / 1000}k" : count.ToString();

    private async Task ScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("smartScrollToBottom", messagesContainer); }
        catch { }
    }

    private async Task ForceScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("scrollToBottom", messagesContainer); }
        catch { }
    }

    public void Dispose()
    {
        CopilotService.OnStateChanged -= RefreshState;
        CopilotService.OnContentReceived -= HandleContentReceived;
        CopilotService.OnSessionComplete -= HandleSessionComplete;
        CopilotService.OnError -= HandleError;
        CopilotService.OnDebug -= HandleDebug;
        CopilotService.OnToolStarted -= HandleToolStarted;
        CopilotService.OnToolCompleted -= HandleToolCompleted;
        CopilotService.OnReasoningReceived -= HandleReasoningReceived;
        CopilotService.OnReasoningComplete -= HandleReasoningComplete;
        CopilotService.OnIntentChanged -= HandleIntentChanged;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        CopilotService.OnTurnStart -= HandleTurnStart;
        CopilotService.OnTurnEnd -= HandleTurnEnd;
    }
}
