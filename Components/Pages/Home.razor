@page "/"
@using AutoPilot.App.Services
@using AutoPilot.App.Models
@inject CopilotService CopilotService
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject DevTunnelService DevTunnelService
@implements IDisposable

<div class="chat-container">
    @if (!CopilotService.IsInitialized)
    {
        <div class="initializing">
            <div class="spinner"></div>
            <p>Connecting to Copilot...</p>
            @if (!string.IsNullOrEmpty(initError))
            {
                <p class="error">@initError</p>
                <button @onclick="Initialize">Retry</button>
            }
        </div>
    }
    else if (activeSession == null)
    {
        <div class="no-session">
            <h2>Welcome to AutoPilot</h2>
            <p>Create a new session from the sidebar to start chatting with Copilot.</p>
        </div>
    }
    else
    {
        <div class="chat-header">
            <button class="session-nav-btn" title="Previous session (▲)" @onclick="() => CycleSession(true)">◀</button>
            <h2>@activeSession.Name</h2>
            <button class="session-nav-btn" title="Next session (▼)" @onclick="() => CycleSession(false)">▶</button>
            <span class="model-badge">@activeSession.Model</span>
            @if (activeSession.SessionId != null)
            {
                <span class="session-id-badge" title="Click to copy: @activeSession.SessionId" @onclick="() => CopySessionId(activeSession.SessionId)"><svg class="icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> @activeSession.SessionId[..8] <svg class="icon copy-icon" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg></span>
            }
            @if (activeSession.IsProcessing)
            {
                <span class="typing-indicator">Copilot is typing...</span>
            }
        </div>

        <div class="messages" @ref="messagesContainer">
            @if (HasMoreMessages)
            {
                <button class="load-more-btn" @onclick="LoadMoreMessages">
                    <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg>
                    Load @Math.Min(50, activeSession.History.Count - visibleMessageCount) older messages (@(activeSession.History.Count - visibleMessageCount) remaining)
                </button>
            }
            <ChatMessageList Messages="VisibleHistory"
                             StreamingContent="@streamingContent"
                             CurrentToolName="@currentToolName"
                             ToolCount="currentTurnToolCount"
                             IsProcessing="activeSession.IsProcessing"
                             Compact="false" />
        </div>

        @if (!string.IsNullOrEmpty(lastError))
        {
            <div class="error-bar">
                <span><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> @lastError</span>
                <button @onclick="() => lastError = null">×</button>
            </div>
        }

        <div class="input-area">
            @if (!string.IsNullOrEmpty(currentIntent))
            {
                <div class="intent-pill"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg> @currentIntent</div>
            }
            @if (activeSession.MessageQueue.Any())
            {
                <div class="message-queue">
                    <div class="queue-header">
                        <span><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg> Queued (@activeSession.MessageQueue.Count)</span>
                        <button class="queue-clear-btn" @onclick="ClearQueue">Clear</button>
                    </div>
                    @for (var i = 0; i < activeSession.MessageQueue.Count; i++)
                    {
                        var index = i;
                        var msg = activeSession.MessageQueue[i];
                        <div class="queue-item">
                            <span class="queue-index">@(index + 1)</span>
                            <span class="queue-text">@Truncate(msg, 80)</span>
                            <button class="queue-remove-btn" @onclick="() => RemoveQueuedMessage(index)">×</button>
                        </div>
                    }
                </div>
            }
            <div class="input-row">
                <textarea @ref="textareaRef" @bind="userInput" @bind:event="oninput" 
                          @onkeydown="HandleKeyDown"
                          placeholder="@GetInputPlaceholder()"
                          rows="1"></textarea>
                @if (activeSession.IsProcessing)
                {
                    <button class="stop-btn" @onclick="StopResponse" title="Stop response">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="1"/></svg>
                    </button>
                }
                <button @onclick="SendMessage" 
                        disabled="@(string.IsNullOrWhiteSpace(userInput))"
                        title="@(activeSession.IsProcessing ? "Queue message" : "Send message")">
                    @if (activeSession.IsProcessing)
                    {
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
                    }
                    else
                    {
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                    }
                </button>
            </div>
            <div class="input-status-bar">
                <button class="plan-icon-toggle @(isPlanMode ? "active" : "")" @onclick="() => isPlanMode = !isPlanMode" title="Toggle planning mode — prefixes messages with [[PLAN]]">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="1.5" width="12" height="13" rx="1.5"/><line x1="5" y1="5" x2="5.01" y2="5"/><line x1="7.5" y1="5" x2="11" y2="5"/><line x1="5" y1="8" x2="5.01" y2="8"/><line x1="7.5" y1="8" x2="11" y2="8"/><line x1="5" y1="11" x2="5.01" y2="11"/><line x1="7.5" y1="11" x2="11" y2="11"/></svg>
                    <span>Planning</span>
                </button>
                <span class="status-sep">·</span>
                <span class="status-model">@(currentUsage?.Model ?? activeSession.Model)</span>
                @if (currentUsage != null)
                {
                    @if (currentUsage.InputTokens.HasValue || currentUsage.OutputTokens.HasValue)
                    {
                        <span class="status-sep">·</span>
                        <span class="status-tokens">↑@FormatTokenCount(currentUsage.InputTokens ?? 0) ↓@FormatTokenCount(currentUsage.OutputTokens ?? 0)</span>
                    }
                    @if (currentUsage.CurrentTokens.HasValue && currentUsage.TokenLimit.HasValue)
                    {
                        <span class="status-sep">·</span>
                        <span class="status-ctx" title="@currentUsage.CurrentTokens.Value / @currentUsage.TokenLimit.Value tokens">@FormatTokenCount(currentUsage.CurrentTokens.Value)/@FormatTokenCount(currentUsage.TokenLimit.Value) ctx</span>
                    }
                }
                <span class="status-sep">·</span>
                <span class="status-msgs">@activeSession.History.Count msgs</span>
                <span class="status-sep">·</span>
                <button class="plan-icon-toggle @(showDebugPanel ? "active" : "")" @onclick="() => showDebugPanel = !showDebugPanel" title="Toggle debug log">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2l1.88 1.88"/><path d="M14.12 3.88L16 2"/><path d="M9 7.13v-1a3.003 3.003 0 1 1 6 0v1"/><path d="M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6"/><path d="M12 20v-9"/><path d="M6.53 9C4.6 8.8 3 7.1 3 5"/><path d="M6 13H2"/><path d="M3 21c0-2.1 1.7-3.9 3.8-4"/><path d="M20.97 5c0 2.1-1.6 3.8-3.5 4"/><path d="M22 13h-4"/><path d="M17.2 17c2.1.1 3.8 1.9 3.8 4"/></svg>
                    <span>Log</span>
                </button>
            </div>
        </div>
    }
    
    @if (showDebugPanel)
    {
        <div class="debug-panel">
            <div class="debug-header">
                <span>Debug Log</span>
                <div class="debug-actions">
                    <input type="text" class="debug-filter" placeholder="Filter..." @bind="debugFilter" @bind:event="oninput" />
                    <button @onclick="InspectDom" title="Inspect DOM"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></button>
                    <button @onclick="() => debugLog = string.Empty" title="Clear log">Clear</button>
                    <button @onclick="() => showDebugPanel = false" title="Close">✕</button>
                </div>
            </div>
            <pre>@FilteredDebugLog</pre>
        </div>
    }
</div>

@code {
    private AgentSessionInfo? activeSession;
    private string userInput = "";
    private bool isPlanMode = false;
    private string streamingContent = "";
    private string currentIntent = "";
    private SessionUsageInfo? currentUsage;
    private string? initError;
    private string? lastError;
    private string debugLog = "";
    private string debugFilter = "";
    private bool showDebugPanel = false;
    private ElementReference messagesContainer;
    private ElementReference textareaRef;
    private DotNetObjectReference<Home>? _dotNetRef;
    private bool _needsRedirect;
    private string? _redirectTo;
    private bool _needsScroll = true;
    private int visibleMessageCount = 50;

    private List<ChatMessage> VisibleHistory
    {
        get
        {
            if (activeSession == null) return new();
            try
            {
                var all = activeSession.History;
                if (all.Count <= visibleMessageCount) return all.ToList();
                return all.Skip(all.Count - visibleMessageCount).ToList();
            }
            catch (InvalidOperationException)
            {
                // Collection modified during enumeration — retry with snapshot
                return activeSession.History.ToArray().ToList();
            }
        }
    }

    private bool HasMoreMessages => activeSession != null && activeSession.History.Count > visibleMessageCount;

    private void LoadMoreMessages()
    {
        visibleMessageCount += 50;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        CopilotService.OnStateChanged += RefreshState;
        CopilotService.OnContentReceived += HandleContentReceived;
        CopilotService.OnSessionComplete += HandleSessionComplete;
        CopilotService.OnError += HandleError;
        CopilotService.OnDebug += HandleDebug;
        CopilotService.OnToolStarted += HandleToolStarted;
        CopilotService.OnToolCompleted += HandleToolCompleted;
        CopilotService.OnReasoningReceived += HandleReasoningReceived;
        CopilotService.OnReasoningComplete += HandleReasoningComplete;
        CopilotService.OnIntentChanged += HandleIntentChanged;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        CopilotService.OnTurnStart += HandleTurnStart;
        CopilotService.OnTurnEnd += HandleTurnEnd;

        await Initialize();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_needsRedirect && _redirectTo != null)
        {
            _needsRedirect = false;
            Nav.NavigateTo(_redirectTo);
        }
        if (firstRender || _needsScroll)
        {
            _needsScroll = false;
            await ForceScrollToBottom();
        }
        try { await JS.InvokeVoidAsync("setupTextareaEnterHandler", textareaRef); } catch { }
        if (_dotNetRef == null)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
        }
        try { await JS.InvokeVoidAsync("setupTabNavigation", _dotNetRef); } catch { }
    }

    private string currentToolName = "";
    private int currentTurnToolCount;

    private void HandleToolStarted(string sessionName, string toolName, string callId)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentToolName = toolName;
        currentTurnToolCount++;
        InvokeAsync(StateHasChanged);
    }

    private void HandleToolCompleted(string sessionName, string callId, string result, bool success)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        // Don't add to history — just clear current tool indicator
        currentToolName = "";
        InvokeAsync(StateHasChanged);
    }

    private void HandleReasoningReceived(string sessionName, string reasoningId, string content)
    {
        // Don't add reasoning to history — it clutters the view
        // The intent indicator already shows thinking state
    }

    private void HandleReasoningComplete(string sessionName, string reasoningId)
    {
        // No-op — reasoning not tracked in history
    }

    private void HandleIntentChanged(string sessionName, string intent)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = intent;
        InvokeAsync(StateHasChanged);
    }

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        if (currentUsage == null)
        {
            currentUsage = info;
        }
        else
        {
            currentUsage = new SessionUsageInfo(
                info.Model ?? currentUsage.Model,
                info.CurrentTokens ?? currentUsage.CurrentTokens,
                info.TokenLimit ?? currentUsage.TokenLimit,
                info.InputTokens ?? currentUsage.InputTokens,
                info.OutputTokens ?? currentUsage.OutputTokens);
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnStart(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        // Don't clear streamingContent — let it accumulate across turns
        // so messages don't vanish between tool-call-driven turns.
        // CompleteResponse will add the full response to History and 
        // SendPromptAsync clears streamingContent when done.
        currentTurnToolCount = 0;
        currentToolName = "";
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnEnd(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = "";
        currentToolName = "";
        currentTurnToolCount = 0;
        // Don't clear streamingContent here — CompleteResponse hasn't added it to History yet.
        // It gets cleared in HandleTurnStart when the next turn begins.
        InvokeAsync(StateHasChanged);
    }

    private void HandleDebug(string message)
    {
        debugLog = $"{DateTime.Now:HH:mm:ss} {message}\n{debugLog}";
        if (debugLog.Length > 10000) debugLog = debugLog[..10000];
        if (showDebugPanel) InvokeAsync(StateHasChanged);
    }

    private string FilteredDebugLog =>
        string.IsNullOrWhiteSpace(debugFilter) ? debugLog :
        string.Join("\n", debugLog.Split('\n')
            .Where(l => l.Contains(debugFilter, StringComparison.OrdinalIgnoreCase)));

    private async Task Initialize()
    {
        initError = null;
        try
        {
            await CopilotService.InitializeAsync();

            // If no remote URL configured, redirect straight to Settings
            if (CopilotService.NeedsConfiguration)
            {
                _needsRedirect = true;
                _redirectTo = "/settings";
                return;
            }

            // RestorePreviousSessionsAsync is already called inside InitializeAsync
            var uiState = CopilotService.LoadUiState();
            if (uiState != null)
            {
                if (!string.IsNullOrEmpty(uiState.ActiveSession))
                    CopilotService.SetActiveSession(uiState.ActiveSession);
                if (uiState.CurrentPage is "/dashboard" or "/settings")
                {
                    _needsRedirect = true;
                    _redirectTo = uiState.CurrentPage;
                }
            }

            // Auto-start tunnel if previously configured
            var connSettings = ConnectionSettings.Load();
            if (connSettings.AutoStartTunnel && DevTunnelService.State == TunnelState.NotStarted)
            {
                _ = Task.Run(async () =>
                {
                    try { await DevTunnelService.HostAsync(connSettings.Port); }
                    catch (Exception ex) { Console.WriteLine($"[AutoStart] Tunnel failed: {ex.Message}"); }
                });
            }
        }
        catch (Exception ex)
        {
            initError = $"Failed to connect: {ex.Message}";
        }
        RefreshState();
    }

    private void HandleError(string sessionName, string error)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            // Suppress cancellation errors (expected during app restart/abort)
            if (error.Contains("cancel", StringComparison.OrdinalIgnoreCase) ||
                error.Contains("TaskCanceled", StringComparison.OrdinalIgnoreCase))
                return;
            lastError = error;
            InvokeAsync(StateHasChanged);
        }
    }

    private void RefreshState()
    {
        var prev = activeSession?.Name;
        activeSession = CopilotService.GetActiveSession();
        if (activeSession?.Name != prev)
        {
            _needsScroll = true;
            visibleMessageCount = 50; // Reset window when switching sessions
        }
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    private void HandleContentReceived(string sessionName, string content)
    {
        if (sessionName == CopilotService.ActiveSessionName && activeSession?.IsProcessing == true)
        {
            streamingContent += content;
            InvokeAsync(async () =>
            {
                StateHasChanged();
                await ScrollToBottom();
            });
        }
    }

    private void HandleSessionComplete(string sessionName, string summary)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            currentIntent = "";
        }
        InvokeAsync(async () =>
        {
            try { await JS.InvokeVoidAsync("showNotification", sessionName, summary); }
            catch { }
        });
    }

    private string _lastKeyDebug = "";

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        _lastKeyDebug = $"Key:{e.Key} Code:{e.Code} Meta:{e.MetaKey} Ctrl:{e.CtrlKey} Shift:{e.ShiftKey}";

        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
            await JS.InvokeVoidAsync("eval", "document.querySelector('.input-row textarea').value = ''");
        }
        // Tab / Shift+Tab to cycle sessions
        if (e.Key == "Tab")
        {
            CycleSession(e.ShiftKey);
        }
        // Cmd+1 through Cmd+9 to switch sessions
        if (e.MetaKey && e.Key.Length == 1 && e.Key[0] >= '1' && e.Key[0] <= '9')
        {
            var sessions = CopilotService.GetAllSessions().ToList();
            var idx = (int)(e.Key[0] - '1');
            if (idx < sessions.Count)
            {
                CopilotService.SwitchSession(sessions[idx].Name);
                CopilotService.SaveUiState("/", sessions[idx].Name);
                StateHasChanged();
            }
        }
    }

    private async Task StopResponse()
    {
        if (activeSession == null) return;
        await CopilotService.AbortSessionAsync(activeSession.Name);
        streamingContent = "";
        StateHasChanged();
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput) || activeSession == null)
            return;

        var prompt = userInput.Trim();
        if (isPlanMode)
            prompt = $"[[PLAN]] {prompt}";
        userInput = "";

        if (activeSession.IsProcessing)
        {
            CopilotService.EnqueueMessage(activeSession.Name, prompt);
            return;
        }

        streamingContent = "";
        currentIntent = "";
        lastError = null;

        try
        {
            await CopilotService.SendPromptAsync(activeSession.Name, prompt);
            streamingContent = "";
        }
        catch (TaskCanceledException)
        {
            // Expected during abort or app restart — not an error
        }
        catch (OperationCanceledException)
        {
            // Expected during abort or app restart — not an error
        }
        catch (Exception ex)
        {
            lastError = $"Error: {ex.Message}";
        }
        await ForceScrollToBottom();
    }

    private void RemoveQueuedMessage(int index)
    {
        if (activeSession != null) CopilotService.RemoveQueuedMessage(activeSession.Name, index);
    }

    private void ClearQueue()
    {
        if (activeSession != null) CopilotService.ClearQueue(activeSession.Name);
    }

    private async Task CopySessionId(string sessionId)
    {
        await JS.InvokeVoidAsync("eval", $"navigator.clipboard.writeText('{sessionId}')");
    }

    private async Task InspectDom()
    {
        var result = await JS.InvokeAsync<string>("inspectMessages");
        debugLog += $"\n[DOM Inspect]\n{result}\n";
        StateHasChanged();
    }

    private string GetInputPlaceholder()
    {
        if (isPlanMode) return "Plan mode: describe what you want planned...";
        if (activeSession?.IsProcessing == true) return "Type to queue next message...";
        return "Message... (⏎ send, ⇧⏎ newline)";
    }

    private string Truncate(string text, int maxLen)
    {
        text = text.Replace("\n", " ").Replace("\r", "");
        return text.Length > maxLen ? text[..maxLen] + "…" : text;
    }


    private static string FormatTokenCount(int count) =>
        count >= 1000 ? $"{count / 1000}k" : count.ToString();

    private async Task ScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("smartScrollToBottom", messagesContainer); }
        catch { }
    }

    private async Task ForceScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("scrollToBottom", messagesContainer); }
        catch { }
    }

    [JSInvokable]
    public void CycleSession(bool reverse)
    {
        var sessions = CopilotService.GetAllSessions().OrderBy(s => s.Name).ToList();
        if (sessions.Count < 2) return;

        var currentName = CopilotService.ActiveSessionName;
        var idx = sessions.FindIndex(s => s.Name == currentName);
        if (idx < 0) idx = 0;

        idx = reverse
            ? (idx - 1 + sessions.Count) % sessions.Count
            : (idx + 1) % sessions.Count;

        CopilotService.SwitchSession(sessions[idx].Name);
        CopilotService.SaveUiState("/", sessions[idx].Name);
        streamingContent = "";
        currentToolName = "";
        currentIntent = "";
        visibleMessageCount = 50;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
        CopilotService.OnStateChanged -= RefreshState;
        CopilotService.OnContentReceived -= HandleContentReceived;
        CopilotService.OnSessionComplete -= HandleSessionComplete;
        CopilotService.OnError -= HandleError;
        CopilotService.OnDebug -= HandleDebug;
        CopilotService.OnToolStarted -= HandleToolStarted;
        CopilotService.OnToolCompleted -= HandleToolCompleted;
        CopilotService.OnReasoningReceived -= HandleReasoningReceived;
        CopilotService.OnReasoningComplete -= HandleReasoningComplete;
        CopilotService.OnIntentChanged -= HandleIntentChanged;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        CopilotService.OnTurnStart -= HandleTurnStart;
        CopilotService.OnTurnEnd -= HandleTurnEnd;
    }
}
