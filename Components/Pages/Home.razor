@page "/"
@using AutoPilot.App.Services
@using AutoPilot.App.Models
@inject CopilotService CopilotService
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject DevTunnelService DevTunnelService
@implements IDisposable

<div class="chat-container">
    @if (!CopilotService.IsInitialized)
    {
        <div class="initializing">
            <div class="spinner"></div>
            <p>Connecting to Copilot...</p>
            @if (!string.IsNullOrEmpty(initError))
            {
                <p class="error">@initError</p>
                <button @onclick="Initialize">Retry</button>
            }
        </div>
    }
    else if (activeSession == null)
    {
        <div class="no-session">
            <img src="autopilot_logo_lg.png" alt="AutoPilot" class="welcome-logo" />
            <h2>Welcome to AutoPilot</h2>
            <p>Create a new session from the sidebar to start chatting with Copilot.</p>
        </div>
    }
    else
    {
        <div class="chat-header">
            <h2>@activeSession.Name</h2>
            <div class="chat-header-badges">
                @if (activeSession.IsProcessing)
                {
                    <span class="processing-dot"></span>
                }
                <span class="model-badge">@activeModelOverride</span>
                @if (activeSession.SessionId != null)
                {
                    <span class="session-id-badge" title="Click to copy: @activeSession.SessionId" @onclick="() => CopySessionId(activeSession.SessionId)">üîó @activeSession.SessionId[..8] üìã</span>
                    <button class="folder-btn" title="Open session folder" @onclick="() => OpenSessionFolder(activeSession.SessionId)" @onclick:stopPropagation="true">üìÇ</button>
                }
            </div>
        </div>

        <div class="messages" @ref="messagesContainer">
            @if (HasMoreMessages)
            {
                <button class="load-more-btn" @onclick="LoadMoreMessages">
                    ‚¨ÜÔ∏è
                    Load @Math.Min(50, activeSession.History.Count - visibleMessageCount) older messages (@(activeSession.History.Count - visibleMessageCount) remaining)
                </button>
            }
            <ChatMessageList Messages="VisibleHistory"
                             StreamingContent="@streamingContent"
                             CurrentToolName="@currentToolName"
                             ToolCount="currentTurnToolCount"
                             ToolActivities="turnToolActivities"
                             IsProcessing="activeSession.IsProcessing"
                             Compact="false" />
        </div>

        @if (!string.IsNullOrEmpty(lastError))
        {
            <div class="error-bar">
                <span>‚ö†Ô∏è @lastError</span>
                <button @onclick="() => lastError = null">√ó</button>
            </div>
        }

        <div class="input-area" @ref="inputAreaRef">
            @if (!string.IsNullOrEmpty(currentIntent))
            {
                <div class="intent-pill">üí≠ @currentIntent</div>
            }
            @if (activeSession.MessageQueue.Any())
            {
                <div class="message-queue">
                    <div class="queue-header">
                        <span>üìã Queued (@activeSession.MessageQueue.Count)</span>
                        <button class="queue-clear-btn" @onclick="ClearQueue">Clear</button>
                    </div>
                    @for (var i = 0; i < activeSession.MessageQueue.Count; i++)
                    {
                        var index = i;
                        var msg = activeSession.MessageQueue[i];
                        <div class="queue-item">
                            <span class="queue-index">@(index + 1)</span>
                            <span class="queue-text">@Truncate(msg, 80)</span>
                            <button class="queue-remove-btn" @onclick="() => RemoveQueuedMessage(index)">√ó</button>
                        </div>
                    }
                </div>
            }
            @if (pendingImages.Count > 0)
            {
                <div class="attachment-strip">
                    @for (var i = 0; i < pendingImages.Count; i++)
                    {
                        var idx = i;
                        var img = pendingImages[i];
                        <div class="attachment-thumb">
                            <img src="@img.DataUri" alt="@img.FileName" />
                            <button class="attachment-remove" @onclick="() => RemoveAttachment(idx)" title="Remove">√ó</button>
                            <span class="attachment-name">@TruncateFileName(img.FileName, 15)</span>
                        </div>
                    }
                </div>
            }
            <div class="input-row">
                <button class="attach-btn" @onclick="OpenFilePicker" title="Attach image (or drag & drop)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.49"/></svg>
                </button>
                <input type="file" @ref="fileInputRef" accept="image/*" multiple style="display:none" @onchange="HandleFileSelected" />
                <textarea @ref="textareaRef" @bind="userInput" @bind:event="oninput" 
                          @onkeydown="HandleKeyDown"
                          placeholder="@GetInputPlaceholder()"
                          rows="1"></textarea>
                @if (activeSession.IsProcessing)
                {
                    <button class="stop-btn" @onclick="StopResponse" title="Stop response">
                        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="10" height="10" rx="1.5" stroke="currentColor" stroke-width="1.5"/></svg>
                    </button>
                }
                <button @onclick="SendMessage" 
                        class="send-btn"
                        disabled="@(string.IsNullOrWhiteSpace(userInput) && pendingImages.Count == 0)"
                        title="@(activeSession.IsProcessing ? "Queue message" : "Send message")">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 4l14 8-14 8V4z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/></svg>
                </button>
            </div>
            <div class="input-status-bar">
                <div class="mode-switcher">
                    <button class="mode-btn @(!isPlanMode ? "active" : "")" @onclick="() => isPlanMode = false">
                        Chat
                    </button>
                    <button class="mode-btn @(isPlanMode ? "active" : "")" @onclick="() => isPlanMode = true">
                        Plan
                    </button>
                </div>
                <span class="status-sep">¬∑</span>
                <select class="inline-model-select" @bind="activeModelOverride" title="Switch model">
                    @foreach (var m in inlineAvailableModels)
                    {
                        <option value="@m">@m</option>
                    }
                </select>
                @if (currentUsage != null)
                {
                    @if (currentUsage.InputTokens.HasValue || currentUsage.OutputTokens.HasValue)
                    {
                        <span class="status-sep">¬∑</span>
                        <span class="status-tokens">‚Üë@FormatTokenCount(currentUsage.InputTokens ?? 0) ‚Üì@FormatTokenCount(currentUsage.OutputTokens ?? 0)</span>
                    }
                    @if (currentUsage.CurrentTokens.HasValue && currentUsage.TokenLimit.HasValue)
                    {
                        <span class="status-sep">¬∑</span>
                        <span class="status-ctx" title="@currentUsage.CurrentTokens.Value / @currentUsage.TokenLimit.Value tokens">@FormatTokenCount(currentUsage.CurrentTokens.Value)/@FormatTokenCount(currentUsage.TokenLimit.Value) ctx</span>
                    }
                }
                <span class="status-sep">¬∑</span>
                <span class="status-msgs">@activeSession.History.Count msgs</span>
                <span class="status-sep">¬∑</span>
                <span class="font-size-controls">
                    <button class="font-size-btn" @onclick="DecreaseFontSize" title="Decrease font size (‚åò‚àí)" disabled="@(fontSize <= 12)">A‚àí</button>
                    <span class="font-size-label" @onclick="ResetFontSize" title="Reset to default">@(fontSize)px</span>
                    <button class="font-size-btn" @onclick="IncreaseFontSize" title="Increase font size (‚åò+)" disabled="@(fontSize >= 24)">A+</button>
                </span>
                <span class="status-sep">¬∑</span>
                <button class="plan-icon-toggle @(showDebugPanel ? "active" : "")" @onclick="() => showDebugPanel = !showDebugPanel" title="Toggle debug log">
                    <span>Log</span>
                </button>
            </div>
        </div>
    }
    
    @if (showDebugPanel)
    {
        <div class="debug-panel">
            <div class="debug-header">
                <span>Debug Log</span>
                <div class="debug-actions">
                    <input type="text" class="debug-filter" placeholder="Filter..." @bind="debugFilter" @bind:event="oninput" />
                    <button @onclick="InspectDom" title="Inspect DOM">üîç</button>
                    <button @onclick="() => debugLog = string.Empty" title="Clear log">Clear</button>
                    <button @onclick="() => showDebugPanel = false" title="Close">‚úï</button>
                </div>
            </div>
            <pre>@FilteredDebugLog</pre>
        </div>
    }
</div>

@code {
    private AgentSessionInfo? activeSession;
    private string userInput = "";
    private bool isPlanMode = false;
    private string streamingContent = "";
    private string currentIntent = "";
    private SessionUsageInfo? currentUsage;
    private string? initError;
    private string? lastError;
    private string debugLog = "";
    private string debugFilter = "";
    private bool showDebugPanel = false;
    private ElementReference messagesContainer;
    private ElementReference textareaRef;
    private ElementReference inputAreaRef;
    private ElementReference fileInputRef;
    private DotNetObjectReference<Home>? _dotNetRef;
    private bool _needsRedirect;
    private string? _redirectTo;
    private bool _needsScroll = true;
    private int visibleMessageCount = 50;
    private List<PendingImage> pendingImages = new();

    private static readonly string ImageTempDir = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
        "AutoPilot", "image-attachments");

    private record PendingImage(string FilePath, string FileName, string DataUri);
    private int fontSize = 20;

    private readonly string[] inlineAvailableModels = new[]
    {
        "claude-opus-4.6",
        "claude-sonnet-4.5",
        "claude-sonnet-4",
        "claude-haiku-4.5",
        "gpt-5.2",
        "gpt-5.1",
        "gpt-5",
        "gpt-5-mini",
        "gemini-3-pro-preview",
    };

    private string activeModelOverride
    {
        get
        {
            // Priority: usage model (actual from SDK) > session model (if not "resumed") > fallback
            var model = currentUsage?.Model;
            if (string.IsNullOrEmpty(model) || !inlineAvailableModels.Contains(model))
            {
                model = activeSession?.Model;
                if (string.IsNullOrEmpty(model) || model == "resumed" || !inlineAvailableModels.Contains(model))
                    model = _selectedModelOverride ?? inlineAvailableModels[0];
            }
            return model;
        }
        set
        {
            _selectedModelOverride = value;
            if (activeSession != null && activeSession.Model != "resumed")
                activeSession.Model = value;
            StateHasChanged();
        }
    }
    private string? _selectedModelOverride;

    private List<ChatMessage> VisibleHistory
    {
        get
        {
            if (activeSession == null) return new();
            try
            {
                var all = activeSession.History;
                if (all.Count <= visibleMessageCount) return all.ToList();
                return all.Skip(all.Count - visibleMessageCount).ToList();
            }
            catch (InvalidOperationException)
            {
                // Collection modified during enumeration ‚Äî retry with snapshot
                return activeSession.History.ToArray().ToList();
            }
        }
    }

    private bool HasMoreMessages => activeSession != null && activeSession.History.Count > visibleMessageCount;

    private void LoadMoreMessages()
    {
        visibleMessageCount += 50;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        CopilotService.OnStateChanged += RefreshState;
        CopilotService.OnContentReceived += HandleContentReceived;
        CopilotService.OnSessionComplete += HandleSessionComplete;
        CopilotService.OnError += HandleError;
        CopilotService.OnDebug += HandleDebug;
        CopilotService.OnToolStarted += HandleToolStarted;
        CopilotService.OnToolCompleted += HandleToolCompleted;
        CopilotService.OnReasoningReceived += HandleReasoningReceived;
        CopilotService.OnReasoningComplete += HandleReasoningComplete;
        CopilotService.OnIntentChanged += HandleIntentChanged;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        CopilotService.OnTurnStart += HandleTurnStart;
        CopilotService.OnTurnEnd += HandleTurnEnd;

        await Initialize();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_needsRedirect && _redirectTo != null)
        {
            _needsRedirect = false;
            Nav.NavigateTo(_redirectTo);
        }
        if (firstRender || _needsScroll)
        {
            _needsScroll = false;
            await ForceScrollToBottom();
        }
        if (firstRender && fontSize != 20)
        {
            try { await JS.InvokeVoidAsync("setAppFontSize", fontSize); } catch { }
        }
        try { await JS.InvokeVoidAsync("setupTextareaEnterHandler", textareaRef); } catch { }
        if (_dotNetRef == null)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
        }
        try { await JS.InvokeVoidAsync("setupTabNavigation", _dotNetRef); } catch { }
        try { await JS.InvokeVoidAsync("setupImageDropZone", inputAreaRef, _dotNetRef); } catch { }
    }

    private string currentToolName = "";
    private int currentTurnToolCount;
    private List<ToolActivity> turnToolActivities = new();

    private void HandleToolStarted(string sessionName, string toolName, string callId, string? inputSummary)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentToolName = toolName;
        currentTurnToolCount++;
        turnToolActivities.Add(new ToolActivity
        {
            Name = toolName,
            CallId = callId,
            Input = inputSummary,
            StartedAt = DateTime.Now
        });
        InvokeAsync(StateHasChanged);
    }

    private void HandleToolCompleted(string sessionName, string callId, string result, bool success)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        var activity = turnToolActivities.LastOrDefault(a => a.CallId == callId);
        if (activity != null)
        {
            activity.IsComplete = true;
            activity.IsSuccess = success;
            activity.Result = result;
            activity.CompletedAt = DateTime.Now;
        }
        currentToolName = "";
        InvokeAsync(StateHasChanged);
    }

    private void HandleReasoningReceived(string sessionName, string reasoningId, string content)
    {
        // Don't add reasoning to history ‚Äî it clutters the view
        // The intent indicator already shows thinking state
    }

    private void HandleReasoningComplete(string sessionName, string reasoningId)
    {
        // No-op ‚Äî reasoning not tracked in history
    }

    private void HandleIntentChanged(string sessionName, string intent)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = intent;
        InvokeAsync(StateHasChanged);
    }

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        if (currentUsage == null)
        {
            currentUsage = info;
        }
        else
        {
            currentUsage = new SessionUsageInfo(
                info.Model ?? currentUsage.Model,
                info.CurrentTokens ?? currentUsage.CurrentTokens,
                info.TokenLimit ?? currentUsage.TokenLimit,
                info.InputTokens ?? currentUsage.InputTokens,
                info.OutputTokens ?? currentUsage.OutputTokens);
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnStart(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        currentTurnToolCount = 0;
        currentToolName = "";
        turnToolActivities.Clear();
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnEnd(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = "";
        currentToolName = "";
        currentTurnToolCount = 0;
        // Don't clear streamingContent here ‚Äî CompleteResponse hasn't added it to History yet.
        // It gets cleared in HandleTurnStart when the next turn begins.
        InvokeAsync(StateHasChanged);
    }

    private void HandleDebug(string message)
    {
        debugLog = $"{DateTime.Now:HH:mm:ss} {message}\n{debugLog}";
        if (debugLog.Length > 10000) debugLog = debugLog[..10000];
        if (showDebugPanel) InvokeAsync(StateHasChanged);
    }

    private string FilteredDebugLog =>
        string.IsNullOrWhiteSpace(debugFilter) ? debugLog :
        string.Join("\n", debugLog.Split('\n')
            .Where(l => l.Contains(debugFilter, StringComparison.OrdinalIgnoreCase)));

    private async Task Initialize()
    {
        initError = null;
        try
        {
            await CopilotService.InitializeAsync();

            // If no remote URL configured, redirect straight to Settings
            if (CopilotService.NeedsConfiguration)
            {
                _needsRedirect = true;
                _redirectTo = "/settings";
                return;
            }

            // RestorePreviousSessionsAsync is already called inside InitializeAsync
            var uiState = CopilotService.LoadUiState();
            if (uiState != null)
            {
                if (!string.IsNullOrEmpty(uiState.ActiveSession))
                    CopilotService.SetActiveSession(uiState.ActiveSession);
                if (uiState.FontSize >= 12 && uiState.FontSize <= 24)
                    fontSize = uiState.FontSize;
                if (uiState.CurrentPage is "/dashboard" or "/settings")
                {
                    _needsRedirect = true;
                    _redirectTo = uiState.CurrentPage;
                }
            }

            // Auto-start tunnel if previously configured
            var connSettings = ConnectionSettings.Load();
            if (connSettings.AutoStartTunnel && DevTunnelService.State == TunnelState.NotStarted)
            {
                _ = Task.Run(async () =>
                {
                    try { await DevTunnelService.HostAsync(connSettings.Port); }
                    catch (Exception ex) { Console.WriteLine($"[AutoStart] Tunnel failed: {ex.Message}"); }
                });
            }
        }
        catch (Exception ex)
        {
            initError = $"Failed to connect: {ex.Message}";
        }
        RefreshState();
    }

    private void HandleError(string sessionName, string error)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            // Suppress cancellation errors (expected during app restart/abort)
            if (error.Contains("cancel", StringComparison.OrdinalIgnoreCase) ||
                error.Contains("TaskCanceled", StringComparison.OrdinalIgnoreCase))
                return;
            lastError = error;
            InvokeAsync(StateHasChanged);
        }
    }

    private bool _forceNextScroll = false;

    private void RefreshState()
    {
        var prev = activeSession?.Name;
        activeSession = CopilotService.GetActiveSession();
        if (activeSession?.Name != prev)
        {
            _needsScroll = true;
            visibleMessageCount = 50; // Reset window when switching sessions
            // Clear per-session UI state so previous session's state doesn't bleed
            streamingContent = "";
            currentIntent = "";
            currentToolName = "";
            currentTurnToolCount = 0;
            currentUsage = null;
            turnToolActivities.Clear();
        }
        InvokeAsync(async () =>
        {
            StateHasChanged();
            if (_forceNextScroll)
            {
                _forceNextScroll = false;
                await ForceScrollToBottom();
            }
            else
            {
                await ScrollToBottom();
            }
        });
    }

    private void HandleContentReceived(string sessionName, string content)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession?.IsProcessing != true)
            return;

        streamingContent += content;
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    private void HandleSessionComplete(string sessionName, string summary)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            currentIntent = "";
            streamingContent = "";
        }
        InvokeAsync(async () =>
        {
            StateHasChanged();
            try { await JS.InvokeVoidAsync("showNotification", sessionName, summary); }
            catch { }
        });
    }

    private string _lastKeyDebug = "";

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        _lastKeyDebug = $"Key:{e.Key} Code:{e.Code} Meta:{e.MetaKey} Ctrl:{e.CtrlKey} Shift:{e.ShiftKey}";

        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
            await JS.InvokeVoidAsync("eval", "document.querySelector('.input-row textarea').value = ''");
        }
        // Tab / Shift+Tab to cycle sessions
        if (e.Key == "Tab")
        {
            CycleSession(e.ShiftKey);
        }
        // Cmd+1 through Cmd+9 to switch sessions
        if (e.MetaKey && e.Key.Length == 1 && e.Key[0] >= '1' && e.Key[0] <= '9')
        {
            var sessions = CopilotService.GetAllSessions().ToList();
            var idx = (int)(e.Key[0] - '1');
            if (idx < sessions.Count)
            {
                CopilotService.SwitchSession(sessions[idx].Name);
                CopilotService.SaveUiState("/", sessions[idx].Name);
                StateHasChanged();
            }
        }
        // Cmd+Plus / Cmd+Minus to adjust font size
        if (e.MetaKey && (e.Key == "=" || e.Key == "+")) IncreaseFontSize();
        if (e.MetaKey && e.Key == "-") DecreaseFontSize();
        if (e.MetaKey && e.Key == "0") ResetFontSize();
    }

    private async Task StopResponse()
    {
        if (activeSession == null) return;
        await CopilotService.AbortSessionAsync(activeSession.Name);
        streamingContent = "";
        StateHasChanged();
    }

    private async Task SendMessage()
    {
        if ((string.IsNullOrWhiteSpace(userInput) && pendingImages.Count == 0) || activeSession == null)
            return;

        var prompt = userInput.Trim();
        
        // Prepend image file paths
        if (pendingImages.Count > 0)
        {
            var imagePaths = string.Join("\n", pendingImages.Select(img => img.FilePath));
            prompt = string.IsNullOrEmpty(prompt)
                ? $"I've attached {pendingImages.Count} image(s) for you to look at:\n{imagePaths}"
                : $"{imagePaths}\n\n{prompt}";
            pendingImages.Clear();
        }
        
        if (isPlanMode)
            prompt = $"[[PLAN]] {prompt}";
        userInput = "";

        if (activeSession.IsProcessing)
        {
            CopilotService.EnqueueMessage(activeSession.Name, prompt);
            return;
        }

        _forceNextScroll = true;
        streamingContent = "";
        currentIntent = "";
        lastError = null;
        StateHasChanged();
        await ForceScrollToBottom();

        try
        {
            await CopilotService.SendPromptAsync(activeSession.Name, prompt);
            streamingContent = "";
        }
        catch (TaskCanceledException)
        {
            // Expected during abort or app restart ‚Äî not an error
        }
        catch (OperationCanceledException)
        {
            // Expected during abort or app restart ‚Äî not an error
        }
        catch (Exception ex)
        {
            lastError = $"Error: {ex.Message}";
        }
        await ForceScrollToBottom();
    }

    private void RemoveQueuedMessage(int index)
    {
        if (activeSession != null) CopilotService.RemoveQueuedMessage(activeSession.Name, index);
    }

    private void ClearQueue()
    {
        if (activeSession != null) CopilotService.ClearQueue(activeSession.Name);
    }

    // Image attachment methods
    [JSInvokable]
    public void OnImageDropped(string base64Data, string fileName, string extension)
    {
        try
        {
            Directory.CreateDirectory(ImageTempDir);
            var safeName = $"{DateTime.Now:yyyyMMdd_HHmmss}_{Guid.NewGuid().ToString("N")[..8]}.{extension}";
            var filePath = Path.Combine(ImageTempDir, safeName);
            var bytes = Convert.FromBase64String(base64Data);
            File.WriteAllBytes(filePath, bytes);
            
            var mime = extension.ToLowerInvariant() switch
            {
                "png" => "image/png",
                "jpg" or "jpeg" => "image/jpeg",
                "gif" => "image/gif",
                "webp" => "image/webp",
                "svg" => "image/svg+xml",
                "bmp" => "image/bmp",
                _ => "image/png"
            };
            var dataUri = $"data:{mime};base64,{base64Data}";
            pendingImages.Add(new PendingImage(filePath, fileName, dataUri));
            InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            lastError = $"Failed to save image: {ex.Message}";
            InvokeAsync(StateHasChanged);
        }
    }

    private void RemoveAttachment(int index)
    {
        if (index >= 0 && index < pendingImages.Count)
        {
            try { File.Delete(pendingImages[index].FilePath); } catch { }
            pendingImages.RemoveAt(index);
        }
    }

    private async Task OpenFilePicker()
    {
        try { await JS.InvokeVoidAsync("triggerImageFilePicker", fileInputRef); } catch { }
    }

    private async Task HandleFileSelected(ChangeEventArgs e)
    {
        // For Blazor file input, we need to read via JS since ChangeEventArgs doesn't have file data
        // Instead, use InputFile approach ‚Äî read the selected files via JS
        try
        {
            var fileData = await JS.InvokeAsync<string[]>("readSelectedFiles", fileInputRef);
            if (fileData != null)
            {
                for (var i = 0; i < fileData.Length; i += 3)
                {
                    if (i + 2 < fileData.Length)
                    {
                        OnImageDropped(fileData[i], fileData[i + 1], fileData[i + 2]);
                    }
                }
            }
        }
        catch
        {
            // Fallback: file picker worked but we couldn't read ‚Äî that's OK
        }
    }

    private static string TruncateFileName(string name, int maxLen)
    {
        if (name.Length <= maxLen) return name;
        var ext = Path.GetExtension(name);
        var stem = Path.GetFileNameWithoutExtension(name);
        var maxStem = maxLen - ext.Length - 1;
        if (maxStem < 3) return name[..maxLen];
        return stem[..maxStem] + "‚Ä¶" + ext;
    }

    private async Task CopySessionId(string sessionId)
    {
        await JS.InvokeVoidAsync("eval", $"navigator.clipboard.writeText('{sessionId}')");
    }

    private void OpenSessionFolder(string sessionId)
    {
        var path = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            ".copilot", "session-state", sessionId);
        if (Directory.Exists(path))
        {
            System.Diagnostics.Process.Start("open", path);
        }
    }

    private async Task InspectDom()
    {
        var result = await JS.InvokeAsync<string>("inspectMessages");
        debugLog += $"\n[DOM Inspect]\n{result}\n";
        StateHasChanged();
    }

    private string GetInputPlaceholder()
    {
        if (isPlanMode) return "Plan mode: describe what you want planned...";
        if (activeSession?.IsProcessing == true) return "Type to queue next message...";
        return "Message... (‚èé send, ‚áß‚èé newline)";
    }

    private string Truncate(string text, int maxLen)
    {
        text = text.Replace("\n", " ").Replace("\r", "");
        return text.Length > maxLen ? text[..maxLen] + "‚Ä¶" : text;
    }


    private static string FormatTokenCount(int count) =>
        count >= 1000 ? $"{count / 1000}k" : count.ToString();

    private void IncreaseFontSize() { if (fontSize < 24) { fontSize += 2; ApplyFontSize(); } }
    private void DecreaseFontSize() { if (fontSize > 12) { fontSize -= 2; ApplyFontSize(); } }
    private void ResetFontSize() { fontSize = 20; ApplyFontSize(); }
    private void ApplyFontSize()
    {
        _ = JS.InvokeVoidAsync("setAppFontSize", fontSize);
        CopilotService.SaveUiState("/", fontSize: fontSize);
    }

    private async Task ScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("smartScrollToBottom", messagesContainer); }
        catch { }
    }

    private async Task ForceScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("scrollToBottom", messagesContainer); }
        catch { }
    }

    [JSInvokable]
    public void CycleSession(bool reverse)
    {
        var sessions = CopilotService.GetAllSessions().OrderBy(s => s.Name).ToList();
        if (sessions.Count < 2) return;

        var currentName = CopilotService.ActiveSessionName;
        var idx = sessions.FindIndex(s => s.Name == currentName);
        if (idx < 0) idx = 0;

        idx = reverse
            ? (idx - 1 + sessions.Count) % sessions.Count
            : (idx + 1) % sessions.Count;

        CopilotService.SwitchSession(sessions[idx].Name);
        CopilotService.SaveUiState("/", sessions[idx].Name);
        streamingContent = "";
        currentToolName = "";
        currentIntent = "";
        visibleMessageCount = 50;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
        CopilotService.OnStateChanged -= RefreshState;
        CopilotService.OnContentReceived -= HandleContentReceived;
        CopilotService.OnSessionComplete -= HandleSessionComplete;
        CopilotService.OnError -= HandleError;
        CopilotService.OnDebug -= HandleDebug;
        CopilotService.OnToolStarted -= HandleToolStarted;
        CopilotService.OnToolCompleted -= HandleToolCompleted;
        CopilotService.OnReasoningReceived -= HandleReasoningReceived;
        CopilotService.OnReasoningComplete -= HandleReasoningComplete;
        CopilotService.OnIntentChanged -= HandleIntentChanged;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        CopilotService.OnTurnStart -= HandleTurnStart;
        CopilotService.OnTurnEnd -= HandleTurnEnd;
    }
}
