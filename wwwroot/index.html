<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>AutoPilot.App</title>
    <base href="/" />
    <link rel="stylesheet" href="lib/bootstrap/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="AutoPilot.App.styles.css" />
    <link rel="icon" href="data:,">
</head>

<body>

    <div class="status-bar-safe-area"></div>

    <div id="app">Loading...</div>

    <div id="blazor-error-ui" data-nosnippet>
        An unhandled error has occurred.
        <a href="." class="reload">Reload</a>
        <span class="dismiss">ðŸ—™</span>
    </div>

    <script src="_framework/blazor.webview.js" autostart="false"></script>
    <script>
        // Request notification permission on load
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }

        // Global keyboard listener â€” registered immediately on load
        document.addEventListener('keydown', function(e) {
            // Ctrl+] for next session, Ctrl+[ for previous
            if (e.ctrlKey && e.code === 'BracketRight' && window._tabDotNetRef) {
                e.preventDefault();
                window._tabDotNetRef.invokeMethodAsync('CycleSession', false);
            } else if (e.ctrlKey && e.code === 'BracketLeft' && window._tabDotNetRef) {
                e.preventDefault();
                window._tabDotNetRef.invokeMethodAsync('CycleSession', true);
            }
        }, true);

        window.setupTextareaEnterHandler = function(element) {
            if (!element || element._enterHandlerSet) return;
            element._enterHandlerSet = true;
            element.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                }
                // Tab / Shift+Tab to cycle sessions
                if (e.key === 'Tab' && window._tabDotNetRef) {
                    e.preventDefault();
                    e.stopPropagation();
                    window._tabDotNetRef.invokeMethodAsync('CycleSession', !e.shiftKey);
                }
            });
        };

        window.scrollToBottom = function(element) {
            if (element) {
                element.scrollTop = element.scrollHeight;
            }
        };

        window.smartScrollToBottom = function(element) {
            if (!element) return;
            var threshold = 150;
            var isAtBottom = (element.scrollHeight - element.scrollTop - element.clientHeight) < threshold;
            if (isAtBottom) {
                element.scrollTop = element.scrollHeight;
            }
        };

        window.isScrolledToBottom = function(element) {
            if (!element) return true;
            return (element.scrollHeight - element.scrollTop - element.clientHeight) < 150;
        };

        window.inspectMessages = function() {
            var msgs = document.querySelector('.messages');
            if (!msgs) return 'No .messages element';
            var children = msgs.children;
            var result = 'Container: w=' + msgs.clientWidth + ' h=' + msgs.clientHeight + ' scrollW=' + msgs.scrollWidth + ', display=' + getComputedStyle(msgs).display + ', flexDir=' + getComputedStyle(msgs).flexDirection + ', alignItems=' + getComputedStyle(msgs).alignItems + '\n';
            for (var i = 0; i < Math.min(children.length, 30); i++) {
                var c = children[i];
                var cs = getComputedStyle(c);
                result += i + ': <' + c.tagName + '> class="' + c.className.substring(0, 50) + '" w=' + c.clientWidth + '/' + c.offsetWidth + ' h=' + c.clientHeight + '/' + c.offsetHeight + ' display=' + cs.display + ' maxW=' + cs.maxWidth + ' width=' + cs.width + ' alignSelf=' + cs.alignSelf + ' overflow=' + cs.overflow + '\n';
            }
            var toolCards = document.querySelectorAll('.tool-card');
            if (toolCards.length > 0) {
                result += '\n=== TOOL CARDS ===\n';
                toolCards.forEach(function(tc, i) {
                    var tcs = getComputedStyle(tc);
                    var parent = tc.parentElement;
                    var ps = parent ? getComputedStyle(parent) : null;
                    result += 'TC' + i + ': w=' + tc.clientWidth + '/' + tc.offsetWidth + ' h=' + tc.clientHeight + '/' + tc.offsetHeight + ' display=' + tcs.display + ' width=' + tcs.width + ' minW=' + tcs.minWidth + ' overflow=' + tcs.overflow + '\n';
                    if (parent) result += '  parent: <' + parent.tagName + '> class="' + parent.className.substring(0, 40) + '" w=' + parent.clientWidth + ' display=' + ps.display + ' width=' + ps.width + '\n';
                });
            }
            return result;
        };

        window.setupTabNavigation = function(dotnetRef) {
            window._tabDotNetRef = dotnetRef;
        };

        window.showNotification = function(sessionName, summary) {
            // Play a sound
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEA...');
                // Simple beep instead
            } catch(e) {}

            // Browser notification
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('AutoPilot: ' + sessionName, {
                    body: summary.substring(0, 100) + (summary.length > 100 ? '...' : ''),
                    icon: 'ðŸ¤–',
                    tag: 'session-complete-' + sessionName
                });
            }
            
            // Also show in-app notification
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.innerHTML = '<strong>' + sessionName + '</strong> finished<br/>' + 
                summary.substring(0, 80) + (summary.length > 80 ? '...' : '');
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 5000);
        };
    </script>

</body>

</html>