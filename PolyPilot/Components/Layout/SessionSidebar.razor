@using PolyPilot.Services
@using PolyPilot.Models
@inject CopilotService CopilotService
@inject RepoManager RepoManager
@inject IJSRuntime JS
@inject NavigationManager Nav

@if (IsMobileTopBar)
{
    <div class="mobile-bar">
        @if (CopilotService.IsInitialized)
        {
            <button class="hamburger-btn" @onclick="ToggleFlyout">
                ‚ò∞
            </button>
        }
        <span class="mobile-title"><img src="PolyPilot_text.png" height="20" style="vertical-align:middle" /></span>
        <div class="mobile-tabs">
            <a href="/" class="mobile-tab @(currentPage == "/" || currentPage == "/dashboard" ? "active" : "")" @onclick='() => { CopilotService.SaveUiState("/"); currentPage = "/"; }' title="Dashboard"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="9"/><rect x="14" y="3" width="7" height="5"/><rect x="14" y="12" width="7" height="9"/><rect x="3" y="16" width="7" height="5"/></svg></a>
            <a href="/settings" class="mobile-tab @(currentPage == "/settings" ? "active" : "")" @onclick='() => { CopilotService.SaveUiState("/settings"); currentPage = "/settings"; }' title="Settings"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg></a>
        </div>
    </div>
}
else if (IsFlyoutPanel)
{
    <div class="sidebar-content flyout-content">
        <div class="flyout-header">
            <h3>Sessions</h3>
            <button class="flyout-close-btn" @onclick="ToggleFlyout">‚úï</button>
        </div>

        <div class="new-session-wrapper">
            <CreateSessionForm @ref="createSessionFormRef" @bind-SessionName="newSessionName"
                               @bind-SelectedModel="selectedModel"
                               AvailableModels="availableModels.ToList()"
                               IsCreating="isCreating"
                               CreateError="@createError"
                               OnCreate="HandleCreateSession"
                               OnBrowseDirectory="OpenDirectoryPicker" />
        </div>

        <div class="sidebar-divider"></div>
        @RenderSortToolbar
        @RenderSessionList
    </div>
}
else
{
    <div class="sidebar-content">
        <div class="sidebar-header">
            <div class="sidebar-header-row">
                <a href="/" class="header-logo-link" @onclick="DashboardClicked" @onclick:preventDefault="true"><img src="PolyPilot_text.png" class="header-logo-img" style="vertical-align:middle" /></a>
                <div class="header-actions">
                    <a href="/" class="header-icon-btn @(currentPage == "/" || currentPage == "/dashboard" ? "active" : "")" title="Dashboard" @onclick="DashboardClicked" @onclick:preventDefault="true"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="9"/><rect x="14" y="3" width="7" height="5"/><rect x="14" y="12" width="7" height="9"/><rect x="3" y="16" width="7" height="5"/></svg></a>
                    <a href="/settings" class="header-icon-btn @(currentPage == "/settings" ? "active" : "")" title="Settings" @onclick='() => { CopilotService.SaveUiState("/settings"); currentPage = "/settings"; }'><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg></a>
                </div>
            </div>
            <p class="status @(CopilotService.IsInitialized ? "connected" : "disconnected")" style="font-size:0.8rem">
                @if (CopilotService.IsInitialized)
                {
                    <text>‚óè @CopilotService.CurrentMode</text>
                }
                else
                {
                    <text>‚óã Disconnected</text>
                }
            </p>
        </div>

        <div class="new-session-wrapper">
            <CreateSessionForm @ref="createSessionFormRef" @bind-SessionName="newSessionName"
                               @bind-SelectedModel="selectedModel"
                               AvailableModels="availableModels.ToList()"
                               IsCreating="isCreating"
                               CreateError="@createError"
                               OnCreate="HandleCreateSession"
                               OnBrowseDirectory="OpenDirectoryPicker" />
        </div>

        <div class="sidebar-divider"></div>
        @RenderSortToolbar
        @RenderSessionList

        <div class="sidebar-footer">
            @if (showBugReport)
            {
                <div class="bug-report-inline">
                    <div class="bug-report-header">
                        <span>Report a Bug</span>
                        <button class="flyout-close-btn" @onclick="CloseFooterPanel" aria-label="Close panel">‚úï</button>
                    </div>
                    <select class="bug-report-select" @bind="selectedBugSession" aria-label="Select session to report">
                        <option value="">No specific session</option>
                        @foreach (var s in CopilotService.GetAllSessions())
                        {
                            <option value="@s.Name">@s.Name@(s.IsProcessing ? " (Thinking)" : "")</option>
                        }
                    </select>
                    <textarea class="bug-report-textarea" @bind="bugDescription" placeholder="Describe the issue you're seeing‚Ä¶" aria-label="Bug description"></textarea>
                    <details class="bug-report-details">
                        <summary>Debug info included</summary>
                        <pre class="bug-report-debug">@GetBugReportDebugInfo()</pre>
                    </details>
                    <div class="bug-report-actions">
                        @if (!string.IsNullOrEmpty(footerStatus))
                        {
                            <span class="bug-report-status @(footerStatus.StartsWith("‚úì") ? "success" : "error")">@footerStatus</span>
                        }
                        <button class="bug-report-submit" @onclick="SubmitBugReport" disabled="@footerSubmitting">
                            @(footerSubmitting ? "Submitting‚Ä¶" : "Submit Issue")
                        </button>
                    </div>
                </div>
            }
            else if (showFixIt)
            {
                <div class="bug-report-inline">
                    <div class="bug-report-header">
                        <span>Fix a Bug / Add Feature</span>
                        <button class="flyout-close-btn" @onclick="CloseFooterPanel" aria-label="Close panel">‚úï</button>
                    </div>
                    <select class="bug-report-select" @bind="selectedBugSession" aria-label="Select session">
                        <option value="">No specific session</option>
                        @foreach (var s in CopilotService.GetAllSessions())
                        {
                            <option value="@s.Name">@s.Name@(s.IsProcessing ? " (Thinking)" : "")</option>
                        }
                    </select>
                    <textarea class="bug-report-textarea" @bind="bugDescription" placeholder="Describe what to fix or build‚Ä¶" aria-label="Description"></textarea>
                    <details class="bug-report-details">
                        <summary>Debug info included</summary>
                        <pre class="bug-report-debug">@GetBugReportDebugInfo()</pre>
                    </details>
                    <div class="bug-report-actions">
                        @if (!string.IsNullOrEmpty(footerStatus))
                        {
                            <span class="bug-report-status @(footerStatus.StartsWith("‚úì") ? "success" : footerStatus.StartsWith("‚è≥") ? "" : "error")">@footerStatus</span>
                        }
                        <button class="bug-report-submit" @onclick="LaunchFixIt" disabled="@footerSubmitting">
                            @(footerSubmitting ? "Launching‚Ä¶" : "Launch Copilot")
                        </button>
                    </div>
                </div>
            }
            else
            {
                <button class="bug-report-btn" @onclick="OpenBugReport" title="Report a bug">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                    Report Bug
                </button>
                <button class="bug-report-btn fix-it-btn" @onclick="OpenFixIt" title="Fix a bug or add a feature">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>
                    Fix / Feature
                </button>
            }
        </div>
    </div>
}

@if (showDirectoryPicker)
{
    <RemoteDirectoryPicker OnSelected="OnDirectorySelected" OnCancelled="OnDirectoryPickerCancelled" />
}

@code {
    [Parameter] public bool IsMobileTopBar { get; set; }
    [Parameter] public bool IsFlyoutPanel { get; set; }
    [Parameter] public EventCallback OnToggleFlyout { get; set; }
    [Parameter] public EventCallback OnSessionSelected { get; set; }
    [Parameter] public int FontSize { get; set; } = 20;
    [Parameter] public EventCallback<int> OnFontSizeChange { get; set; }

    private async Task IncreaseFontSize()
    {
        if (FontSize < 24)
            await OnFontSizeChange.InvokeAsync(2);
    }

    private async Task DecreaseFontSize()
    {
        if (FontSize > 12)
            await OnFontSizeChange.InvokeAsync(-2);
    }

    private RenderFragment RenderSortToolbar => __builder =>
    {
        <div class="sidebar-toolbar">
            <select class="sort-select" title="Sort sessions" @onchange="OnSortModeChanged">
                <option value="LastActive" selected="@(CopilotService.Organization.SortMode == SessionSortMode.LastActive)">‚Üï Active</option>
                <option value="CreatedAt" selected="@(CopilotService.Organization.SortMode == SessionSortMode.CreatedAt)">‚Üï New</option>
                <option value="Alphabetical" selected="@(CopilotService.Organization.SortMode == SessionSortMode.Alphabetical)">‚Üï A‚ÄìZ</option>
                <option value="Manual" selected="@(CopilotService.Organization.SortMode == SessionSortMode.Manual)">‚Üï Manual</option>
            </select>
            @if (isAddingGroup)
            {
                <input type="text" class="new-group-input" id="newGroupInput"
                       placeholder="Group name..."
                       @onblur="CommitNewGroup"
                       @onkeydown="HandleNewGroupKeyDown" />
            }
            else
            {
                <div class="toolbar-actions">
                    <button class="new-group-btn" @onclick="StartAddGroup" title="New group">+ Group</button>
                    <button class="new-group-btn" @onclick="() => showAddRepo = true" title="Add repository">+ Repo</button>
                    <button class="new-group-btn" @onclick="RefreshSessionsManually" title="Refresh sessions">‚Üª Refresh</button>
                </div>
            }
        </div>
    };

    private RenderFragment RenderSessionList => __builder =>
    {
        @if (showAddRepo)
        {
            <div class="add-repo-form">
                <input type="text" @bind="newRepoUrl" placeholder="owner/repo or full URL" class="repo-url-input" />
                @if (confirmRepoReplace)
                {
                    <div class="repo-confirm">
                        <span>@confirmRepoName already exists. Re-fetch?</span>
                        <div class="repo-confirm-actions">
                            <button class="btn-repo-add" @onclick="ConfirmAddRepository">Yes</button>
                            <button class="btn-repo-cancel" @onclick="() => { confirmRepoReplace = false; confirmRepoName = null; }">No</button>
                        </div>
                    </div>
                }
                else
                {
                    <div class="add-repo-actions">
                        <button class="btn-repo-add" @onclick="AddRepository" disabled="@(isAddingRepo || string.IsNullOrWhiteSpace(newRepoUrl))">
                            @(isAddingRepo ? "Cloning..." : "Add")
                        </button>
                        <button class="btn-repo-cancel" @onclick="() => { showAddRepo = false; addRepoError = null; }">Cancel</button>
                    </div>
                }
                @if (isAddingRepo && !string.IsNullOrEmpty(addRepoProgress))
                {
                    <div class="repo-progress">@addRepoProgress</div>
                }
                @if (!string.IsNullOrEmpty(addRepoError))
                {
                    <div class="repo-error">‚ö† @addRepoError</div>
                }
            </div>
        }

        <div class="session-list">
            @{
                var organized = CopilotService.GetOrganizedSessions().ToList();
                var showGroupHeaders = CopilotService.HasMultipleGroups;
                var sessionIndex = 0;
            }

            @if (!sessions.Any() && !CopilotService.HasMultipleGroups)
            {
                <div class="section-header"><span class="section-header-label">Active Sessions</span></div>
                <p class="no-sessions">No active sessions.<br/>Create one above or resume below.</p>
            }

            @if (sessions.Any() || CopilotService.HasMultipleGroups)
            {
                @if (!showGroupHeaders)
                {
                    <div class="section-header"><span class="section-header-label">Active Sessions</span></div>
                }

                @foreach (var (group, groupSessions) in organized)
                {
                    @if (showGroupHeaders)
                    {
                        var isRepoGroup = !string.IsNullOrEmpty(group.RepoId);
                        var repoForGroup = isRepoGroup ? RepoManager.Repositories.FirstOrDefault(r => r.Id == group.RepoId) : null;
                        var groupTitle = repoForGroup != null ? $"{repoForGroup.Url}\n{repoForGroup.BareClonePath}" : "";
                        <div class="group-header @(group.IsCollapsed ? "collapsed" : "") @(isRepoGroup ? "repo-group" : "")"
                             title="@groupTitle"
                             @onclick="() => CopilotService.ToggleGroupCollapsed(group.Id)">
                            <span class="group-chevron">@(group.IsCollapsed ? "‚ñ∂" : "‚ñº")</span>
                            @if (isRepoGroup)
                            {
                                <span class="group-repo-icon" title="Repository">‚å•</span>
                            }
                            <span class="group-name">@group.Name</span>
                            <span class="group-count">@groupSessions.Count</span>
                            @if (group.IsCollapsed && groupSessions.Any(s => s.IsProcessing))
                            {
                                <span class="group-busy-dot"></span>
                            }
                            @if (group.Id != SessionGroup.DefaultId)
                            {
                                @if (isRepoGroup && confirmRemoveRepoId == group.RepoId)
                                {
                                    var rId = group.RepoId!;
                                    var gId = group.Id;
                                    <span class="repo-remove-confirm" @onclick:stopPropagation="true">
                                        <span class="repo-remove-label">Delete folder?</span>
                                        <button class="btn-repo-rm" @onclick="() => RemoveRepo(rId, gId, true)">Yes</button>
                                        <button class="btn-repo-rm" @onclick="() => RemoveRepo(rId, gId, false)">No</button>
                                        <button class="btn-repo-rm cancel" @onclick="() => { confirmRemoveRepoId = null; }">Cancel</button>
                                    </span>
                                }
                                else
                                {
                                    var gId = group.Id;
                                    <div class="group-menu-wrapper">
                                        <button class="group-more-btn" title="More actions"
                                                @onclick="() => { openGroupMenuId = openGroupMenuId == gId ? null : gId; }"
                                                @onclick:stopPropagation="true">‚Ä¶</button>
                                        @if (openGroupMenuId == group.Id)
                                        {
                                            <div class="group-menu-overlay" @onclick="() => { openGroupMenuId = null; }" @onclick:stopPropagation="true"></div>
                                            <div class="group-menu" @onclick:stopPropagation="true">
                                                @if (isRepoGroup)
                                                {
                                                    var rId = group.RepoId!;
                                                    <button class="group-menu-item" @onclick="() => { openGroupMenuId = null; createSessionFormRef?.ExpandForRepo(rId); }">
                                                        ‚ûï New Session
                                                    </button>
                                                    <div class="group-menu-separator"></div>
                                                    <button class="group-menu-item destructive" @onclick="() => { openGroupMenuId = null; confirmRemoveRepoId = rId; }">
                                                        üóë Remove Repo
                                                    </button>
                                                }
                                                else
                                                {
                                                    <button class="group-menu-item destructive" @onclick="() => { openGroupMenuId = null; CopilotService.DeleteGroup(gId); }">
                                                        üóë Delete Group
                                                    </button>
                                                }
                                            </div>
                                        }
                                    </div>
                                }
                            }
                        </div>
                    }

                    @if (!group.IsCollapsed || !showGroupHeaders)
                    {
                        @foreach (var session in groupSessions)
                        {
                            sessionIndex++;
                            var idx = sessionIndex;
                            var meta = CopilotService.GetSessionMeta(session.Name);
                            var sName = session.Name;
                            <SessionListItem Session="session"
                                             Meta="meta"
                                             IsActive="@(session.Name == CopilotService.ActiveSessionName)"
                                             IsCompleted="@completedSessions.Contains(session.Name)"
                                             IsRenaming="@(renamingSession == session.Name)"
                                             IsMenuOpen="@(openMenuSession == session.Name)"
                                             ShortcutIndex="idx"
                                             Groups="CopilotService.Organization.Groups"
                                             UsageInfo="@(usageBySession.TryGetValue(session.Name, out var usg) ? usg : null)"
                                             OnSelect="() => SelectSession(sName)"
                                             OnClose="() => CloseSession(sName)"
                                             OnPin="(pinned) => { CopilotService.PinSession(sName, pinned); }"
                                             OnMove="(groupId) => CopilotService.MoveSession(sName, groupId)"
                                             OnStartRename="() => StartRename(sName)"
                                             OnCommitRename="CommitRename"
                                             OnToggleMenu="() => ToggleSessionMenu(sName)"
                                             OnCloseMenu="() => { openMenuSession = null; }"
                                             OnReportBug="() => OpenBugReportForSession(sName)"
                                             OnFixWithCopilot="() => OpenFixItForSession(sName)" />
                        }
                    }
                }
            }

            @if (persistedSessions.Any())
            {
                <div class="sidebar-divider"></div>
                <div class="section-header" @onclick="TogglePersistedSessions" style="cursor: pointer;">
                    <span class="section-header-label">Saved Sessions (@filteredPersistedSessions.Count())</span>
                    <span class="toggle-icon">@(showPersistedSessions ? "‚ñº" : "‚ñ∂")</span>
                </div>
                
                @if (showPersistedSessions)
                {
                    <div class="filter-box">
                        <input type="text" @bind="sessionFilter" @bind:event="oninput" 
                               placeholder="Filter sessions..." class="filter-input" />
                    </div>
                    
                    @foreach (var persisted in filteredPersistedSessions.Take(30))
                    {
                        var isOpen = IsSessionOpen(persisted.SessionId);
                        <div class="session-item persisted @(isOpen ? "already-open" : "") @(confirmResumeId == persisted.SessionId ? "confirm-active" : "")" 
                             @onclick="async () => { if (isOpen) await SwitchToOpenSession(persisted.SessionId); else ConfirmResume(persisted); }"
                             title="@(isOpen ? "Click to switch to this session" : GetTooltip(persisted))">
                            <div class="session-info">
                                <span class="session-name persisted-name">@(persisted.Title ?? "Untitled")</span>
                                <div class="session-meta-row">
                                    <div class="session-meta-left">
                                        <span class="session-meta-time">@persisted.LastModified.ToString("MMM dd") @persisted.LastModified.ToShortTimeString()</span>
                                        @if (!string.IsNullOrEmpty(persisted.WorkingDirectory))
                                        {
                                            <span class="session-meta-dir">@GetShortPath(persisted.WorkingDirectory)</span>
                                        }
                                    </div>
                                    @if (isOpen)
                                    {
                                        <span class="open-badge">‚óè Open</span>
                                    }
                                    else if (confirmResumeId != persisted.SessionId)
                                    {
                                        <span class="resume-icon">Resume</span>
                                    }
                                </div>
                                @if (!isOpen && confirmResumeId == persisted.SessionId)
                                {
                                    <div class="resume-confirm-wrap">
                                        <div class="resume-confirm">
                                            <button class="btn-resume-yes" @onclick="() => ResumeSession(persisted)" @onclick:stopPropagation="true" disabled="@isCreating">
                                                @if (isCreating) { <span>Resuming<span class="dots"><span>.</span><span>.</span><span>.</span></span></span> } else { <span>‚ñ∂ Resume</span> }
                                            </button>
                                            <button class="btn-resume-no" @onclick="CancelResume" @onclick:stopPropagation="true">‚úï</button>
                                        </div>
                                        @if (!string.IsNullOrEmpty(resumeError))
                                        {
                                            <div class="resume-error">‚ö† @resumeError</div>
                                        }
                                    </div>
                                }
                            </div>
                        </div>
                    }
                }
            }
        </div>
    };

    private string selectedModel = "claude-opus-4.6";
    private string sessionFilter = "";
    private bool isCreating = false;
    private string newSessionName = "";
    private string? createError = null;
    private bool showPersistedSessions = false;
    private string? renamingSession = null;
    private string? confirmResumeId = null;
    private string? resumeError = null;
    private string currentPage = "/";
    private bool isAddingGroup = false;
    private string? openMenuSession = null;
    private string? openGroupMenuId = null;
    private CreateSessionForm? createSessionFormRef;
    private bool showDirectoryPicker;
    private List<AgentSessionInfo> sessions = new();
    private List<PersistedSessionInfo> persistedSessions = new();
    private bool showAddRepo = false;
    private string newRepoUrl = "";
    private string? addRepoError = null;
    private bool isAddingRepo = false;
    private string? addRepoProgress = null;
    private bool confirmRepoReplace = false;
    private string? confirmRepoName = null;
    private string? confirmRemoveRepoId = null;

    private async Task ToggleFlyout()
    {
        await OnToggleFlyout.InvokeAsync();
    }

    private static readonly string[] _fallbackModels = new[]
    {
        "claude-opus-4.6",
        "claude-opus-4.6-fast",
        "claude-opus-4.5",
        "claude-sonnet-4.5",
        "claude-sonnet-4",
        "claude-haiku-4.5",
        "gpt-5.2",
        "gpt-5.2-codex",
        "gpt-5.1",
        "gpt-5.1-codex",
        "gpt-5.1-codex-max",
        "gpt-5.1-codex-mini",
        "gpt-5",
        "gpt-5-mini",
        "gpt-4.1",
        "gemini-3-pro-preview",
    };
    private IReadOnlyList<string> availableModels =>
        CopilotService.AvailableModels.Count > 0 ? CopilotService.AvailableModels : _fallbackModels;

    private IEnumerable<PersistedSessionInfo> filteredPersistedSessions => 
        (string.IsNullOrWhiteSpace(sessionFilter) 
            ? persistedSessions 
            : persistedSessions.Where(s => 
                (s.Title?.Contains(sessionFilter, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (s.Preview?.Contains(sessionFilter, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (s.WorkingDirectory?.Contains(sessionFilter, StringComparison.OrdinalIgnoreCase) ?? false) ||
                s.SessionId.Contains(sessionFilter, StringComparison.OrdinalIgnoreCase)))
        .OrderByDescending(s => IsSessionOpen(s.SessionId))
        .ThenByDescending(s => s.LastModified);

    protected override void OnInitialized()
    {
        currentPage = new Uri(Nav.Uri).AbsolutePath;
        Nav.LocationChanged += (_, e) => { currentPage = new Uri(e.Location).AbsolutePath; InvokeAsync(StateHasChanged); };
        CopilotService.OnStateChanged += RefreshSessions;
        CopilotService.OnSessionComplete += HandleSessionComplete;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        RepoManager.OnStateChanged += OnRepoStateChanged;
        RepoManager.Load();
        RefreshSessions();
        LoadPersistedSessions();

        // Restore last selected model
        var uiState = CopilotService.LoadUiState();
        if (!string.IsNullOrEmpty(uiState?.SelectedModel))
            selectedModel = uiState.SelectedModel;
    }

    private void SaveSelectedModel()
    {
        CopilotService.SaveUiState(currentPage, selectedModel: selectedModel);
    }

    private HashSet<string> completedSessions = new();
    private Dictionary<string, SessionUsageInfo> usageBySession = new();

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (usageBySession.TryGetValue(sessionName, out var current))
        {
            usageBySession[sessionName] = new SessionUsageInfo(
                info.Model ?? current.Model,
                info.CurrentTokens ?? current.CurrentTokens,
                info.TokenLimit ?? current.TokenLimit,
                info.InputTokens ?? current.InputTokens,
                info.OutputTokens ?? current.OutputTokens);
        }
        else
        {
            usageBySession[sessionName] = info;
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleSessionComplete(string sessionName, string summary)
    {
        completedSessions.Add(sessionName);
        InvokeAsync(StateHasChanged);
        // Auto-clear highlight after 10 seconds
        _ = Task.Delay(10000).ContinueWith(_ =>
        {
            completedSessions.Remove(sessionName);
            InvokeAsync(StateHasChanged);
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Set up Enter key handler via JS to avoid Blazor round-trips on every keystroke
            await JS.InvokeVoidAsync("eval", @"
                document.getElementById('sessionNameInput')?.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.querySelector('.new-session button')?.click();
                    }
                });
            ");
        }
    }

    private DateTime _lastSidebarRefresh = DateTime.MinValue;
    private bool _sidebarRefreshPending;

    private async Task RefreshSessionsManually()
    {
        _sidebarRefreshPending = false;
        _lastSidebarRefresh = DateTime.MinValue;
        await CopilotService.RefreshSessionsAsync();
    }

    private void RefreshSessions()
    {
        var now = DateTime.UtcNow;
        if ((now - _lastSidebarRefresh).TotalMilliseconds < 500)
        {
            if (!_sidebarRefreshPending)
            {
                _sidebarRefreshPending = true;
                _ = Task.Delay(500).ContinueWith(_ => InvokeAsync(() => {
                    _sidebarRefreshPending = false;
                    _lastSidebarRefresh = DateTime.UtcNow;
                    sessions = CopilotService.GetAllSessions().ToList();
                    LoadPersistedSessions();
                    StateHasChanged();
                }));
            }
            return;
        }
        _lastSidebarRefresh = now;
        sessions = CopilotService.GetAllSessions().ToList();
        LoadPersistedSessions();
        InvokeAsync(StateHasChanged);
    }

    private void OnRepoStateChanged() => InvokeAsync(StateHasChanged);

    private void LoadPersistedSessions()
    {
        persistedSessions = CopilotService.GetPersistedSessions().ToList();
    }

    private bool IsSessionOpen(string sessionId) =>
        sessions.Any(s => s.SessionId == sessionId);

    private void TogglePersistedSessions()
    {
        showPersistedSessions = !showPersistedSessions;
    }

    private async Task HandleCreateSession((string Name, string Model, string Directory, string? WorktreeId, string? InitialPrompt) args)
    {
        if (isCreating) return;
        isCreating = true;
        createError = null;
        try
        {
            var sessionInfo = await CopilotService.CreateSessionAsync(args.Name, args.Model, args.Directory);
            CopilotService.SwitchSession(sessionInfo.Name);
            newSessionName = "";

            // If created from a worktree, place session in the repo group
            if (!string.IsNullOrEmpty(args.WorktreeId))
            {
                var wt = RepoManager.Worktrees.FirstOrDefault(w => w.Id == args.WorktreeId);
                if (wt != null)
                {
                    RepoManager.LinkSessionToWorktree(wt.Id, sessionInfo.Name);
                    var repo = RepoManager.Repositories.FirstOrDefault(r => r.Id == wt.RepoId);
                    if (repo != null)
                    {
                        var group = CopilotService.GetOrCreateRepoGroup(repo.Id, repo.Name);
                        CopilotService.MoveSession(sessionInfo.Name, group.Id);
                        var meta = CopilotService.GetSessionMeta(sessionInfo.Name);
                        if (meta != null) meta.WorktreeId = wt.Id;
                    }
                }
            }

            CopilotService.SaveUiState(currentPage, selectedModel: selectedModel);
            await OnSessionSelected.InvokeAsync();

            // Send initial prompt after session is ready
            if (!string.IsNullOrEmpty(args.InitialPrompt))
            {
                _ = CopilotService.SendPromptAsync(sessionInfo.Name, args.InitialPrompt);
            }
        }
        catch (Exception ex)
        {
            createError = ex.Message;
            Console.WriteLine($"Error creating session: {ex}");
        }
        finally
        {
            isCreating = false;
        }
    }

    private void ConfirmResume(PersistedSessionInfo persisted)
    {
        resumeError = null;
        confirmResumeId = confirmResumeId == persisted.SessionId ? null : persisted.SessionId;
    }

    private void CancelResume()
    {
        confirmResumeId = null;
        resumeError = null;
    }

    private async Task ResumeSession(PersistedSessionInfo persisted)
    {
        isCreating = true;
        resumeError = null;
        try
        {
            var title = persisted.Title ?? "Untitled";
            var displayName = title.Length > 30 ? title[..27] + "..." : title;
            var sessionInfo = await CopilotService.ResumeSessionAsync(persisted.SessionId, displayName);
            CopilotService.SwitchSession(sessionInfo.Name);
            confirmResumeId = null;
        }
        catch (Exception ex)
        {
            if (IsCorruptSessionError(ex.Message))
            {
                var deleted = CopilotService.DeletePersistedSession(persisted.SessionId);
                LoadPersistedSessions();
                confirmResumeId = deleted ? null : persisted.SessionId;
                resumeError = deleted
                    ? "Saved session was corrupted and has been removed."
                    : "Saved session is corrupted. Delete it from ~/.copilot/session-state and try again.";
            }
            else
            {
                resumeError = FriendlyResumeError(ex.Message);
            }
            Console.WriteLine($"Error resuming session: {ex.Message}");
        }
        finally
        {
            isCreating = false;
        }
    }

    private static bool IsCorruptSessionError(string message) =>
        message.Contains("session file is corrupted", StringComparison.OrdinalIgnoreCase) ||
        message.Contains("session file", StringComparison.OrdinalIgnoreCase) &&
        message.Contains("corrupt", StringComparison.OrdinalIgnoreCase);

    private string FriendlyResumeError(string message)
    {
        if (message.Contains("not found", StringComparison.OrdinalIgnoreCase) || 
            message.Contains("does not exist", StringComparison.OrdinalIgnoreCase))
            return "Session no longer exists ‚Äî it may have expired or been deleted.";
        if (message.Contains("already exists", StringComparison.OrdinalIgnoreCase))
            return "A session with this name is already open. Close it first.";
        if (message.Contains("not initialized", StringComparison.OrdinalIgnoreCase))
            return "Copilot is not connected yet. Wait for initialization.";
        if (message.Contains("timeout", StringComparison.OrdinalIgnoreCase) ||
            message.Contains("timed out", StringComparison.OrdinalIgnoreCase))
            return "Connection timed out. Check your network and try again.";
        if (message.Contains("unauthorized", StringComparison.OrdinalIgnoreCase) ||
            message.Contains("401", StringComparison.OrdinalIgnoreCase))
            return "Authentication failed. You may need to sign in again.";
        return $"Resume failed: {(message.Length > 120 ? message[..120] + "‚Ä¶" : message)}";
    }

    private async Task StartRename(string sessionName)
    {
        renamingSession = sessionName;
        StateHasChanged();
        // Focus the input after render
        await Task.Yield();
        await JS.InvokeVoidAsync("eval", @"
            var el = document.getElementById('renameInput');
            if (el) { el.focus(); el.select(); }
        ");
    }

    private async Task CommitRename()
    {
        if (renamingSession == null) return;
        var oldName = renamingSession;
        renamingSession = null;

        var newName = await JS.InvokeAsync<string>("getElementValue", "renameInput");
        if (!string.IsNullOrWhiteSpace(newName) && newName.Trim() != oldName)
        {
            CopilotService.RenameSession(oldName, newName.Trim());
        }
    }

    private async Task HandleRenameKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await CommitRename();
        }
        else if (e.Key == "Escape")
        {
            renamingSession = null;
        }
    }

    private async Task DashboardClicked()
    {
        CopilotService.SetActiveSession(null);
        CopilotService.SaveUiState("/");
        currentPage = "/";
        try { await JS.InvokeVoidAsync("eval", "window.__dashRef?.invokeMethodAsync('JsCollapseToGrid')"); } catch { }
        Nav.NavigateTo("/");
    }

    private async Task SelectSession(string name)
    {
        completedSessions.Remove(name);
        // CSS visibility already toggled by JS capture-phase click handler
        CopilotService.SwitchSession(name);
        var session = CopilotService.GetSession(name);
        if (session != null) session.LastReadMessageCount = session.History.Count;
        // Fire-and-forget to avoid blocking UI
        _ = Task.Run(() => CopilotService.SaveUiState("/", name));
        await OnSessionSelected.InvokeAsync();
        if (currentPage != "/")
            Nav.NavigateTo("/");
    }

    private async Task SwitchToOpenSession(string sessionId)
    {
        var match = sessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (match != null)
            await SelectSession(match.Name);
    }

    private async Task CloseSession(string name)
    {
        await CopilotService.CloseSessionAsync(name);
    }

    private void MoveSessionToGroup(string sessionName, ChangeEventArgs e)
    {
        if (e.Value is string groupId && !string.IsNullOrEmpty(groupId))
        {
            CopilotService.MoveSession(sessionName, groupId);
        }
    }

    private void OnSortModeChanged(ChangeEventArgs e)
    {
        if (e.Value is string val && Enum.TryParse<SessionSortMode>(val, out var mode))
        {
            CopilotService.SetSortMode(mode);
        }
    }

    private void StartAddGroup()
    {
        isAddingGroup = true;
    }

    private async Task CommitNewGroup()
    {
        var name = await JS.InvokeAsync<string>("getElementValue", "newGroupInput");
        isAddingGroup = false;
        if (!string.IsNullOrWhiteSpace(name))
        {
            CopilotService.CreateGroup(name.Trim());
        }
    }

    private async Task HandleNewGroupKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CommitNewGroup();
        else if (e.Key == "Escape") isAddingGroup = false;
    }

    private void ToggleSessionMenu(string sessionName)
    {
        openMenuSession = openMenuSession == sessionName ? null : sessionName;
    }

    private string GetTooltip(PersistedSessionInfo persisted)
    {
        var tooltip = $"Session: {persisted.SessionId}\n";
        if (!string.IsNullOrEmpty(persisted.WorkingDirectory))
            tooltip += $"Directory: {persisted.WorkingDirectory}\n";
        if (!string.IsNullOrEmpty(persisted.Preview))
            tooltip += $"\nFirst message:\n{persisted.Preview}";
        return tooltip;
    }

    private string GetShortPath(string? path)
    {
        if (string.IsNullOrEmpty(path)) return "";
        var parts = path.Split('/');
        return parts.Length > 2 ? "~/" + parts[^1] : path;
    }

    private async Task AddRepository()
    {
        if (isAddingRepo || string.IsNullOrWhiteSpace(newRepoUrl)) return;
        addRepoError = null;

        // Check if repo already exists
        var normalizedUrl = RepoManager.NormalizeRepoUrl(newRepoUrl.Trim());
        var id = RepoManager.RepoIdFromUrl(normalizedUrl);
        var existing = RepoManager.Repositories.FirstOrDefault(r => r.Id == id);
        if (existing != null)
        {
            confirmRepoReplace = true;
            confirmRepoName = existing.Name;
            return;
        }

        await DoAddRepository();
    }

    private async Task ConfirmAddRepository()
    {
        confirmRepoReplace = false;
        confirmRepoName = null;
        await DoAddRepository();
    }

    private async Task DoAddRepository()
    {
        isAddingRepo = true;
        addRepoProgress = null;
        try
        {
            var repo = await RepoManager.AddRepositoryAsync(newRepoUrl.Trim(), progress =>
            {
                addRepoProgress = progress;
                InvokeAsync(StateHasChanged);
            });
            CopilotService.GetOrCreateRepoGroup(repo.Id, repo.Name);
            showAddRepo = false;
            newRepoUrl = "";
        }
        catch (Exception ex)
        {
            addRepoError = ex.Message;
        }
        finally
        {
            isAddingRepo = false;
            addRepoProgress = null;
        }
    }

    private async Task RemoveRepo(string repoId, string groupId, bool deleteFromDisk)
    {
        confirmRemoveRepoId = null;
        try
        {
            await RepoManager.RemoveRepositoryAsync(repoId, deleteFromDisk);
            CopilotService.DeleteGroup(groupId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing repo: {ex.Message}");
        }
    }

    private void OpenDirectoryPicker()
    {
        showDirectoryPicker = true;
        StateHasChanged();
    }

    private void OnDirectorySelected(string path)
    {
        showDirectoryPicker = false;
        createSessionFormRef?.SetDirectory(path);
        StateHasChanged();
    }

    private void OnDirectoryPickerCancelled()
    {
        showDirectoryPicker = false;
        StateHasChanged();
    }

    // --- Bug Report / Fix It ---
    private bool showBugReport;
    private bool showFixIt;
    private string bugDescription = "";
    private string selectedBugSession = "";
    private bool footerSubmitting;
    private string? footerStatus;

    private void OpenBugReport()
    {
        showBugReport = true;
        showFixIt = false;
        bugDescription = "";
        selectedBugSession = "";
        footerStatus = null;
        StateHasChanged();
    }

    private void OpenFixIt()
    {
        showFixIt = true;
        showBugReport = false;
        bugDescription = "";
        selectedBugSession = "";
        footerStatus = null;
        StateHasChanged();
    }

    private async void OpenBugReportForSession(string sessionName)
    {
        if (PlatformHelper.IsMobile)
        {
            // On mobile, skip the inline form and open GitHub directly
            var debugInfo = GetBugReportDebugInfo();
            var sessionLabel = $" [{sessionName}]";
            var body = $"## Description\n(Describe the issue here)\n\n## Session\n{sessionName}\n\n## Debug Info\n```\n{debugInfo}\n```";
            var title = Uri.EscapeDataString($"[Bug Report]{sessionLabel}");
            var issueBody = Uri.EscapeDataString(body);
            var url = $"https://github.com/PureWeen/PolyPilot/issues/new?title={title}&body={issueBody}&labels=bug";
            try { await Launcher.Default.OpenAsync(new Uri(url)); } catch { }
            return;
        }
        OpenBugReport();
        selectedBugSession = sessionName;
        StateHasChanged();
    }

    private void OpenFixItForSession(string sessionName)
    {
        OpenFixIt();
        selectedBugSession = sessionName;
        StateHasChanged();
    }

    private void CloseFooterPanel()
    {
        showBugReport = false;
        showFixIt = false;
        StateHasChanged();
    }

    private string GetBugReportDebugInfo()
    {
        var sb = new System.Text.StringBuilder();
        sb.AppendLine($"Mode: {CopilotService.CurrentMode}");
        sb.AppendLine($"Initialized: {CopilotService.IsInitialized}");
        sb.AppendLine($"NeedsConfiguration: {CopilotService.NeedsConfiguration}");
        sb.AppendLine($"IsRestoring: {CopilotService.IsRestoring}");
        sb.AppendLine($"IsRemoteMode: {CopilotService.IsRemoteMode}");
        sb.AppendLine($"Sessions: {CopilotService.GetAllSessions().Count()}");
        sb.AppendLine($"Build: {BuildInfo.BuildTimestamp}");
        sb.AppendLine($"Platform: {System.Runtime.InteropServices.RuntimeInformation.OSDescription}");
        sb.AppendLine($"Arch: {System.Runtime.InteropServices.RuntimeInformation.OSArchitecture}");
        sb.AppendLine($"Runtime: {System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription}");
        if (!string.IsNullOrEmpty(CopilotService.FallbackNotice))
            sb.AppendLine($"FallbackNotice: {CopilotService.FallbackNotice}");
        sb.AppendLine($"LastDebug: {CopilotService.LastDebugMessage}");

        if (!string.IsNullOrEmpty(selectedBugSession))
        {
            var session = CopilotService.GetAllSessions().FirstOrDefault(s => s.Name == selectedBugSession);
            if (session != null)
            {
                sb.AppendLine($"--- Selected Session: {session.Name} ---");
                sb.AppendLine($"IsProcessing: {session.IsProcessing}");
                sb.AppendLine($"Model: {session.Model}");
                sb.AppendLine($"MessageCount: {session.MessageCount}");
                sb.AppendLine($"LastUpdatedAt: {session.LastUpdatedAt:o}");
                sb.AppendLine($"WorkingDirectory: {session.WorkingDirectory}");
            }
        }

        try
        {
            var crashPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                ".polypilot", "crash.log");
            if (File.Exists(crashPath))
            {
                var lines = File.ReadAllLines(crashPath);
                var tail = lines.Length > 10 ? lines[^10..] : lines;
                sb.AppendLine($"--- crash.log (last {tail.Length} lines) ---");
                foreach (var line in tail)
                    sb.AppendLine(line);
            }
        }
        catch { /* ignore */ }

        return sb.ToString();
    }

    // --- Report Bug: creates a GitHub issue ---
    private async Task SubmitBugReport()
    {
        if (string.IsNullOrWhiteSpace(bugDescription))
        {
            footerStatus = "‚úó Please describe the issue";
            return;
        }

        footerSubmitting = true;
        footerStatus = null;
        StateHasChanged();

        try
        {
            var debugInfo = GetBugReportDebugInfo();
            var sessionLabel = !string.IsNullOrEmpty(selectedBugSession) ? $" [{selectedBugSession}]" : "";
            var body = $"## Description\n{bugDescription.Trim()}\n\n## Debug Info\n```\n{debugInfo}\n```";
            var title = bugDescription.Trim().Split('\n')[0];
            if (title.Length > 80) title = title[..80];

            if (PlatformHelper.IsMobile)
            {
                // Mobile: open browser to pre-filled GitHub issue
                var issueTitle = Uri.EscapeDataString($"[Bug Report]{sessionLabel} {title}");
                var issueBody = Uri.EscapeDataString(body);
                var url = $"https://github.com/PureWeen/PolyPilot/issues/new?title={issueTitle}&body={issueBody}&labels=bug";
                await Launcher.Default.OpenAsync(new Uri(url));
                footerStatus = "‚úì Opened in browser";
                bugDescription = "";
            }
            else
            {
                var psi = new System.Diagnostics.ProcessStartInfo("gh",
                    $"issue create --repo PureWeen/PolyPilot --title \"[Bug Report]{EscapeForShell(sessionLabel)} {EscapeForShell(title)}\" --body \"{EscapeForShell(body)}\" --label bug")
                {
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                var process = System.Diagnostics.Process.Start(psi);
                if (process != null)
                {
                    var output = await process.StandardOutput.ReadToEndAsync();
                    var error = await process.StandardError.ReadToEndAsync();
                    await process.WaitForExitAsync();

                    if (process.ExitCode == 0)
                    {
                        footerStatus = $"‚úì {output.Trim()}";
                        bugDescription = "";
                    }
                    else
                    {
                        footerStatus = $"‚úó {error.Trim()}";
                    }
                }
                else
                {
                    footerStatus = "‚úó Could not start gh CLI";
                }
            }
        }
        catch (Exception ex)
        {
            footerStatus = $"‚úó {ex.Message}";
        }
        finally
        {
            footerSubmitting = false;
            StateHasChanged();
        }
    }

    // --- Fix It: creates a worktree and launches copilot in a terminal ---
    private async Task LaunchFixIt()
    {
        if (string.IsNullOrWhiteSpace(bugDescription))
        {
            footerStatus = "‚úó Please describe what to fix or build";
            return;
        }

        footerSubmitting = true;
        footerStatus = "‚è≥ Creating worktree‚Ä¶";
        StateHasChanged();

        try
        {
            var debugInfo = GetBugReportDebugInfo();
            var desc = bugDescription.Trim();
            if (!string.IsNullOrEmpty(selectedBugSession))
                desc = $"[Session: {selectedBugSession}] {desc}";
            var slugTitle = new string(desc.Split('\n')[0]
                .Where(c => char.IsLetterOrDigit(c) || c == ' ' || c == '-')
                .ToArray())
                .Trim().Replace(' ', '-').ToLowerInvariant();
            if (slugTitle.Length > 40) slugTitle = slugTitle[..40].TrimEnd('-');
            var branchName = $"fix/{slugTitle}-{DateTime.UtcNow:yyyyMMdd-HHmm}";

            var polypilotRepo = RepoManager.Repositories
                .FirstOrDefault(r => r.Url?.Contains("PolyPilot", StringComparison.OrdinalIgnoreCase) == true);

            string worktreePath;

            if (polypilotRepo != null)
            {
                var wt = await RepoManager.CreateWorktreeAsync(polypilotRepo.Id, branchName);
                worktreePath = wt.Path;
            }
            else
            {
                var repoRoot = FindGitRoot();
                if (repoRoot == null)
                {
                    footerStatus = "‚úó No PolyPilot repo found. Add it via + Repo first.";
                    return;
                }
                worktreePath = repoRoot;
                // Determine the upstream default branch to base the fix on.
                // Try upstream/main, origin/main, then fall back to current HEAD.
                var baseBranch = await GetDefaultRemoteBranch(repoRoot);
                if (baseBranch != null)
                {
                    // Fetch latest and create branch from the upstream default
                    await RunProcessAsync("git", "fetch --quiet upstream 2>/dev/null || git fetch --quiet origin", repoRoot);
                    await RunProcessAsync("git", $"checkout -b {branchName} {baseBranch}", repoRoot);
                }
                else
                {
                    await RunProcessAsync("git", $"checkout -b {branchName}", repoRoot);
                }
            }

            footerStatus = "‚è≥ Launching copilot‚Ä¶";
            StateHasChanged();

            var prompt = BuildCopilotPrompt(desc, debugInfo, branchName);
            var promptFile = Path.Combine(Path.GetTempPath(), $"polypilot-fix-{Guid.NewGuid():N}.md");
            await File.WriteAllTextAsync(promptFile, prompt);

            LaunchCopilotInTerminal(worktreePath, promptFile);

            footerStatus = "‚úì Copilot launched in new terminal";
            bugDescription = "";
        }
        catch (Exception ex)
        {
            footerStatus = $"‚úó {ex.Message}";
        }
        finally
        {
            footerSubmitting = false;
            StateHasChanged();
        }
    }

    private static string BuildCopilotPrompt(string description, string debugInfo, string branchName)
    {
        return $"""
You are fixing a bug in the PolyPilot app (a .NET MAUI Blazor Hybrid app).

## Bug Report
{description}

## Debug Info from the running app
```
{debugInfo}
```

## Instructions
1. Analyze the bug description and debug info above to understand the issue.
2. Search the codebase to find the root cause.
3. Implement a fix with the smallest possible change.
4. Add unit tests in `PolyPilot.Tests/` that cover the bug scenario and prevent regression.
5. Add UI scenario definitions to `PolyPilot.Tests/Scenarios/mode-switch-scenarios.json` if the bug involves mode switching, settings, or UI flows.
6. Run `cd PolyPilot.Tests && dotnet test` to verify all tests pass (existing + new).
7. Run `cd PolyPilot && dotnet build -f {(OperatingSystem.IsWindows() ? "net10.0-windows10.0.19041.0" : "net10.0-maccatalyst")}` to verify the app builds.
8. **Verify your branch is based on `main`** ‚Äî run `git log --oneline upstream/main..HEAD` (or `origin/main..HEAD`) and confirm only YOUR commits appear. If unrelated commits are included, the branch was created from the wrong base. Fix it: create a new branch from `upstream/main` and cherry-pick your commits onto it.
9. Commit your changes to branch `{branchName}` with a descriptive commit message.
10. Push the branch and create a PR against `main` in the PureWeen/PolyPilot repository using `gh pr create`.

Important conventions:
- Never use `static readonly` fields that call platform APIs (use lazy `??=` properties instead).
- Tests must NEVER call `ConnectionSettings.Save()` or `ConnectionSettings.Load()`.
- Use `ConnectionMode.Demo` for success paths in tests, `ConnectionMode.Persistent` with port 19999 for failure paths.
- Never force push. Always add new commits.
- Do NOT just fix the user's settings files if they are in a bad state. Instead, make the app able to recover gracefully if settings files are corrupt, missing, or in an unexpected state. Add defensive parsing, fallback defaults, and error handling so the app self-heals.
""";
    }

    private static void LaunchCopilotInTerminal(string workingDir, string promptFile)
    {
        if (OperatingSystem.IsWindows())
        {
            // Write a PowerShell script that sends the prompt as the first message
            var psScript = Path.Combine(Path.GetTempPath(), $"polypilot-launch-{Guid.NewGuid():N}.ps1");
            File.WriteAllText(psScript,
                $"Set-Location \"{workingDir}\"\n" +
                $"Write-Host \"üìã Prompt loaded from: {promptFile}\"\n" +
                $"Write-Host \"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\"\n" +
                $"Write-Host \"\"\n" +
                $"$prompt = Get-Content '{promptFile}' -Raw\n" +
                $"copilot --yolo -i \"$prompt\"\n");

            // Launch in a new Windows Terminal / cmd window
            var psi = new System.Diagnostics.ProcessStartInfo("powershell.exe",
                $"-ExecutionPolicy Bypass -NoExit -File \"{psScript}\"")
            {
                UseShellExecute = true,
                WorkingDirectory = workingDir
            };
            System.Diagnostics.Process.Start(psi);
        }
        else
        {
            // Write a shell script that sends the prompt as the first message
            var shellScript = Path.Combine(Path.GetTempPath(), $"polypilot-launch-{Guid.NewGuid():N}.sh");
            File.WriteAllText(shellScript,
                "#!/bin/bash\n" +
                $"cd \"{workingDir}\"\n" +
                $"echo \"üìã Prompt loaded from: {promptFile}\"\n" +
                $"echo \"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\"\n" +
                $"echo \"\"\n" +
                // --yolo grants all permissions
                // -i (--interactive) sends the prompt then stays interactive for follow-ups
                // (-p exits after completion; -i keeps the session open)
                $"copilot --yolo -i \"$(cat '{promptFile}')\"\n");
            System.Diagnostics.Process.Start("chmod", $"+x \"{shellScript}\"")?.WaitForExit();

            // Use 'open -a Terminal <script>' ‚Äî launches Terminal.app as a fully independent
            // process with NO sandbox inheritance from the MAUI app
            var psi = new System.Diagnostics.ProcessStartInfo("open", $"-a Terminal \"{shellScript}\"")
            {
                UseShellExecute = false,
                CreateNoWindow = true
            };
            System.Diagnostics.Process.Start(psi);
        }
    }

    private static string? FindGitRoot()
    {
        try
        {
            var dir = AppDomain.CurrentDomain.BaseDirectory;
            while (dir != null)
            {
                if (Directory.Exists(Path.Combine(dir, ".git"))) return dir;
                dir = Path.GetDirectoryName(dir);
            }
        }
        catch { }
        return null;
    }

    private static async Task RunProcessAsync(string cmd, string args, string workingDir)
    {
        var psi = new System.Diagnostics.ProcessStartInfo(cmd, args)
        {
            WorkingDirectory = workingDir,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        var p = System.Diagnostics.Process.Start(psi);
        if (p != null) await p.WaitForExitAsync();
    }

    /// <summary>
    /// Find the upstream default branch ref (e.g. "upstream/main", "origin/main").
    /// Returns null if no suitable remote branch is found.
    /// </summary>
    private static async Task<string?> GetDefaultRemoteBranch(string repoRoot)
    {
        // Prefer upstream/main (fork convention), then origin/main
        foreach (var candidate in new[] { "upstream/main", "upstream/master", "origin/main", "origin/master" })
        {
            try
            {
                var psi = new System.Diagnostics.ProcessStartInfo("git", $"rev-parse --verify {candidate}")
                {
                    WorkingDirectory = repoRoot,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };
                var p = System.Diagnostics.Process.Start(psi);
                if (p != null)
                {
                    await p.WaitForExitAsync();
                    if (p.ExitCode == 0) return candidate;
                }
            }
            catch { }
        }
        return null;
    }

    private static string EscapeForAppleScript(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"");

    private static string EscapeForShell(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("`", "\\`").Replace("$", "\\$");

    public void Dispose()
    {
        CopilotService.OnStateChanged -= RefreshSessions;
        CopilotService.OnSessionComplete -= HandleSessionComplete;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        RepoManager.OnStateChanged -= OnRepoStateChanged;
    }
}
