@page "/"
@page "/dashboard"
@using PolyPilot.Services
@using PolyPilot.Models
@inject CopilotService CopilotService
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject DevTunnelService DevTunnelService
@inject WsBridgeServer WsBridgeServer
@inject GitAutoUpdateService GitAutoUpdate
@implements IAsyncDisposable

<div class="dashboard @(expandedSession != null ? "expanded-mode" : "")">
    @if (!sessions.Any())
    {
        <div class="no-sessions-dash">
            <img src="PolyPilot_logo_lg.png" alt="PolyPilot" class="empty-logo" />
            <p class="welcome-title">Welcome to PolyPilot</p>
            @if (CopilotService.IsRestoring)
            {
                <div class="restoring-indicator">
                    <div class="restoring-spinner"></div>
                    <span>Restoring sessions‚Ä¶</span>
                </div>
            }
            @if (!string.IsNullOrEmpty(initError))
            {
                <div class="init-error-card">
                    <span class="init-error-icon">‚ö†Ô∏è</span>
                    <p class="init-error-text">@initError</p>
                    <button class="retry-btn" @onclick="Initialize">Retry</button>
                </div>
            }
            @if (PlatformHelper.IsMobile)
            {
                <button class="connect-btn" @onclick='() => Nav.NavigateTo("/settings")'>Connect to Remote Server</button>
            }
        </div>
    }
    else if (expandedSession != null)
    {
        @* Expanded single-session view *@
        var session = sessions.FirstOrDefault(s => s.Name == expandedSession);
        if (session != null)
        {
            <ExpandedSessionView Session="session"
                                 IsCompleted="@completedSessions.Contains(session.Name)"
                                 StreamingContent="@(streamingBySession.TryGetValue(session.Name, out var s2) ? s2 : "")"
                                 ActivityText="@(activityBySession.TryGetValue(session.Name, out var a2) ? a2 : "")"
                                 CurrentToolName="@(currentToolBySession.TryGetValue(session.Name, out var t2) ? t2 : "")"
                                 ToolActivities="@(toolActivitiesBySession.TryGetValue(session.Name, out var ta2) ? ta2 : new())"
                                 Intent="@(intentBySession.TryGetValue(session.Name, out var i2) ? i2 : "")"
                                 Error="@(errorBySession.TryGetValue(session.Name, out var e2) ? e2 : null)"
                                 UsageInfo="@(usageBySession.TryGetValue(session.Name, out var u2) ? u2 : null)"
                                 PlanMode="@planModeBySession.GetValueOrDefault(session.Name)"
                                 CurrentModel="@GetExpandedModel(session)"
                                 AvailableModels="availableModels"
                                 PendingImages="@(pendingImagesBySession.TryGetValue(session.Name, out var pi2) ? pi2 : null)"
                                 UserAvatarUrl="@CopilotService.GitHubAvatarUrl"
                                 Layout="@CopilotService.ChatLayout"
                                 FontSize="fontSize"
                                 MessageWindowSize="@(expandedMessageCounts.TryGetValue(session.Name, out var emc) ? emc : 25)"
                                 OnSend="() => SendFromCard(session.Name)"
                                 OnStop="() => StopSession(session.Name)"
                                 OnCollapse="CollapseExpanded"
                                 OnAttach="() => TriggerAttach(session.Name)"
                                 OnDismissError="() => DismissError(session.Name)"
                                 OnClearQueue="() => ClearQueue(session.Name)"
                                 OnRemoveQueuedMessage="(idx) => RemoveQueuedMessage(session.Name, idx)"
                                 OnRemovePendingImage="(idx) => RemovePendingImage(session.Name, idx)"
                                 OnSetPlanMode="(enabled) => SetPlanMode(session.Name, enabled)"
                                 OnSetModel="(model) => SetExpandedModel(session, model)"
                                 OnFontSizeChange="HandleFontSizeChange"
                                 OnLoadMore="() => LoadMoreExpandedMessages(session.Name)" />
        }
    }
    else
    {
        <div class="dashboard-header">
            <h2>Session Orchestrator</h2>
            <span class="session-count">@sessions.Count active sessions</span>
            @if (CopilotService.IsRemoteMode)
            {
                <span class="bridge-status @(CopilotService.IsBridgeConnected ? "connected" : "disconnected")" 
                      title="@(CopilotService.IsBridgeConnected ? "Bridge connected" : "Bridge disconnected ‚Äî reconnecting...")">
                    @(CopilotService.IsBridgeConnected ? "üü¢" : "üî¥")
                </span>
            }
            <div class="toolbar-actions">
                <button class="toolbar-overflow-btn" @onclick="() => toolbarMenuOpen = !toolbarMenuOpen"
                        @onclick:stopPropagation="true" title="More options">‚ãØ</button>
                <div class="toolbar-controls @(toolbarMenuOpen ? "open" : "")">
                    @if (isAddingDashGroup)
                    {
                        <input type="text" class="new-group-input" id="dashNewGroupInput"
                               placeholder="Group name..."
                               @onblur="CommitDashGroup"
                               @onkeydown="HandleDashGroupKeyDown" />
                    }
                    else
                    {
                        <button class="grid-density-btn" @onclick="() => { isAddingDashGroup = true; }" title="New group">+ Group</button>
                    }
                    <button class="grid-density-btn" @onclick="ToggleGridDensity" title="@(isCompactGrid ? "Expanded grid" : "Compact grid")">
                        @(isCompactGrid ? "‚ñ§ Expanded" : "‚ñ¶ Compact")
                    </button>
                    <span class="font-size-controls">
                        <button class="font-size-btn" @onclick="DecreaseFontSize" disabled="@(fontSize <= 12)" title="Decrease font size (‚åò‚àí)">A‚àí</button>
                        <span class="font-size-label" @onclick="ResetFontSize" title="Reset font size (‚åò0)">@(fontSize)px</span>
                        <button class="font-size-btn" @onclick="IncreaseFontSize" disabled="@(fontSize >= 24)" title="Increase font size (‚åò+)">A+</button>
                    </span>
                    <select class="sort-select" @onchange="OnSortModeChanged">
                        <option value="LastActive" selected="@(CopilotService.Organization.SortMode == SessionSortMode.LastActive)">‚Üï Last Active</option>
                        <option value="CreatedAt" selected="@(CopilotService.Organization.SortMode == SessionSortMode.CreatedAt)">‚Üï Created</option>
                        <option value="Alphabetical" selected="@(CopilotService.Organization.SortMode == SessionSortMode.Alphabetical)">‚Üï A‚ÄìZ</option>
                        <option value="Manual" selected="@(CopilotService.Organization.SortMode == SessionSortMode.Manual)">‚Üï Manual</option>
                    </select>
                </div>
            </div>
        </div>
        @foreach (var (group, groupSessions) in CopilotService.GetOrganizedSessions().ToList())
        {
            var showGroupHeaders = CopilotService.HasMultipleGroups;
            @if (showGroupHeaders)
            {
                <div class="group-divider @(group.IsCollapsed ? "collapsed" : "")"
                     @onclick="() => CopilotService.ToggleGroupCollapsed(group.Id)">
                    <span class="group-divider-name">@group.Name</span>
                    <span class="group-divider-count">@groupSessions.Count sessions</span>
                    @if (group.IsCollapsed && groupSessions.Any(s => s.IsProcessing))
                    {
                        <span class="group-divider-busy">‚óè working</span>
                    }
                    <span class="group-divider-chevron">@(group.IsCollapsed ? "‚ñ∂" : "‚ñº")</span>
                </div>
            }

            @if (!group.IsCollapsed || !showGroupHeaders)
            {
                <div class="session-grid @(isCompactGrid ? "" : "expanded-grid")">
                @foreach (var session in groupSessions)
                {
                    var isCompleted = completedSessions.Contains(session.Name);
                    var cardClass = session.IsProcessing ? "processing" : isCompleted ? "completed" : "idle";
                    var meta = CopilotService.GetSessionMeta(session.Name);
                    var isPinned = meta?.IsPinned ?? false;
                    <SessionCard Session="session"
                                 Meta="meta"
                                 IsCompleted="isCompleted"
                                 StreamingContent="@(streamingBySession.TryGetValue(session.Name, out var s) ? s : "")"
                                 ActivityText="@(activityBySession.TryGetValue(session.Name, out var a) ? a : "")"
                                 CurrentToolName="@(currentToolBySession.TryGetValue(session.Name, out var t) ? t : "")"
                                 ToolActivities="@(toolActivitiesBySession.TryGetValue(session.Name, out var ta) ? ta : new())"
                                 Intent="@(intentBySession.TryGetValue(session.Name, out var intentG) ? intentG : "")"
                                 Error="@(errorBySession.TryGetValue(session.Name, out var errG) ? errG : null)"
                                 PendingImages="@(pendingImagesBySession.TryGetValue(session.Name, out var pi) ? pi : new())"
                                 UserAvatarUrl="@CopilotService.GitHubAvatarUrl"
                                 Layout="@CopilotService.ChatLayout"
                                 IsRenaming="@(cardRenamingSession == session.Name)"
                                 IsMenuOpen="@(cardMenuSession == session.Name)"
                                 OnGoTo="() => GoToSession(session.Name)"
                                 OnToggleMenu="() => ToggleCardMenu(session.Name)"
                                 OnExpand="() => ExpandSession(session.Name)"
                                 OnLoadMore="() => LoadMoreCardMessages(session.Name)"
                                 OnDismissError="() => DismissError(session.Name)"
                                 OnClearQueue="() => ClearQueue(session.Name)"
                                 OnRemovePendingImage="(idx) => RemovePendingImage(session.Name, idx)"
                                 OnSend="(text) => SendFromCard(session.Name, text)"
                                 OnStartRename="() => StartCardRename(session.Name)"
                                 OnCommitRename="(newName) => CommitCardRename()"
                                 OnCloseMenu="() => { cardMenuSession = null; }" />

                }
                </div>
            }
        }
    }

    @if (_showFontBubble)
    {
        <div class="font-bubble">@(fontSize)px</div>
    }
</div>

@code {
    private List<AgentSessionInfo> sessions = new();
    private HashSet<string> completedSessions = new();
    private Dictionary<string, string> streamingBySession = new();
    private Dictionary<string, string> activityBySession = new();
    private Dictionary<string, string> draftBySession = new();
    private Dictionary<string, int> expandedMessageCounts = new();
    private Dictionary<string, List<ToolActivity>> toolActivitiesBySession = new();
    private Dictionary<string, string> currentToolBySession = new();
    private Dictionary<string, string> intentBySession = new();
    private Dictionary<string, string> errorBySession = new();
    private Dictionary<string, SessionUsageInfo> usageBySession = new();
    private Dictionary<string, bool> planModeBySession = new();
    private Dictionary<string, List<PendingImage>> pendingImagesBySession = new();
    private Dictionary<string, string> shellCwdBySession = new();
    private Dictionary<string, List<string>> commandHistoryBySession = new();
    private Dictionary<string, int> historyIndexBySession = new();
    private int fontSize = 20;
    private string? expandedSession;
    private bool _needsScrollToBottom;
    private bool isCompactGrid;  // true = compact cards, false = spacious cards
    private bool toolbarMenuOpen;
    private string? cardMenuSession;
    private string? cardRenamingSession;
    private bool isAddingDashGroup;
    private string? _focusedInputId;
    private string? _lastActiveSession;
    private int _cursorStart;
    private int _cursorEnd;
    private DotNetObjectReference<Dashboard>? _dotNetRef;
    private string? initError;
    private bool _initializationComplete = false;

    protected override async Task OnInitializedAsync()
    {
        CopilotService.OnStateChanged += RefreshState;
        CopilotService.OnSessionComplete += HandleComplete;
        CopilotService.OnContentReceived += HandleContent;
        CopilotService.OnActivity += HandleActivity;
        CopilotService.OnToolStarted += HandleToolStarted;
        CopilotService.OnToolCompleted += HandleToolCompleted;
        CopilotService.OnIntentChanged += HandleIntentChanged;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        CopilotService.OnError += HandleError;
        CopilotService.OnTurnStart += HandleTurnStart;
        CopilotService.OnTurnEnd += HandleTurnEnd;

        await Initialize();
    }

    private async Task Initialize()
    {
        initError = null;
        try
        {
            // Load UI state FIRST, before initializing (which triggers RefreshState)
            var uiState = CopilotService.LoadUiState();
            if (uiState != null)
            {
                Console.WriteLine($"[Dashboard] Restoring UI state: ExpandedSession={uiState.ExpandedSession}, ExpandedGrid={uiState.ExpandedGrid}, CurrentPage={uiState.CurrentPage}");
                
                // Restore font size
                if (uiState.FontSize >= 12 && uiState.FontSize <= 24)
                    fontSize = uiState.FontSize;
                
                // Restore expanded grid state (inverted: isCompactGrid)
                isCompactGrid = !uiState.ExpandedGrid;
                Console.WriteLine($"[Dashboard] Set isCompactGrid = {isCompactGrid} (from ExpandedGrid={uiState.ExpandedGrid})");
                
                // Restore expanded session state
                if (!string.IsNullOrEmpty(uiState.ExpandedSession))
                {
                    expandedSession = uiState.ExpandedSession;
                    _explicitlyCollapsed = false;
                    _initialGridSet = true; // Prevent RefreshState from overriding
                    // Don't set active session yet - will do after Initialize
                    Console.WriteLine($"[Dashboard] Will restore to expanded session: {uiState.ExpandedSession}");
                }
                else if (uiState.CurrentPage == "/dashboard" || uiState.CurrentPage == "/")
                {
                    // User was in grid view, don't auto-expand
                    _explicitlyCollapsed = true;
                    _initialGridSet = true; // Prevent RefreshState from overriding
                    Console.WriteLine($"[Dashboard] Will restore to grid view (no expanded session)");
                }
            }
            else
            {
                Console.WriteLine("[Dashboard] No UI state found to restore");
            }

            await CopilotService.InitializeAsync();

            // Wait for sessions to arrive (remote mode needs time to sync)
            if (!CopilotService.GetAllSessions().Any())
            {
                await Task.Delay(2000);
            }
            sessions = CopilotService.GetAllSessions().ToList();

            if (CopilotService.NeedsConfiguration)
            {
                // Stay on dashboard, user can navigate to settings manually
            }

            // Now set the active session after initialization
            if (uiState != null)
            {
                if (!string.IsNullOrEmpty(uiState.ExpandedSession))
                {
                    CopilotService.SetActiveSession(uiState.ExpandedSession);
                    _focusedInputId = $"input-{uiState.ExpandedSession.Replace(" ", "-")}";
                    _needsScrollToBottom = true;
                }
                else if (uiState.CurrentPage == "/dashboard" || uiState.CurrentPage == "/")
                {
                    CopilotService.SetActiveSession(null); // Clear any auto-set active session
                }
            }

            // When multiple sessions exist and no saved state, start on grid view
            if (sessions.Count > 1 && CopilotService.ActiveSessionName == null && uiState == null)
            {
                _explicitlyCollapsed = true;
            }

            var connSettings = ConnectionSettings.Load();
            if (connSettings.AutoStartTunnel && DevTunnelService.State == TunnelState.NotStarted)
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        var success = await DevTunnelService.HostAsync(connSettings.Port);
                        if (!success)
                        {
                            Console.WriteLine("[AutoStart] Tunnel failed, falling back to direct sharing");
                            StartDirectSharingIfEnabled(connSettings);
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[AutoStart] Tunnel error: {ex.Message}");
                        StartDirectSharingIfEnabled(connSettings);
                    }
                });
            }
            else
            {
                // No tunnel auto-start ‚Äî try direct sharing
                StartDirectSharingIfEnabled(connSettings);
            }

            GitAutoUpdate.Initialize();
            
            _initializationComplete = true; // Allow RefreshState to process changes now
        }
        catch (Exception ex)
        {
            initError = ex.Message;
            Console.WriteLine($"Init error: {ex}");
            _initializationComplete = true; // Even on error, allow normal operation
        }

        RefreshState();
    }

    private void StartDirectSharingIfEnabled(ConnectionSettings connSettings)
    {
        if (connSettings.DirectSharingEnabled && !string.IsNullOrEmpty(connSettings.ServerPassword)
            && !WsBridgeServer.IsRunning && DevTunnelService.State != TunnelState.Running)
        {
            WsBridgeServer.ServerPassword = connSettings.ServerPassword;
            WsBridgeServer.SetCopilotService(CopilotService);
            WsBridgeServer.Start(DevTunnelService.BridgePort, connSettings.Port);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("eval", @"
                if (!window.__dashboardKeydownRegistered) {
                    window.__dashboardKeydownRegistered = true;
                    document.addEventListener('keydown', function(e) {
                        var sel = '.card-input input, .card-input textarea, .input-row textarea';
                        var isInput = e.target.matches && e.target.matches(sel);
                        if (e.key === 'Enter' && !e.shiftKey && isInput) {
                            e.preventDefault();
                            if (window.__sendPending) return;
                            window.__sendPending = true;
                            setTimeout(function() { window.__sendPending = false; }, 500);
                            var container = e.target.closest('.card-input') || e.target.closest('.input-row');
                            if (container) {
                                var btn = container.querySelector('.send-btn:not(.stop-btn)') || container.querySelectorAll('button')[container.querySelectorAll('button').length - 1];
                                if (btn) btn.click();
                            }
                        }
                        // ArrowUp/Down: command history navigation
                        if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && isInput && !e.shiftKey && !e.metaKey && !e.ctrlKey) {
                            var ta = e.target;
                            var atStart = ta.selectionStart === 0 && ta.selectionEnd === 0;
                            var atEnd = ta.selectionStart === ta.value.length;
                            if ((e.key === 'ArrowUp' && atStart) || (e.key === 'ArrowDown' && atEnd)) {
                                var card = ta.closest('[data-session]');
                                var sessionName = card ? card.dataset.session : '';
                                if (sessionName && window.__dashRef) {
                                    e.preventDefault();
                                    window.__dashRef.invokeMethodAsync('JsNavigateHistory', sessionName, e.key === 'ArrowUp');
                                }
                            }
                        }
                        if (e.key === 'Tab' && isInput) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            var expandedCard = document.querySelector('.expanded-card');
                            if (expandedCard && window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsCycleExpandedSession', e.shiftKey);
                                return;
                            }
                            var inputs = Array.from(document.querySelectorAll(sel));
                            if (inputs.length < 2) return;
                            var idx = inputs.indexOf(e.target);
                            if (idx < 0) idx = 0;
                            idx = e.shiftKey ? (idx - 1 + inputs.length) % inputs.length : (idx + 1) % inputs.length;
                            inputs[idx].focus();
                            var card = inputs[idx].closest('.session-card');
                            if (card && card.dataset.session && window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsSelectSession', card.dataset.session);
                            }
                        }
                        if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
                            e.preventDefault();
                            var collapseBtn = document.querySelector('.collapse-card-btn');
                            if (collapseBtn) { collapseBtn.click(); return; }
                            var card = isInput ? e.target.closest('.session-card') : document.querySelector('.session-card');
                            if (card && card.dataset.session && window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsExpandSession', card.dataset.session);
                            }
                        }
                        if (e.key === 'Escape') {
                            var collapseBtn = document.querySelector('.collapse-card-btn');
                            if (collapseBtn) collapseBtn.click();
                        }
                        // ‚åò1-9 / Ctrl+1-9: switch to session by index
                        if ((e.metaKey || e.ctrlKey) && e.key >= '1' && e.key <= '9') {
                            e.preventDefault();
                            if (window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsSwitchToSessionByIndex', parseInt(e.key));
                            }
                        }
                        // ‚åò+/‚åò- / Ctrl+=/Ctrl+-: font size, ‚åò0 reset
                        if ((e.metaKey || e.ctrlKey) && (e.key === '=' || e.key === '+' || e.key === '-' || e.key === '0')) {
                            e.preventDefault();
                            if (window.__dashRef) {
                                var delta = (e.key === '=' || e.key === '+') ? 1 : e.key === '-' ? -1 : 0;
                                window.__dashRef.invokeMethodAsync('JsChangeFontSize', delta);
                            }
                        }
                        // Ctrl+C: interrupt running session (only when no text selected)
                        if (e.ctrlKey && e.key === 'c' && !e.metaKey && !e.shiftKey) {
                            var selection = window.getSelection();
                            if (!selection || selection.toString().length === 0) {
                                e.preventDefault();
                                if (window.__dashRef) {
                                    window.__dashRef.invokeMethodAsync('JsInterruptSession');
                                }
                            }
                        }
                    });
                }
            ");
            try
            {
                var dotNetRef = DotNetObjectReference.Create(this);
                if (_disposed) { dotNetRef.Dispose(); return; }
                await JS.InvokeVoidAsync("eval", "window.__dashRef = null;");
                _dotNetRef = dotNetRef;
                await JS.InvokeVoidAsync("eval", "window.__setDashRef = function(ref) { window.__dashRef = ref; };");
                if (_disposed) return;
                await JS.InvokeVoidAsync("__setDashRef", _dotNetRef);
                await JS.InvokeVoidAsync("eval", @"
                if (!window.__textareaAutoResize) {
                    window.__textareaAutoResize = true;
                    document.addEventListener('input', function(e) {
                        if (e.target.tagName === 'TEXTAREA' && e.target.closest('.input-row')) {
                            e.target.style.height = 'auto';
                            e.target.style.height = Math.min(e.target.scrollHeight, 150) + 'px';
                        }
                    });
                }
            ");
            }
            catch (ObjectDisposedException) { }
        }

        // Auto-scroll all card message containers to bottom
        // Restore draft text, focus, and cursor position ‚Äî all in ONE JS call
        var draftsJson = "{}";
        if (draftBySession.Count > 0)
        {
            var draftMap = new Dictionary<string, string>();
            foreach (var (name, draft) in draftBySession)
            {
                if (!string.IsNullOrEmpty(draft))
                    draftMap[$"input-{name.Replace(" ", "-")}"] = draft;
            }
            draftsJson = System.Text.Json.JsonSerializer.Serialize(draftMap);
        }
        var focusId = _focusedInputId ?? "";
        var selStart = _cursorStart;
        var selEnd = _cursorEnd;
        _focusedInputId = null;

        var forceScroll = _needsScrollToBottom;
        _needsScrollToBottom = false;

        await JS.InvokeVoidAsync("restoreDraftsAndFocus", draftsJson, focusId, selStart, selEnd, forceScroll);

        // Auto-load more messages when scrolled to top (IntersectionObserver on load-more buttons)
        await JS.InvokeVoidAsync("eval", @"
            if (!window.__loadMoreObserver) {
                window.__loadMoreObserver = new IntersectionObserver(function(entries) {
                    entries.forEach(function(entry) {
                        if (entry.isIntersecting) entry.target.click();
                    });
                }, { threshold: 0.1 });
            }
            document.querySelectorAll('.load-more-btn').forEach(function(btn) {
                if (!btn.__observed) { btn.__observed = true; window.__loadMoreObserver.observe(btn); }
            });
        ");
    }

    private DateTime _lastRefresh = DateTime.MinValue;
    private bool _refreshPending;

    private async Task SafeRefreshAsync()
    {
        // Throttle to max ~4 refreshes per second to avoid blocking UI interactions
        var now = DateTime.UtcNow;
        if ((now - _lastRefresh).TotalMilliseconds < 250)
        {
            if (!_refreshPending)
            {
                _refreshPending = true;
                _ = Task.Delay(250).ContinueWith(_ => InvokeAsync(SafeRefreshAsync));
            }
            return;
        }
        _lastRefresh = now;
        _refreshPending = false;

        // Capture all card input values before re-render wipes them
        try
        {
            var json = await JS.InvokeAsync<string>("eval", @"
                (function() {
                    var result = {};
                    var active = document.activeElement;
                    document.querySelectorAll('.card-input input, .card-input textarea, .expanded-card .input-area textarea').forEach(function(el) {
                        if (el.id && el.value) result[el.id] = el.value;
                    });
                    if (active && active.id) result['__focused'] = active.id;
                    if (active) { result['__selStart'] = active.selectionStart || 0; result['__selEnd'] = active.selectionEnd || 0; }
                    return JSON.stringify(result);
                })();
            ");
            if (!string.IsNullOrEmpty(json))
            {
                var saved = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, string>>(json);
                if (saved != null)
                {
                    foreach (var (id, val) in saved)
                    {
                        if (id.StartsWith("__")) continue;
                        // Map input id back to session name
                        var sessionName = id.Replace("input-", "").Replace("-", " ");
                        if (!string.IsNullOrEmpty(val))
                            draftBySession[sessionName] = val;
                    }
                    if (saved.TryGetValue("__focused", out var fid))
                        _focusedInputId = fid;
                    if (saved.TryGetValue("__selStart", out var ss) && int.TryParse(ss, out var start))
                        _cursorStart = start;
                    if (saved.TryGetValue("__selEnd", out var se) && int.TryParse(se, out var end))
                        _cursorEnd = end;
                }
            }
        }
        catch { }
        StateHasChanged();
    }

    private bool _explicitlyCollapsed;
    private bool _initialGridSet;
    private bool _refreshing;

    private void RefreshState()
    {
        if (_refreshing) return;
        if (!_initializationComplete) return; // Don't process state changes until initialization is done
        _refreshing = true;
        try
        {
            sessions = CopilotService.GetAllSessions().ToList();

            // On first load with multiple sessions, default to grid view
            // unless a session was explicitly selected (e.g. from Settings page)
            if (!_initialGridSet && sessions.Count > 1)
            {
                _initialGridSet = true;
                var selected = CopilotService.ActiveSessionName;
                if (selected != null && sessions.Any(s => s.Name == selected))
                {
                    expandedSession = selected;
                    _lastActiveSession = selected;
                    _focusedInputId = $"input-{selected.Replace(" ", "-")}";
                }
                else
                {
                    expandedSession = null;
                    _lastActiveSession = selected;
                    if (selected != null)
                        CopilotService.SetActiveSession(null);
                }
                InvokeAsync(SafeRefreshAsync);
                return;
            }

            // Auto-expand when only one session (unless user explicitly collapsed)
            if (sessions.Count == 1 && expandedSession == null && !_explicitlyCollapsed)
            {
                expandedSession = sessions[0].Name;
                CopilotService.SwitchSession(sessions[0].Name);
            }
            // Detect sidebar-initiated session switch ‚Äî expand to chat view
            // Skip during initial load (_lastActiveSession will be set below)
            var active = CopilotService.ActiveSessionName;
            if (active != null && active != _lastActiveSession && sessions.Any(s => s.Name == active) && _lastActiveSession != null)
            {
                _lastActiveSession = active;
                expandedSession = active;
                _focusedInputId = $"input-{active.Replace(" ", "-")}";
                _needsScrollToBottom = true;
                CopilotService.SaveUiState("/dashboard", activeSession: active, expandedSession: active, expandedGrid: !isCompactGrid);
            }
            
            // Set _lastActiveSession during initial load to prevent auto-expand above
            if (_lastActiveSession == null && active != null)
            {
                _lastActiveSession = active;
            }
            // Clear sidebar highlight when showing grid view
            // Clear stale streaming content for sessions that finished
            foreach (var s in sessions)
            {
                if (!s.IsProcessing && streamingBySession.ContainsKey(s.Name))
                    streamingBySession.Remove(s.Name);
            }
            InvokeAsync(SafeRefreshAsync);
        }
        finally { _refreshing = false; }
    }

    private void HandleComplete(string sessionName, string summary)
    {
        completedSessions.Add(sessionName);
        streamingBySession.Remove(sessionName);
        activityBySession.Remove(sessionName);
        InvokeAsync(SafeRefreshAsync);
        _ = Task.Delay(10000).ContinueWith(_ =>
        {
            completedSessions.Remove(sessionName);
            InvokeAsync(SafeRefreshAsync);
        });
    }

    private void HandleContent(string sessionName, string content)
    {
        if (!streamingBySession.ContainsKey(sessionName))
            streamingBySession[sessionName] = "";
        streamingBySession[sessionName] += content;
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleActivity(string sessionName, string activity)
    {
        activityBySession[sessionName] = activity;
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleToolStarted(string sessionName, string toolName, string callId, string? inputSummary)
    {
        currentToolBySession[sessionName] = toolName;
        if (!toolActivitiesBySession.ContainsKey(sessionName))
            toolActivitiesBySession[sessionName] = new();
        // Deduplicate: update existing activity if replayed
        var existing = toolActivitiesBySession[sessionName].FirstOrDefault(a => a.CallId == callId);
        if (existing != null)
        {
            if (!string.IsNullOrEmpty(inputSummary)) existing.Input = inputSummary;
            return;
        }
        toolActivitiesBySession[sessionName].Add(new ToolActivity
        {
            Name = toolName,
            CallId = callId,
            Input = inputSummary,
            StartedAt = DateTime.Now
        });
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleToolCompleted(string sessionName, string callId, string result, bool success)
    {
        if (toolActivitiesBySession.TryGetValue(sessionName, out var activities))
        {
            var activity = activities.LastOrDefault(a => a.CallId == callId);
            if (activity != null)
            {
                activity.IsComplete = true;
                activity.IsSuccess = success;
                activity.Result = result;
                activity.CompletedAt = DateTime.Now;
            }
        }
        currentToolBySession.Remove(sessionName);
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleIntentChanged(string sessionName, string intent)
    {
        intentBySession[sessionName] = intent;
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (usageBySession.TryGetValue(sessionName, out var current))
        {
            usageBySession[sessionName] = new SessionUsageInfo(
                info.Model ?? current.Model,
                info.CurrentTokens ?? current.CurrentTokens,
                info.TokenLimit ?? current.TokenLimit,
                info.InputTokens ?? current.InputTokens,
                info.OutputTokens ?? current.OutputTokens,
                info.PremiumQuota ?? current.PremiumQuota);
        }
        else
        {
            usageBySession[sessionName] = info;
        }
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleError(string sessionName, string error)
    {
        if (error.Contains("cancell", StringComparison.OrdinalIgnoreCase)) return;
        errorBySession[sessionName] = error;
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleTurnStart(string sessionName)
    {
        currentToolBySession.Remove(sessionName);
        toolActivitiesBySession[sessionName] = new();
        InvokeAsync(SafeRefreshAsync);
    }

    private void HandleTurnEnd(string sessionName)
    {
        intentBySession.Remove(sessionName);
        currentToolBySession.Remove(sessionName);
        InvokeAsync(SafeRefreshAsync);
    }

    private void DismissError(string sessionName)
    {
        errorBySession.Remove(sessionName);
    }

    private async Task SendFromCard(string sessionName, string? explicitText = null)
    {
        var inputId = $"input-{sessionName.Replace(" ", "-")}";
        var prompt = explicitText ?? await JS.InvokeAsync<string>("getElementValue", inputId);
        var hasImages = pendingImagesBySession.TryGetValue(sessionName, out var pendingSendImages) && pendingSendImages.Count > 0;
        if (string.IsNullOrWhiteSpace(prompt) && !hasImages) return;

        if (explicitText == null) // Only clear if we read from DOM, otherwise child component cleared it
            await JS.InvokeVoidAsync("clearElementValue", inputId);
        draftBySession.Remove(sessionName);

        var finalPrompt = (prompt ?? "").Trim();

        // Record in command history
        if (!string.IsNullOrWhiteSpace(finalPrompt))
        {
            if (!commandHistoryBySession.ContainsKey(sessionName))
                commandHistoryBySession[sessionName] = new();
            var history = commandHistoryBySession[sessionName];
            // Avoid consecutive duplicates
            if (history.Count == 0 || history[^1] != finalPrompt)
            {
                history.Add(finalPrompt);
                if (history.Count > 50) history.RemoveAt(0);
            }
            historyIndexBySession[sessionName] = history.Count; // past the end = "no selection"
        }

        // Handle ! shell commands
        if (finalPrompt.StartsWith("!") && finalPrompt.Length > 1)
        {
            var shellCmd = finalPrompt.Substring(1).TrimStart();
            await ExecuteShellCommand(sessionName, shellCmd);
            return;
        }

        // Handle / slash commands
        if (finalPrompt.StartsWith("/"))
        {
            await HandleSlashCommand(sessionName, finalPrompt);
            return;
        }

        if (planModeBySession.GetValueOrDefault(sessionName))
            finalPrompt = $"[[PLAN]] {finalPrompt}";

        List<string>? imagePaths = null;
        if (hasImages)
        {
            imagePaths = pendingSendImages!.Select(i => i.TempPath).ToList();
            pendingImagesBySession.Remove(sessionName);
        }

        var session = sessions.FirstOrDefault(s => s.Name == sessionName);
        if (session?.IsProcessing == true)
        {
            CopilotService.EnqueueMessage(sessionName, finalPrompt);
            return;
        }

        _needsScrollToBottom = true;
        streamingBySession.Remove(sessionName);
        activityBySession.Remove(sessionName);

        // Force scroll to bottom immediately after sending
        await JS.InvokeVoidAsync("eval", @"
            document.querySelectorAll('.card-messages, .messages').forEach(function(el) {
                el.scrollTop = el.scrollHeight;
            });
            setTimeout(function() {
                document.querySelectorAll('.card-messages, .messages').forEach(function(el) {
                    el.scrollTop = el.scrollHeight;
                });
            }, 100);
        ");

        try
        {
            _ = CopilotService.SendPromptAsync(sessionName, finalPrompt, imagePaths).ContinueWith(t =>
            {
                if (t.IsFaulted)
                {
                    InvokeAsync(() =>
                    {
                        Console.WriteLine($"Error sending to {sessionName}: {t.Exception?.InnerException?.Message}");
                    });
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending to {sessionName}: {ex.Message}");
        }
    }

    private string GetShellCwd(string sessionName)
    {
        if (!shellCwdBySession.TryGetValue(sessionName, out var cwd))
        {
            // Default to the session's working directory if available
            var session = CopilotService.GetAllSessions().FirstOrDefault(s => s.Name == sessionName);
            cwd = session?.WorkingDirectory ?? Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        }
        return cwd;
    }

    private async Task ExecuteShellCommand(string sessionName, string command)
    {
        var session = CopilotService.GetAllSessions().FirstOrDefault(s => s.Name == sessionName);
        if (session == null) return;

        session.History.Add(ChatMessage.UserMessage($"!{command}"));
        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);

        // Handle cd as a built-in: resolve the path and update the tracked cwd
        var trimmed = command.Trim();
        if (trimmed == "cd" || trimmed.StartsWith("cd "))
        {
            var arg = trimmed == "cd" ? "~" : trimmed.Substring(3).Trim();
            if (string.IsNullOrEmpty(arg) || arg == "~")
                arg = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            else if (arg.StartsWith("~/"))
                arg = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), arg.Substring(2));

            var cwd = GetShellCwd(sessionName);
            var resolved = Path.GetFullPath(Path.Combine(cwd, arg));

            if (Directory.Exists(resolved))
            {
                shellCwdBySession[sessionName] = resolved;
                session.History.Add(ChatMessage.SystemMessage(resolved));
            }
            else
            {
                session.History.Add(ChatMessage.ErrorMessage($"cd: no such directory: {resolved}"));
            }

            session.MessageCount = session.History.Count;
            _needsScrollToBottom = true;
            await InvokeAsync(SafeRefreshAsync);
            return;
        }

        try
        {
            var cwd = GetShellCwd(sessionName);
            using var process = new System.Diagnostics.Process();
            process.StartInfo = new System.Diagnostics.ProcessStartInfo
            {
                FileName = "/bin/bash",
                Arguments = $"-c \"{command.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = cwd
            };
            process.Start();
            var stdout = await process.StandardOutput.ReadToEndAsync();
            var stderr = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();

            var output = stdout;
            if (!string.IsNullOrEmpty(stderr))
                output = string.IsNullOrEmpty(output) ? stderr : $"{output}\n{stderr}";
            if (string.IsNullOrEmpty(output))
                output = $"(exit code {process.ExitCode})";

            session.History.Add(ChatMessage.ShellOutputMessage(output.TrimEnd(), process.ExitCode));
        }
        catch (Exception ex)
        {
            session.History.Add(ChatMessage.ErrorMessage($"Shell error: {ex.Message}"));
        }

        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private async Task HandleSlashCommand(string sessionName, string input)
    {
        var session = sessions.FirstOrDefault(s => s.Name == sessionName);
        if (session == null) return;

        var parts = input.TrimStart('/').Split(' ', 2, StringSplitOptions.TrimEntries);
        var cmd = parts[0].ToLowerInvariant();
        var arg = parts.Length > 1 ? parts[1] : "";

        session.History.Add(ChatMessage.UserMessage(input));
        session.MessageCount = session.History.Count;

        switch (cmd)
        {
            case "help":
                session.History.Add(ChatMessage.SystemMessage(
                    "**Available commands:**\n" +
                    "- `/help` ‚Äî Show this help\n" +
                    "- `/clear` ‚Äî Clear chat history\n" +
                    "- `/compact` ‚Äî Summarize conversation and start fresh\n" +
                    "- `/new [name]` ‚Äî Create a new session\n" +
                    "- `/sessions` ‚Äî List all sessions\n" +
                    "- `/rename <name>` ‚Äî Rename current session\n" +
                    "- `/version` ‚Äî Show version info\n" +
                    "- `/diff [args]` ‚Äî Show git diff\n" +
                    "- `/status` ‚Äî Show git status\n" +
                    "- `/mcp` ‚Äî List MCP servers (enable/disable with `/mcp enable|disable <name>`)\n" +
                    "- `/plugin` ‚Äî List installed plugins (enable/disable with `/plugin enable|disable <name>`)\n" +
                    "- `!<command>` ‚Äî Run a shell command"));
                break;

            case "clear":
                CopilotService.ClearHistory(sessionName);
                session.History.Add(ChatMessage.SystemMessage("Chat history cleared."));
                break;

            case "version":
                var appVersion = AppInfo.Current.VersionString;
                var buildVersion = AppInfo.Current.BuildString;
                var sdkVersion = typeof(GitHub.Copilot.SDK.CopilotClient).Assembly.GetName().Version?.ToString() ?? "unknown";
                var runtime = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription;
                var gitCommit = "";
                try
                {
                    var gitDir = Path.GetDirectoryName(AppContext.BaseDirectory);
                    for (int i = 0; i < 20 && gitDir != null; i++)
                    {
                        gitDir = Path.GetDirectoryName(gitDir);
                        if (gitDir != null && Directory.Exists(Path.Combine(gitDir, ".git")))
                        {
                            var headFile = Path.Combine(gitDir, ".git", "HEAD");
                            if (File.Exists(headFile))
                            {
                                var head = File.ReadAllText(headFile).Trim();
                                if (head.StartsWith("ref: "))
                                {
                                    var refPath = Path.Combine(gitDir, ".git", head[5..]);
                                    if (File.Exists(refPath))
                                        gitCommit = File.ReadAllText(refPath).Trim()[..7];
                                }
                                else if (head.Length >= 7)
                                    gitCommit = head[..7];
                            }
                            break;
                        }
                    }
                }
                catch { }
                var versionText = $"**PolyPilot** v{appVersion} (build {buildVersion})\n" +
                    $"**SDK:** GitHub.Copilot.SDK {sdkVersion}\n" +
                    $"**Runtime:** {runtime}" +
                    (string.IsNullOrEmpty(gitCommit) ? "" : $"\n**Git:** {gitCommit}");
                session.History.Add(ChatMessage.SystemMessage(versionText));
                break;

            case "compact":
                session.History.Add(ChatMessage.SystemMessage("Compacting conversation..."));
                session.MessageCount = session.History.Count;
                _needsScrollToBottom = true;
                await InvokeAsync(SafeRefreshAsync);
                _ = CopilotService.SendPromptAsync(sessionName,
                    "Summarize our conversation so far into a concise context block, then we'll continue from there. Keep key decisions, file paths, and code snippets. Drop routine chatter.");
                return;

            case "new":
                var newName = string.IsNullOrWhiteSpace(arg)
                    ? $"Session {CopilotService.SessionCount + 1}"
                    : arg;
                await CopilotService.CreateSessionAsync(newName);
                sessions = CopilotService.GetAllSessions().ToList();
                var created = sessions.LastOrDefault();
                if (created != null)
                {
                    CopilotService.SetActiveSession(created.Name);
                    expandedSession = created.Name;
                    _explicitlyCollapsed = false;
                }
                await InvokeAsync(SafeRefreshAsync);
                return;

            case "sessions":
                var allSessions = CopilotService.GetAllSessions().ToList();
                var listing = string.Join("\n", allSessions.Select((s, i) =>
                    $"- {(s.Name == sessionName ? "**" : "")}{s.Name}{(s.Name == sessionName ? "** (current)" : "")}" +
                    $" ‚Äî {s.MessageCount} messages" +
                    $"{(s.IsProcessing ? " ‚è≥" : "")}"));
                session.History.Add(ChatMessage.SystemMessage(
                    $"**{allSessions.Count} session{(allSessions.Count != 1 ? "s" : "")}:**\n{listing}"));
                break;

            case "rename":
                if (string.IsNullOrWhiteSpace(arg))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: /rename <new name>"));
                }
                else
                {
                    var success = CopilotService.RenameSession(sessionName, arg);
                    if (success)
                    {
                        if (expandedSession == sessionName)
                            expandedSession = arg;
                        sessions = CopilotService.GetAllSessions().ToList();
                        session = sessions.FirstOrDefault(s => s.Name == arg);
                        session?.History.Add(ChatMessage.SystemMessage($"Session renamed to **{arg}**."));
                    }
                    else
                    {
                        session.History.Add(ChatMessage.ErrorMessage($"Failed to rename ‚Äî \"{arg}\" may already exist."));
                    }
                }
                break;

            case "diff":
            case "status":
                var gitCmd = string.IsNullOrWhiteSpace(arg) ? cmd : $"{cmd} {arg}";
                await RunGitCommand(sessionName, session, gitCmd);
                return;

            case "mcp":
                HandleMcpCommand(session, arg);
                break;

            case "plugin":
            case "plugins":
                HandlePluginCommand(session, arg);
                break;

            default:
                // Unknown command ‚Äî pass through to the SDK as a regular prompt
                _ = CopilotService.SendPromptAsync(sessionName, input);
                return;
        }

        if (session != null)
            session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private async Task RunGitCommand(string sessionName, AgentSessionInfo session, string gitArgs)
    {
        var cwd = GetShellCwd(sessionName);
        var isDiff = gitArgs.StartsWith("diff");
        session.History.Add(ChatMessage.UserMessage($"/{gitArgs}"));
        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);

        try
        {
            using var process = new System.Diagnostics.Process();
            process.StartInfo = new System.Diagnostics.ProcessStartInfo
            {
                FileName = "git",
                Arguments = $"--no-pager {gitArgs}",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                WorkingDirectory = cwd
            };
            process.Start();

            var stdout = await process.StandardOutput.ReadToEndAsync();
            var stderr = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();

            var output = !string.IsNullOrEmpty(stdout) ? stdout : stderr;
            if (string.IsNullOrWhiteSpace(output))
            {
                session.History.Add(ChatMessage.SystemMessage("(no changes)"));
            }
            else if (isDiff)
            {
                session.History.Add(ChatMessage.DiffMessage(output));
            }
            else
            {
                var wrapped = $"```\n{output.TrimEnd()}\n```";
                session.History.Add(ChatMessage.SystemMessage(wrapped));
            }
        }
        catch (Exception ex)
        {
            session.History.Add(ChatMessage.ErrorMessage($"git error: {ex.Message}"));
        }

        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private void HandleMcpCommand(AgentSessionInfo session, string arg)
    {
        var parts = arg.Split(' ', 2, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        var subcommand = parts.Length > 0 ? parts[0].ToLowerInvariant() : "";
        var target = parts.Length > 1 ? parts[1] : "";

        switch (subcommand)
        {
            case "enable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/mcp enable <server-name>`"));
                    return;
                }
                ToggleMcpServer(target, enabled: true);
                session.History.Add(ChatMessage.SystemMessage($"‚úÖ MCP server **{target}** enabled. Create a new session to pick up the change."));
                break;

            case "disable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/mcp disable <server-name>`"));
                    return;
                }
                ToggleMcpServer(target, enabled: false);
                session.History.Add(ChatMessage.SystemMessage($"üö´ MCP server **{target}** disabled. Create a new session to pick up the change."));
                break;

            default:
                session.History.Add(ChatMessage.SystemMessage(GetMcpServerInfo()));
                break;
        }
    }

    private void HandlePluginCommand(AgentSessionInfo session, string arg)
    {
        var parts = arg.Split(' ', 2, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        var subcommand = parts.Length > 0 ? parts[0].ToLowerInvariant() : "";
        var target = parts.Length > 1 ? parts[1] : "";

        switch (subcommand)
        {
            case "enable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/plugin enable <plugin-name>`"));
                    return;
                }
                TogglePlugin(target, enabled: true);
                session.History.Add(ChatMessage.SystemMessage($"‚úÖ Plugin **{target}** enabled. Create a new session to pick up the change."));
                break;

            case "disable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/plugin disable <plugin-name>`"));
                    return;
                }
                TogglePlugin(target, enabled: false);
                session.History.Add(ChatMessage.SystemMessage($"üö´ Plugin **{target}** disabled. Create a new session to pick up the change."));
                break;

            default:
                session.History.Add(ChatMessage.SystemMessage(GetPluginInfo()));
                break;
        }
    }

    private void ToggleMcpServer(string name, bool enabled)
    {
        var settings = ConnectionSettings.Load();
        if (enabled)
            settings.DisabledMcpServers.Remove(name);
        else if (!settings.DisabledMcpServers.Contains(name))
            settings.DisabledMcpServers.Add(name);
        settings.Save();
    }

    private void TogglePlugin(string name, bool enabled)
    {
        var settings = ConnectionSettings.Load();
        if (enabled)
            settings.DisabledPlugins.Remove(name);
        else if (!settings.DisabledPlugins.Contains(name))
            settings.DisabledPlugins.Add(name);
        settings.Save();
    }

    private string GetMcpServerInfo()
    {
        var sb = new System.Text.StringBuilder();
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var copilotDir = Path.Combine(home, ".copilot");
        var servers = new List<(string name, string command, string[] args)>();

        // Read ~/.copilot/mcp-servers.json (simple format)
        try
        {
            var path = Path.Combine(copilotDir, "mcp-servers.json");
            if (File.Exists(path))
            {
                var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(path));
                foreach (var prop in doc.RootElement.EnumerateObject())
                {
                    var command = prop.Value.TryGetProperty("command", out var c) ? c.GetString() ?? "" : "";
                    var args = prop.Value.TryGetProperty("args", out var a)
                        ? a.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                        : Array.Empty<string>();
                    servers.Add((prop.Name, command, args));
                }
            }
        }
        catch { }

        // Read ~/.copilot/mcp-config.json (wrapped format)
        try
        {
            var path = Path.Combine(copilotDir, "mcp-config.json");
            if (File.Exists(path))
            {
                var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(path));
                if (doc.RootElement.TryGetProperty("mcpServers", out var mcpServers))
                {
                    foreach (var prop in mcpServers.EnumerateObject())
                    {
                        if (servers.Any(s => s.name == prop.Name)) continue;
                        var command = prop.Value.TryGetProperty("command", out var c) ? c.GetString() ?? "" : "";
                        var args = prop.Value.TryGetProperty("args", out var a)
                            ? a.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                            : Array.Empty<string>();
                        servers.Add((prop.Name, command, args));
                    }
                }
            }
        }
        catch { }

        // Read plugin .mcp.json files
        try
        {
            var pluginsDir = Path.Combine(copilotDir, "installed-plugins");
            if (Directory.Exists(pluginsDir))
            {
                foreach (var marketDir in Directory.GetDirectories(pluginsDir))
                {
                    foreach (var pluginDir in Directory.GetDirectories(marketDir))
                    {
                        var mcpFile = Path.Combine(pluginDir, ".mcp.json");
                        if (!File.Exists(mcpFile)) continue;
                        try
                        {
                            var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(mcpFile));
                            if (doc.RootElement.TryGetProperty("mcpServers", out var mcpServers))
                            {
                                foreach (var prop in mcpServers.EnumerateObject())
                                {
                                    if (servers.Any(s => s.name == prop.Name)) continue;
                                    var command = prop.Value.TryGetProperty("command", out var c) ? c.GetString() ?? "" : "";
                                    var args = prop.Value.TryGetProperty("args", out var a)
                                        ? a.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                                        : Array.Empty<string>();
                                    servers.Add((prop.Name, command, args));
                                }
                            }
                        }
                        catch { }
                    }
                }
            }
        }
        catch { }

        if (servers.Count == 0)
            return "**No MCP servers configured.**\n\nAdd servers to `~/.copilot/mcp-servers.json` or `~/.copilot/mcp-config.json`.";

        var settings = ConnectionSettings.Load();
        var disabledCount = servers.Count(s => settings.DisabledMcpServers.Contains(s.name));
        var enabledCount = servers.Count - disabledCount;
        sb.AppendLine($"**{servers.Count} MCP server{(servers.Count != 1 ? "s" : "")}** ({enabledCount} enabled):\n");
        foreach (var (name, command, args) in servers)
        {
            var lastArg = args.LastOrDefault() ?? "";
            var script = Path.GetFileName(lastArg);
            var display = !string.IsNullOrEmpty(script) ? $"`{command} {script}`" : $"`{command}`";
            var isDisabled = settings.DisabledMcpServers.Contains(name);
            var status = isDisabled ? "üö´" : "‚úÖ";
            sb.AppendLine($"- {status} **{name}** ‚Äî {display}");
        }
        sb.AppendLine();
        sb.AppendLine("Use `/mcp enable <name>` or `/mcp disable <name>` to toggle.");

        return sb.ToString().TrimEnd();
    }

    private async Task StopSession(string sessionName)
    {
        await CopilotService.AbortSessionAsync(sessionName);
    }

    private string GetPluginInfo()
    {
        var sb = new System.Text.StringBuilder();
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var pluginsDir = Path.Combine(home, ".copilot", "installed-plugins");

        if (!Directory.Exists(pluginsDir))
            return "**No plugins installed.**\n\nInstall plugins with `copilot plugin install <source>`.";

        var plugins = new List<(string name, string marketplace, string type, string detail)>();

        foreach (var marketDir in Directory.GetDirectories(pluginsDir))
        {
            var marketplace = Path.GetFileName(marketDir);
            foreach (var pluginDir in Directory.GetDirectories(marketDir))
            {
                var pluginName = Path.GetFileName(pluginDir);
                var type = "plugin";
                var detail = "";

                // Check for MCP config
                var mcpFile = Path.Combine(pluginDir, ".mcp.json");
                if (File.Exists(mcpFile))
                {
                    type = "mcp";
                    try
                    {
                        var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(mcpFile));
                        if (doc.RootElement.TryGetProperty("mcpServers", out var servers))
                        {
                            var names = servers.EnumerateObject().Select(p => p.Name).ToList();
                            detail = string.Join(", ", names);
                        }
                    }
                    catch { }
                }

                // Check for skills
                var skillDirs = Directory.GetDirectories(pluginDir, "skills", SearchOption.AllDirectories).FirstOrDefault();
                if (skillDirs != null)
                {
                    var skills = Directory.GetDirectories(skillDirs).Select(Path.GetFileName).ToList();
                    if (skills.Count > 0)
                    {
                        type = type == "mcp" ? "mcp+skills" : "skills";
                        detail = string.IsNullOrEmpty(detail)
                            ? string.Join(", ", skills!)
                            : $"{detail} | skills: {string.Join(", ", skills!)}";
                    }
                }

                plugins.Add((pluginName, marketplace, type, detail));
            }
        }

        if (plugins.Count == 0)
            return "**No plugins installed.**\n\nInstall plugins with `copilot plugin install <source>`.";

        var settings = ConnectionSettings.Load();
        var disabledCount = plugins.Count(p => settings.DisabledPlugins.Contains(p.name));
        var enabledCount = plugins.Count - disabledCount;
        sb.AppendLine($"**{plugins.Count} plugin{(plugins.Count != 1 ? "s" : "")} installed** ({enabledCount} enabled):\n");
        foreach (var (name, marketplace, type, detail) in plugins)
        {
            var badge = type switch { "mcp" => "üîå", "skills" => "üõ†Ô∏è", "mcp+skills" => "üîåüõ†Ô∏è", _ => "üì¶" };
            var isDisabled = settings.DisabledPlugins.Contains(name);
            var status = isDisabled ? "üö´" : "‚úÖ";
            var detailStr = !string.IsNullOrEmpty(detail) ? $" ‚Äî {detail}" : "";
            sb.AppendLine($"- {status} {badge} **{name}** `{marketplace}`{detailStr}");
        }
        sb.AppendLine();
        sb.AppendLine("Use `/plugin enable <name>` or `/plugin disable <name>` to toggle.");

        return sb.ToString().TrimEnd();
    }

    [JSInvokable]
    public async Task JsInterruptSession()
    {
        var target = expandedSession ?? CopilotService.ActiveSessionName;
        if (target == null) return;
        var session = sessions.FirstOrDefault(s => s.Name == target);
        if (session?.IsProcessing == true)
            await StopSession(target);
    }

    private async Task TriggerAttach(string sessionName)
    {
        var fileId = $"file-{sessionName.Replace(" ", "-")}";
        await JS.InvokeVoidAsync("clickElement", fileId);
    }

    private async Task ExpandSession(string sessionName)
    {
        try { File.AppendAllText(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".polypilot/ui-state-debug.log"), $"[{DateTime.Now:HH:mm:ss}] ExpandSession called for {sessionName}\n"); } catch { }
        await SaveDraftsAndCursor();
        expandedSession = sessionName;
        _needsScrollToBottom = true;
        CopilotService.SwitchSession(sessionName);
        CopilotService.SaveUiState("/dashboard", activeSession: sessionName, expandedSession: sessionName, expandedGrid: !isCompactGrid);
    }

    private async Task CollapseExpanded()
    {
        try { File.AppendAllText(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".polypilot/ui-state-debug.log"), $"[{DateTime.Now:HH:mm:ss}] CollapseExpanded called\n"); } catch { }
        await SaveDraftsAndCursor();
        expandedSession = null;
        _needsScrollToBottom = true;
        _lastActiveSession = null;
        _explicitlyCollapsed = true;
        CopilotService.SetActiveSession(null);
        CopilotService.SaveUiState("/dashboard", activeSession: null, expandedSession: null, expandedGrid: !isCompactGrid);
    }

    private void ToggleGridDensity()
    {
        isCompactGrid = !isCompactGrid;
        CopilotService.SaveUiState("/dashboard", expandedGrid: !isCompactGrid, expandedSession: expandedSession);
    }

    private void ToggleCardMenu(string sessionName)
    {
        cardMenuSession = cardMenuSession == sessionName ? null : sessionName;
    }

    private void StartCardRename(string sessionName)
    {
        cardRenamingSession = sessionName;
        _ = FocusCardRenameInput();
    }

    private async Task FocusCardRenameInput()
    {
        await Task.Yield();
        StateHasChanged();
        await Task.Yield();
        await JS.InvokeVoidAsync("eval", @"
            var el = document.getElementById('cardRenameInput');
            if (el) { el.focus(); el.select(); }
        ");
    }

    private async Task CommitCardRename()
    {
        if (cardRenamingSession == null) return;
        var oldName = cardRenamingSession;
        cardRenamingSession = null;

        var newName = await JS.InvokeAsync<string>("getElementValue", "cardRenameInput");
        if (!string.IsNullOrWhiteSpace(newName) && newName.Trim() != oldName)
        {
            CopilotService.RenameSession(oldName, newName.Trim());
        }
    }

    private async Task HandleCardRenameKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CommitCardRename();
        else if (e.Key == "Escape") cardRenamingSession = null;
    }

    private void OnSortModeChanged(ChangeEventArgs e)
    {
        if (e.Value is string val && Enum.TryParse<SessionSortMode>(val, out var mode))
        {
            CopilotService.SetSortMode(mode);
        }
    }

    private async Task CommitDashGroup()
    {
        var name = await JS.InvokeAsync<string>("getElementValue", "dashNewGroupInput");
        isAddingDashGroup = false;
        if (!string.IsNullOrWhiteSpace(name))
        {
            CopilotService.CreateGroup(name.Trim());
        }
    }

    private async Task HandleDashGroupKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CommitDashGroup();
        else if (e.Key == "Escape") isAddingDashGroup = false;
    }

    private async Task SaveDraftsAndCursor()
    {
        var json = await JS.InvokeAsync<string>("eval", @"
            (function() {
                var focused = document.activeElement;
                var sel = '.card-input input, .card-input textarea, .input-row textarea';
                var focusId = (focused && focused.id && focused.matches(sel)) ? focused.id : null;
                var selStart = focusId ? (focused.selectionStart || 0) : 0;
                var selEnd = focusId ? (focused.selectionEnd || 0) : 0;
                var items = Array.from(document.querySelectorAll(sel))
                    .filter(el => el.id)
                    .map(el => ({ id: el.id, value: el.value || '' }));
                return JSON.stringify({ focusId: focusId, selStart: selStart, selEnd: selEnd, items: items });
            })()
        ");
        if (!string.IsNullOrEmpty(json))
        {
            try
            {
                var state = System.Text.Json.JsonSerializer.Deserialize<DraftState>(json);
                if (state != null)
                {
                    _focusedInputId = state.FocusId;
                    _cursorStart = state.SelStart;
                    _cursorEnd = state.SelEnd;
                    draftBySession.Clear();
                    foreach (var item in state.Items ?? [])
                    {
                        var name = item.Id.Replace("input-", "").Replace("-", " ");
                        draftBySession[name] = item.Value;
                    }
                }
            }
            catch { }
        }
    }

    private record DraftItem(
        [property: System.Text.Json.Serialization.JsonPropertyName("id")] string Id,
        [property: System.Text.Json.Serialization.JsonPropertyName("value")] string Value);

    private record DraftState(
        [property: System.Text.Json.Serialization.JsonPropertyName("focusId")] string? FocusId,
        [property: System.Text.Json.Serialization.JsonPropertyName("selStart")] int SelStart,
        [property: System.Text.Json.Serialization.JsonPropertyName("selEnd")] int SelEnd,
        [property: System.Text.Json.Serialization.JsonPropertyName("items")] List<DraftItem>? Items);

    [JSInvokable]
    public async Task JsImagePasted(string base64, string fileName, string extension, string inputId)
    {
        var rawName = inputId.Replace("input-", "");
        var sessionName = sessions.FirstOrDefault(s => s.Name.Replace(" ", "-") == rawName)?.Name;
        if (string.IsNullOrEmpty(sessionName)) return;

        try
        {
            var tempDir = Path.Combine(Path.GetTempPath(), "PolyPilot-images");
            Directory.CreateDirectory(tempDir);
            var tempPath = Path.Combine(tempDir, $"{Guid.NewGuid()}.{extension}");
            var bytes = Convert.FromBase64String(base64);
            await File.WriteAllBytesAsync(tempPath, bytes);

            var mime = extension.ToLowerInvariant() switch
            {
                "png" => "image/png",
                "jpg" or "jpeg" => "image/jpeg",
                "gif" => "image/gif",
                "webp" => "image/webp",
                "svg" => "image/svg+xml",
                "bmp" => "image/bmp",
                _ => "image/png"
            };
            var dataUri = $"data:{mime};base64,{base64}";

            if (!pendingImagesBySession.ContainsKey(sessionName))
                pendingImagesBySession[sessionName] = new();
            pendingImagesBySession[sessionName].Add(new PendingImage(tempPath, fileName, dataUri));

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving pasted image: {ex.Message}");
        }
    }

    private void RemovePendingImage(string sessionName, int index)
    {
        if (pendingImagesBySession.TryGetValue(sessionName, out var images) && index >= 0 && index < images.Count)
        {
            try { File.Delete(images[index].TempPath); } catch { }
            images.RemoveAt(index);
            if (images.Count == 0) pendingImagesBySession.Remove(sessionName);
        }
    }

    private static string TruncateFileName(string name, int maxLen)
    {
        if (name.Length <= maxLen) return name;
        var ext = Path.GetExtension(name);
        var stem = Path.GetFileNameWithoutExtension(name);
        var maxStem = maxLen - ext.Length - 1;
        if (maxStem < 3) return name[..maxLen];
        return stem[..maxStem] + "‚Ä¶" + ext;
    }

    private async Task CloseSession(string sessionName)
    {
        await CopilotService.CloseSessionAsync(sessionName);
        if (expandedSession == sessionName)
        {
            expandedSession = null;
            CopilotService.SaveUiState("/dashboard", activeSession: null, expandedSession: null, expandedGrid: !isCompactGrid);
        }
    }

    private void ClearQueue(string sessionName)
    {
        CopilotService.ClearQueue(sessionName);
    }

    private async Task GoToSession(string sessionName)
    {
        CopilotService.SwitchSession(sessionName);
        await SaveDraftsAndCursor();
        expandedSession = sessionName;
        _needsScrollToBottom = true;
        _focusedInputId = $"input-{sessionName.Replace(" ", "-")}";
        _cursorStart = 0;
        _cursorEnd = 0;
    }

    private static string ShortenPath(string path)
    {
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(home) && path.StartsWith(home))
            return "~" + path[home.Length..];
        var parts = path.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        return parts.Length > 3 ? string.Join("/", parts[^3..]) : path;
    }

    private void OpenSessionFolder(string sessionId)
    {
        var path = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            ".copilot", "session-state", sessionId);
        if (Directory.Exists(path))
        {
#if MACCATALYST
            System.Diagnostics.Process.Start("open", path);
#elif WINDOWS
            System.Diagnostics.Process.Start("explorer.exe", path);
#endif
        }
    }

    [JSInvokable]
    public async Task JsExpandSession(string sessionName)
    {
        await SaveDraftsAndCursor();
        expandedSession = sessionName;
        CopilotService.SwitchSession(sessionName);
        StateHasChanged();
    }

    [JSInvokable]
    public async Task JsCollapseToGrid()
    {
        await SaveDraftsAndCursor();
        expandedSession = null;
        _lastActiveSession = null;
        _explicitlyCollapsed = true;
        CopilotService.SetActiveSession(null);
        CopilotService.SaveUiState("/dashboard", activeSession: null, expandedSession: null, expandedGrid: !isCompactGrid);
        StateHasChanged();
    }

    [JSInvokable]
    public async Task JsCycleExpandedSession(bool reverse)
    {
        if (expandedSession == null || sessions.Count < 2) return;
        await SaveDraftsAndCursor();
        var idx = sessions.FindIndex(s => s.Name == expandedSession);
        if (idx < 0) idx = 0;
        idx = reverse ? (idx - 1 + sessions.Count) % sessions.Count : (idx + 1) % sessions.Count;
        expandedSession = sessions[idx].Name;
        CopilotService.SwitchSession(expandedSession);
        _focusedInputId = $"input-{expandedSession.Replace(" ", "-")}";
        _cursorStart = 0;
        _cursorEnd = 0;
        StateHasChanged();
    }

    [JSInvokable]
    public void JsSelectSession(string sessionName)
    {
        _lastActiveSession = sessionName;
        CopilotService.SwitchSession(sessionName);
    }

    [JSInvokable]
    public async Task JsNavigateHistory(string sessionName, bool up)
    {
        if (!commandHistoryBySession.TryGetValue(sessionName, out var history) || history.Count == 0)
            return;

        if (!historyIndexBySession.ContainsKey(sessionName))
            historyIndexBySession[sessionName] = history.Count;

        var idx = historyIndexBySession[sessionName];
        if (up)
            idx = Math.Max(0, idx - 1);
        else
            idx = Math.Min(history.Count, idx + 1);

        historyIndexBySession[sessionName] = idx;
        var inputId = $"input-{sessionName.Replace(" ", "-")}";
        var text = idx < history.Count ? history[idx] : "";
        await JS.InvokeVoidAsync("eval", $"(function(){{ var el = document.getElementById('{inputId}'); if(el){{ el.value = {System.Text.Json.JsonSerializer.Serialize(text)}; el.setSelectionRange(el.value.length, el.value.length); }} }})()");
    }

    [JSInvokable]
    public async Task JsSwitchToSessionByIndex(int index)
    {
        // Use organized sessions to match sidebar badge ordering
        var organized = CopilotService.GetOrganizedSessions().ToList();
        var sessionIndex = 0;
        foreach (var (group, groupSessions) in organized)
        {
            if (group.IsCollapsed && CopilotService.HasMultipleGroups) continue;
            foreach (var session in groupSessions)
            {
                sessionIndex++;
                if (sessionIndex == index)
                {
                    if (expandedSession != null)
                    {
                        await SaveDraftsAndCursor();
                        expandedSession = session.Name;
                        _focusedInputId = $"input-{session.Name.Replace(" ", "-")}";
                    }
                    CopilotService.SwitchSession(session.Name);
                    StateHasChanged();
                    return;
                }
            }
        }
    }

    private const int DefaultMessageWindow = 25;
    private const int DefaultCardMessageWindow = 10;
    private Dictionary<string, int> cardMessageCounts = new();

    private List<ChatMessage> GetWindowedMessages(string sessionName, IReadOnlyList<ChatMessage> history)
    {
        var limit = expandedMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultMessageWindow;
        try
        {
            if (history.Count <= limit) return history.ToList();
            return history.Skip(history.Count - limit).ToList();
        }
        catch (InvalidOperationException)
        {
            return history.ToArray().TakeLast(limit).ToList();
        }
    }

    private List<ChatMessage> GetCardMessages(string sessionName, IReadOnlyList<ChatMessage> history)
    {
        var limit = cardMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultCardMessageWindow;
        try
        {
            if (history.Count <= limit) return history.ToList();
            return history.Skip(history.Count - limit).ToList();
        }
        catch (InvalidOperationException)
        {
            return history.ToArray().TakeLast(limit).ToList();
        }
    }

    private void LoadMoreCardMessages(string sessionName)
    {
        var current = cardMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultCardMessageWindow;
        cardMessageCounts[sessionName] = current + 15;
    }

    private void LoadMoreExpandedMessages(string sessionName)
    {
        var current = expandedMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultMessageWindow;
        expandedMessageCounts[sessionName] = current + 25;
    }

    // === Model, plan mode, font, token helpers ===

    private static readonly string[] _fallbackModels = new[]
    {
        "claude-opus-4.6", "claude-opus-4.6-fast", "claude-opus-4.5", "claude-sonnet-4.5", "claude-sonnet-4", "claude-haiku-4.5",
        "gpt-5.2", "gpt-5.2-codex", "gpt-5.1", "gpt-5.1-codex", "gpt-5.1-codex-max", "gpt-5.1-codex-mini", "gpt-5", "gpt-5-mini", "gpt-4.1",
        "gemini-3-pro-preview",
    };
    private IReadOnlyList<string> availableModels =>
        CopilotService.AvailableModels.Count > 0 ? CopilotService.AvailableModels : _fallbackModels;

    private string GetSessionModel(AgentSessionInfo session)
    {
        // Priority: 1) Usage info (TRUTH) - what the backend is actually using
        if (usageBySession.TryGetValue(session.Name, out var u) && !string.IsNullOrEmpty(u.Model))
            return u.Model;

        // Priority: 2) Session model property (initial configuration)
        if (!string.IsNullOrEmpty(session.Model) && session.Model != "resumed")
            return session.Model;

        return availableModels[0];
    }

    private string GetExpandedModel(AgentSessionInfo session)
    {
        return GetSessionModel(session);
    }

    private async Task SetExpandedModel(AgentSessionInfo session, string? model)
    {
        if (string.IsNullOrEmpty(model)) return;
        // If the session has no history, recreate it to "switch" the model effectively
        if (session.History.Count == 0)
        {
            await CopilotService.RecreateSessionAsync(session.Name, model);
            sessions = CopilotService.GetAllSessions().ToList();
            await InvokeAsync(SafeRefreshAsync);
            return;
        }

        // SDK doesn't support changing model mid-session; update local state only.
        session.Model = model;
    }

    private void SetPlanMode(string sessionName, bool enabled) => planModeBySession[sessionName] = enabled;

    private void IncreaseFontSize() { if (fontSize < 24) { fontSize += 2; ApplyFontSize(); ShowFontBubble(); } }
    private void DecreaseFontSize() { if (fontSize > 12) { fontSize -= 2; ApplyFontSize(); ShowFontBubble(); } }
    private void ResetFontSize() { fontSize = 20; ApplyFontSize(); ShowFontBubble(); }
    private void HandleFontSizeChange(int delta)
    {
        if (delta == 0) ResetFontSize();
        else if (delta > 0) IncreaseFontSize();
        else DecreaseFontSize();
    }

    [JSInvokable]
    public void JsChangeFontSize(int delta)
    {
        HandleFontSizeChange(delta);
        InvokeAsync(StateHasChanged);
    }

    private bool _showFontBubble;
    private CancellationTokenSource? _fontBubbleCts;

    private void ShowFontBubble()
    {
        _fontBubbleCts?.Cancel();
        _showFontBubble = true;
        _fontBubbleCts = new CancellationTokenSource();
        var cts = _fontBubbleCts;
        _ = Task.Delay(1500, cts.Token).ContinueWith(_ =>
        {
            if (!cts.Token.IsCancellationRequested)
            {
                _showFontBubble = false;
                InvokeAsync(StateHasChanged);
            }
        }, TaskScheduler.Default);
    }
    private void ApplyFontSize()
    {
        _ = JS.InvokeVoidAsync("setAppFontSize", fontSize);
        CopilotService.SaveUiState("/dashboard", fontSize: fontSize);
    }

    private static string FormatTokenCount(int count) =>
        count >= 1000 ? $"{count / 1000}k" : count.ToString();

    private static string Truncate(string s, int max) =>
        s.Length <= max ? s : s[..max] + "‚Ä¶";

    private void RemoveQueuedMessage(string sessionName, int index)
    {
        var session = sessions.FirstOrDefault(s => s.Name == sessionName);
        if (session != null && index >= 0 && index < session.MessageQueue.Count)
            session.MessageQueue.RemoveAt(index);
    }

    private async Task CopyToClipboard(string text)
    {
        try { await JS.InvokeVoidAsync("navigator.clipboard.writeText", text); } catch { }
    }

    private bool _disposed;

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        CopilotService.OnStateChanged -= RefreshState;
        CopilotService.OnSessionComplete -= HandleComplete;
        CopilotService.OnContentReceived -= HandleContent;
        CopilotService.OnActivity -= HandleActivity;
        CopilotService.OnToolStarted -= HandleToolStarted;
        CopilotService.OnToolCompleted -= HandleToolCompleted;
        CopilotService.OnIntentChanged -= HandleIntentChanged;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        CopilotService.OnError -= HandleError;
        CopilotService.OnTurnStart -= HandleTurnStart;
        CopilotService.OnTurnEnd -= HandleTurnEnd;
        foreach (var images in pendingImagesBySession.Values)
            foreach (var img in images)
                try { File.Delete(img.TempPath); } catch { }
        try { await JS.InvokeVoidAsync("eval", "window.__dashRef = null;"); } catch { }
        _dotNetRef?.Dispose();
    }
}
