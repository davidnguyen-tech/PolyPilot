@page "/"
@page "/dashboard"
@using PolyPilot.Services
@using PolyPilot.Models
@inject CopilotService CopilotService
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject DevTunnelService DevTunnelService
@inject WsBridgeServer WsBridgeServer
@inject GitAutoUpdateService GitAutoUpdate
@inject QrScannerService QrScanner
@inject FiestaService FiestaService
@implements IAsyncDisposable

<div class="dashboard @(expandedSession != null ? "expanded-mode" : "")">
    @if (!sessions.Any())
    {
        <div class="no-sessions-dash">
            <img src="PolyPilot_logo_lg.png" alt="PolyPilot" class="empty-logo" />
            <p class="welcome-title">Welcome to PolyPilot</p>
            @if (CopilotService.IsRestoring)
            {
                <div class="restoring-indicator">
                    <div class="restoring-spinner"></div>
                    <span>Restoring sessions‚Ä¶</span>
                </div>
            }
            @if (!string.IsNullOrEmpty(initError) && !PlatformHelper.IsMobile)
            {
                <div class="init-error-card">
                    <span class="init-error-icon">‚ö†Ô∏è</span>
                    <p class="init-error-text">@initError</p>
                    <button class="retry-btn" @onclick="Initialize">Retry</button>
                </div>
            }
            @if (!string.IsNullOrEmpty(CopilotService.FallbackNotice))
            {
                <div class="init-error-card fallback-notice">
                    <span class="init-error-icon">‚ö†Ô∏è</span>
                    <p class="init-error-text">@CopilotService.FallbackNotice</p>
                    <button class="retry-btn" @onclick="GoToSettings">Settings</button>
                    <button class="dismiss-btn" @onclick="DismissFallbackNotice">Dismiss</button>
                </div>
            }
            @if (PlatformHelper.IsMobile && !CopilotService.IsInitialized)
            {
                <div class="mobile-connect-card">
                    <button class="scan-qr-btn" @onclick="DashboardScanQr">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                        Scan QR Code
                    </button>
                    <div class="mobile-connect-divider"><span>or enter manually</span></div>
                    <input type="text" class="mobile-connect-input" placeholder="Server URL" @bind="mobileRemoteUrl" />
                    <input type="password" class="mobile-connect-input" placeholder="Token" @bind="mobileRemoteToken" />
                    <button class="mobile-connect-go" @onclick="DashboardConnect" disabled="@mobileConnecting">
                        @(mobileConnecting ? "Connecting‚Ä¶" : "Connect")
                    </button>
                    @if (!string.IsNullOrEmpty(mobileConnectError))
                    {
                        <p class="mobile-connect-error">@mobileConnectError</p>
                    }
                </div>
            }
        </div>
    }
    else if (expandedSession != null)
    {
        var expandedMeta = CopilotService.Organization.Sessions.FirstOrDefault(m => m.SessionName == expandedSession);
        var expandedGroup = expandedMeta != null ? CopilotService.Organization.Groups.FirstOrDefault(g => g.Id == expandedMeta.GroupId && g.IsMultiAgent) : null;
        @if (expandedGroup != null)
        {
            var grpProgress = CopilotService.GetMultiAgentProgress(expandedGroup.Id);
            var expandedGroupId = expandedGroup.Id;
            <div class="ma-expanded-toolbar" @onclick:stopPropagation="true">
                <span class="ma-expanded-toolbar-label">ü§ñ @expandedGroup.Name</span>
                <select class="ma-mode-select" @onchange="(e) => OnMultiAgentModeChanged(expandedGroupId, e)">
                    <option value="Broadcast" selected="@(expandedGroup.OrchestratorMode == MultiAgentMode.Broadcast)">üì° Broadcast</option>
                    <option value="Sequential" selected="@(expandedGroup.OrchestratorMode == MultiAgentMode.Sequential)">‚è© Sequential</option>
                    <option value="Orchestrator" selected="@(expandedGroup.OrchestratorMode == MultiAgentMode.Orchestrator)">üéØ Orchestrate</option>
                    <option value="OrchestratorReflect" selected="@(expandedGroup.OrchestratorMode == MultiAgentMode.OrchestratorReflect)">üîÑ Reflect</option>
                </select>
                @if (expandedGroup.OrchestratorMode == MultiAgentMode.OrchestratorReflect)
                {
                    <span class="reflect-iter-inline">
                        <label>Iterations:</label>
                        <input type="number" min="1" max="100" value="@GetMaxIterations(expandedGroupId)"
                               @onchange="(e) => SetMaxIterations(expandedGroupId, e)"
                               @onclick:stopPropagation="true" class="reflect-iter-input" />
                    </span>
                }
                @if (grpProgress.Processing > 0)
                {
                    <span class="ma-expanded-toolbar-progress">@grpProgress.Completed/@grpProgress.Total done</span>
                }
                @if (_groupPhases.TryGetValue(expandedGroupId, out var expPhase))
                {
                    <span class="phase-indicator">@PhaseLabel(expPhase.Phase, expPhase.Detail)</span>
                }
                <input type="text" id="ma-input-expanded-@expandedGroupId" class="ma-expanded-toolbar-input"
                       placeholder="@GetInputPlaceholder(expandedGroup.OrchestratorMode)"
                       @onkeydown="@(async (KeyboardEventArgs e) => { if (e.Key == "Enter") await SendToExpandedMultiAgentGroup(expandedGroupId); })"
                       @onclick:stopPropagation="true" />
                <button class="ma-send-btn" @onclick="() => SendToExpandedMultiAgentGroup(expandedGroupId)" @onclick:stopPropagation="true">
                    üì° Send All
                </button>
            </div>
        }
        @* Keep-alive: render all active sessions, JS owns 'active' class for instant switching *@
        @foreach (var session in sessions)
        {
            <KeepAliveSession Id="@($"slot-{session.Name.Replace(" ", "-")}")"
                              IsVisible="@(session.Name == expandedSession)"
                              WarmWhenHidden="@(session.IsProcessing && (streamingBySession.ContainsKey(session.Name) || currentToolBySession.ContainsKey(session.Name) || activityBySession.ContainsKey(session.Name)))"
                              HiddenWarmIntervalMs="250"
                              @key="session.Name">
                <ExpandedSessionView Session="session"
                                     IsCompleted="@completedSessions.Contains(session.Name)"
                                     StreamingContent="@(streamingBySession.TryGetValue(session.Name, out var s2) ? s2 : "")"
                                     ActivityText="@(activityBySession.TryGetValue(session.Name, out var a2) ? a2 : "")"
                                     CurrentToolName="@(currentToolBySession.TryGetValue(session.Name, out var t2) ? t2 : "")"
                                     ToolActivities="@(toolActivitiesBySession.TryGetValue(session.Name, out var ta2) ? ta2 : new())"
                                     Intent="@(intentBySession.TryGetValue(session.Name, out var i2) ? i2 : "")"
                                     Error="@(errorBySession.TryGetValue(session.Name, out var e2) ? e2 : null)"
                                     UsageInfo="@(usageBySession.TryGetValue(session.Name, out var u2) ? u2 : null)"
                                     InputMode="@GetInputMode(session.Name)"
                                     CurrentModel="@GetExpandedModel(session)"
                                     AvailableModels="availableModels"
                                     PendingImages="@(pendingImagesBySession.TryGetValue(session.Name, out var pi2) ? pi2 : null)"
                                     UserAvatarUrl="@CopilotService.GitHubAvatarUrl"
                                     Layout="@CopilotService.ChatLayout"
                                     Style="@CopilotService.ChatStyle"
                                     FontSize="fontSize"
                                     MessageWindowSize="@(expandedMessageCounts.TryGetValue(session.Name, out var emc) ? emc : 25)"
                                     FiestaActive="@FiestaService.IsFiestaActive(session.Name)"
                                     FiestaWorkers="@GetFiestaWorkersForSession(session.Name)"
                                     OnSend="HandleSend"
                                     OnStop="StopSession"
                                     OnCollapse="CollapseExpanded"
                                     OnAttach="TriggerAttach"
                                     OnDismissError="DismissError"
                                     OnClearQueue="ClearQueue"
                                     OnRemoveQueuedMessage="RemoveQueuedMessage"
                                     OnRemovePendingImage="RemovePendingImage"
                                     OnSetInputMode="(mode) => SetInputMode(session.Name, mode)"
                                     OnSetModel="(model) => SetExpandedModel(session, model)"
                                     OnFontSizeChange="HandleFontSizeChange"
                                     OnLoadMore="LoadMoreExpandedMessages"
                                     OnStartFiesta="StartFiestaForSession"
                                     OnStopFiesta="StopFiestaForSession"
                                     OnStopReflection="() => StopReflectionForSession(session.Name)" />
            </KeepAliveSession>
        }
    }
    else
    {
        <div class="dashboard-header">
            <h2>Session Orchestrator</h2>
            <span class="session-count">@sessions.Count active sessions</span>
            @if (CopilotService.IsRemoteMode)
            {
                <span class="bridge-status @(CopilotService.IsBridgeConnected ? "connected" : "disconnected")" 
                      title="@(CopilotService.IsBridgeConnected ? "Bridge connected" : "Bridge disconnected ‚Äî reconnecting...")">
                    @(CopilotService.IsBridgeConnected ? "üü¢" : "üî¥")
                </span>
            }
            <div class="toolbar-actions">
                <button class="toolbar-overflow-btn" @onclick="() => toolbarMenuOpen = !toolbarMenuOpen"
                        @onclick:stopPropagation="true" title="More options">‚ãØ</button>
                <div class="toolbar-controls @(toolbarMenuOpen ? "open" : "")">
                    @if (isAddingDashGroup)
                    {
                        <input type="text" class="new-group-input" id="dashNewGroupInput"
                               placeholder="Group name..."
                               @onblur="CommitDashGroup"
                               @onkeydown="HandleDashGroupKeyDown" />
                    }
                    else if (isAddingMultiAgentGroup)
                    {
                        <input type="text" class="new-group-input" id="dashNewMultiAgentGroupInput"
                               placeholder="Multi-agent group name..."
                               @onblur="CommitMultiAgentGroup"
                               @onkeydown="HandleMultiAgentGroupKeyDown" />
                    }
                    else
                    {
                        <button class="grid-density-btn" @onclick="() => { isAddingDashGroup = true; }" title="New group">+ Group</button>
                        <button class="grid-density-btn multi-agent-btn" @onclick="() => { isAddingMultiAgentGroup = true; }" title="New multi-agent group">ü§ñ + Multi-Agent</button>
                    }
                    <button class="grid-density-btn" @onclick="ToggleGridDensity" title="@(isCompactGrid ? "Expanded grid" : "Compact grid")">
                        @(isCompactGrid ? "‚ñ§ Expanded" : "‚ñ¶ Compact")
                    </button>
                    <span class="font-size-controls">
                        <button class="font-size-btn" @onclick="DecreaseFontSize" disabled="@(fontSize <= 12)" title="Decrease font size (‚åò‚àí)">A‚àí</button>
                        <span class="font-size-label" @onclick="ResetFontSize" title="Reset font size (‚åò0)">@(fontSize)px</span>
                        <button class="font-size-btn" @onclick="IncreaseFontSize" disabled="@(fontSize >= 24)" title="Increase font size (‚åò+)">A+</button>
                    </span>
                    <select class="sort-select" @onchange="OnSortModeChanged">
                        <option value="LastActive" selected="@(CopilotService.Organization.SortMode == SessionSortMode.LastActive)">‚Üï Last Active</option>
                        <option value="CreatedAt" selected="@(CopilotService.Organization.SortMode == SessionSortMode.CreatedAt)">‚Üï Created</option>
                        <option value="Alphabetical" selected="@(CopilotService.Organization.SortMode == SessionSortMode.Alphabetical)">‚Üï A‚ÄìZ</option>
                        <option value="Manual" selected="@(CopilotService.Organization.SortMode == SessionSortMode.Manual)">‚Üï Manual</option>
                    </select>
                </div>
            </div>
        </div>
        @foreach (var (group, groupSessions) in CopilotService.GetOrganizedSessions())
        {
            var showGroupHeaders = CopilotService.HasMultipleGroups;
            @if (showGroupHeaders)
            {
                <div class="group-divider @(group.IsCollapsed ? "collapsed" : "") @(group.IsMultiAgent ? "multi-agent-group" : "")"
                     @onclick="() => CopilotService.ToggleGroupCollapsed(group.Id)">
                    @if (group.IsMultiAgent)
                    {
                        <span class="group-divider-badge">ü§ñ</span>
                    }
                    <span class="group-divider-name">@group.Name</span>
                    @if (group.IsMultiAgent)
                    {
                        <span class="group-divider-mode" @onclick:stopPropagation="true">
                            <select class="ma-mode-select" @onchange="(e) => OnMultiAgentModeChanged(group.Id, e)">
                                <option value="Broadcast" selected="@(group.OrchestratorMode == MultiAgentMode.Broadcast)">üì° Broadcast</option>
                                <option value="Sequential" selected="@(group.OrchestratorMode == MultiAgentMode.Sequential)">‚è© Sequential</option>
                                <option value="Orchestrator" selected="@(group.OrchestratorMode == MultiAgentMode.Orchestrator)">üéØ Orchestrate</option>
                                <option value="OrchestratorReflect" selected="@(group.OrchestratorMode == MultiAgentMode.OrchestratorReflect)">üîÑ Reflect</option>
                            </select>
                        </span>
                    }
                    <span class="group-divider-count">@groupSessions.Count sessions</span>
                    @if (group.IsCollapsed && groupSessions.Any(s => s.IsProcessing))
                    {
                        <span class="group-divider-busy">‚óè working</span>
                    }
                    @if (group.IsMultiAgent && !group.IsCollapsed)
                    {
                        var progress = CopilotService.GetMultiAgentProgress(group.Id);
                        @if (progress.Processing > 0)
                        {
                            <span class="group-divider-progress">
                                @progress.Completed/@progress.Total done
                            </span>
                        }
                        @if (_groupPhases.TryGetValue(group.Id, out var gridPhase))
                        {
                            <span class="phase-indicator">@PhaseLabel(gridPhase.Phase, gridPhase.Detail)</span>
                        }
                    }
                    <span class="group-divider-chevron">@(group.IsCollapsed ? "‚ñ∂" : "‚ñº")</span>
                </div>
            }

            @if (!group.IsCollapsed || !showGroupHeaders)
            {
                @if (group.IsMultiAgent && showGroupHeaders)
                {
                    <div class="multi-agent-input-bar" @onclick:stopPropagation="true">
                        @if (group.OrchestratorMode == MultiAgentMode.OrchestratorReflect)
                        {
                            <span class="reflect-iter-inline">
                                <label>Iterations:</label>
                                <input type="number" min="1" max="100" value="@GetMaxIterations(group.Id)"
                                       @onchange="(e) => SetMaxIterations(group.Id, e)"
                                       @onclick:stopPropagation="true" class="reflect-iter-input" />
                            </span>
                        }
                        <textarea id="ma-input-@group.Id" class="ma-broadcast-input" placeholder="@GetInputPlaceholder(group.OrchestratorMode)"
                                  rows="1"></textarea>
                        <button class="ma-send-btn" @onclick="() => SendToMultiAgentGroup(group.Id)" title="Send to all sessions">
                            üì° Send All
                        </button>
                    </div>
                }
                <div class="session-grid @(isCompactGrid ? "" : "expanded-grid")">
                @foreach (var session in groupSessions)
                {
                    var isCompleted = completedSessions.Contains(session.Name);
                    var cardClass = session.IsProcessing ? "processing" : isCompleted ? "completed" : "idle";
                    var meta = CopilotService.GetSessionMeta(session.Name);
                    var isPinned = meta?.IsPinned ?? false;
                    <SessionCard Session="session"
                                 @key="session.Name"
                                 Meta="meta"
                                 IsCompleted="isCompleted"
                                 MessageCount="@(cardMessageCounts.TryGetValue(session.Name, out var mc) ? mc : DefaultCardMessageWindow)"
                                 StreamingContent="@(streamingBySession.TryGetValue(session.Name, out var s) ? s : "")"
                                 ActivityText="@(activityBySession.TryGetValue(session.Name, out var a) ? a : "")"
                                 CurrentToolName="@(currentToolBySession.TryGetValue(session.Name, out var t) ? t : "")"
                                 ToolActivities="@(toolActivitiesBySession.TryGetValue(session.Name, out var ta) ? ta : new())"
                                 Intent="@(intentBySession.TryGetValue(session.Name, out var intentG) ? intentG : "")"
                                 Error="@(errorBySession.TryGetValue(session.Name, out var errG) ? errG : null)"
                                 PendingImages="@(pendingImagesBySession.TryGetValue(session.Name, out var pi) ? pi : new())"
                                 UserAvatarUrl="@CopilotService.GitHubAvatarUrl"
                                 Layout="@CopilotService.ChatLayout"
                                 Style="@CopilotService.ChatStyle"
                                 IsRenaming="@(cardRenamingSession == session.Name)"
                                 IsMenuOpen="@(cardMenuSession == session.Name)"
                                 OnGoTo="() => GoToSession(session.Name)"
                                 OnToggleMenu="() => ToggleCardMenu(session.Name)"
                                 OnExpand="() => ExpandSession(session.Name)"
                                 OnLoadMore="() => LoadMoreCardMessages(session.Name)"
                                 OnDismissError="() => DismissError(session.Name)"
                                 OnClearQueue="() => ClearQueue(session.Name)"
                                 OnRemovePendingImage="(idx) => RemovePendingImage(session.Name, idx)"
                                 OnSend="(text) => SendFromCard(session.Name, text)"
                                 OnStartRename="() => StartCardRename(session.Name)"
                                 OnCommitRename="(newName) => CommitCardRename()"
                                 OnCloseMenu="() => { cardMenuSession = null; }" />

                }
                </div>
            }
        }
    }

    @if (_showFontBubble)
    {
        <div class="font-bubble">@(fontSize)px</div>
    }
</div>

@code {
    private List<AgentSessionInfo> sessions = new();
    private HashSet<string> completedSessions = new();
    private Dictionary<string, string> streamingBySession = new();
    private Dictionary<string, string> activityBySession = new();
    private Dictionary<string, string> draftBySession = new();
    private Dictionary<string, int> expandedMessageCounts = new();
    private Dictionary<string, List<ToolActivity>> toolActivitiesBySession = new();
    private Dictionary<string, string> currentToolBySession = new();
    private Dictionary<string, string> intentBySession = new();
    private Dictionary<string, string> errorBySession = new();
    private Dictionary<string, SessionUsageInfo> usageBySession = new();
    private Dictionary<string, string> inputModeBySession = new();
    private Dictionary<string, List<PendingImage>> pendingImagesBySession = new();
    private Dictionary<string, string> shellCwdBySession = new();
    private Dictionary<string, List<string>> commandHistoryBySession = new();
    private Dictionary<string, int> historyIndexBySession = new();
    private int fontSize = 20;
    private string? expandedSession;
    private string mobileRemoteUrl = "";
    private string mobileRemoteToken = "";
    private bool mobileConnecting;
    private string? mobileConnectError;
    private bool _needsScrollToBottom;
    private volatile bool _sessionSwitching; // true during ExpandSession to skip redundant JS interop
    private bool _loadMoreObserverInitialized;
    private bool isCompactGrid;  // true = compact cards, false = spacious cards
    private bool toolbarMenuOpen;
    private string? cardMenuSession;
    private string? cardRenamingSession;
    private bool isAddingDashGroup;
    private bool isAddingMultiAgentGroup;
    private string? _focusedInputId;
    private string? _lastActiveSession;
    private int _cursorStart;
    private int _cursorEnd;
    private DotNetObjectReference<Dashboard>? _dotNetRef;
    private string? initError;
    private bool _initializationComplete = false;
    private readonly Dictionary<string, ChatMessage> _fiestaStreamingMessages = new(StringComparer.Ordinal);
    private Dictionary<string, (OrchestratorPhase Phase, string? Detail)> _groupPhases = new();

    protected override async Task OnInitializedAsync()
    {
        _renderTimer = new Timer(_ =>
        {
            if (_renderDirty)
            {
                _renderDirty = false;
                InvokeAsync(SafeRefreshAsync);
            }
        }, null, Timeout.Infinite, Timeout.Infinite);
        
        CopilotService.OnStateChanged += RefreshState;
        CopilotService.OnSessionComplete += HandleComplete;
        CopilotService.OnContentReceived += HandleContent;
        CopilotService.OnActivity += HandleActivity;
        CopilotService.OnToolStarted += HandleToolStarted;
        CopilotService.OnToolCompleted += HandleToolCompleted;
        CopilotService.OnReasoningReceived += HandleReasoningReceived;
        CopilotService.OnReasoningComplete += HandleReasoningComplete;
        CopilotService.OnIntentChanged += HandleIntentChanged;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        CopilotService.OnError += HandleError;
        CopilotService.OnTurnStart += HandleTurnStart;
        CopilotService.OnTurnEnd += HandleTurnEnd;
        CopilotService.OnOrchestratorPhaseChanged += HandleOrchestratorPhaseChanged;
        FiestaService.OnStateChanged += HandleFiestaStateChanged;
        FiestaService.OnHostTaskUpdate += HandleFiestaTaskUpdate;

        await Initialize();

        // Pre-fill remote connection fields from saved settings
        if (PlatformHelper.IsMobile)
        {
            var cs = ConnectionSettings.Load();
            mobileRemoteUrl = cs.RemoteUrl ?? "";
            mobileRemoteToken = cs.RemoteToken ?? "";
        }
    }

    private async Task Initialize()
    {
        initError = null;
        try
        {
            // Load UI state FIRST, before initializing (which triggers RefreshState)
            var uiState = CopilotService.LoadUiState();
            if (uiState != null)
            {
                Console.WriteLine($"[Dashboard] Restoring UI state: ExpandedSession={uiState.ExpandedSession}, ExpandedGrid={uiState.ExpandedGrid}, CurrentPage={uiState.CurrentPage}");
                
                // Restore font size
                if (uiState.FontSize >= 12 && uiState.FontSize <= 24)
                    fontSize = uiState.FontSize;

                // Restore per-session input modes (chat/plan/autopilot)
                if (uiState.InputModes?.Count > 0)
                {
                    inputModeBySession = uiState.InputModes
                        .Where(kvp => !string.IsNullOrWhiteSpace(kvp.Key) && IsValidInputMode(kvp.Value))
                        .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
                }
                
                // Restore expanded grid state (inverted: isCompactGrid)
                isCompactGrid = !uiState.ExpandedGrid;
                Console.WriteLine($"[Dashboard] Set isCompactGrid = {isCompactGrid} (from ExpandedGrid={uiState.ExpandedGrid})");
                
                // Restore expanded session state
                if (!string.IsNullOrEmpty(uiState.ExpandedSession))
                {
                    expandedSession = uiState.ExpandedSession;
                    _explicitlyCollapsed = false;
                    _initialGridSet = true; // Prevent RefreshState from overriding
                    // Don't set active session yet - will do after Initialize
                    Console.WriteLine($"[Dashboard] Will restore to expanded session: {uiState.ExpandedSession}");
                }
                else if (uiState.CurrentPage == "/dashboard" || uiState.CurrentPage == "/")
                {
                    // User was in grid view, don't auto-expand
                    _explicitlyCollapsed = true;
                    _initialGridSet = true; // Prevent RefreshState from overriding
                    Console.WriteLine($"[Dashboard] Will restore to grid view (no expanded session)");
                }
            }
            else
            {
                Console.WriteLine("[Dashboard] No UI state found to restore");
            }

            await CopilotService.InitializeAsync();

            // Wait for sessions to arrive (remote mode needs time to sync)
            if (!CopilotService.GetAllSessions().Any())
            {
                await Task.Delay(2000);
            }
            sessions = CopilotService.GetAllSessions().ToList();

            if (CopilotService.NeedsConfiguration)
            {
                // Stay on dashboard, user can navigate to settings manually
            }

            // Now set the active session after initialization
            if (uiState != null)
            {
                if (!string.IsNullOrEmpty(uiState.ExpandedSession))
                {
                    CopilotService.SetActiveSession(uiState.ExpandedSession);
                    _focusedInputId = $"input-{uiState.ExpandedSession.Replace(" ", "-")}";
                    _needsScrollToBottom = true;
                }
                else if (uiState.CurrentPage == "/dashboard" || uiState.CurrentPage == "/")
                {
                    CopilotService.SetActiveSession(null); // Clear any auto-set active session
                }
            }

            // When multiple sessions exist and no saved state, start on grid view
            if (sessions.Count > 1 && CopilotService.ActiveSessionName == null && uiState == null)
            {
                _explicitlyCollapsed = true;
            }

            var connSettings = ConnectionSettings.Load();
            if (connSettings.AutoStartTunnel && DevTunnelService.State == TunnelState.NotStarted)
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        var success = await DevTunnelService.HostAsync(connSettings.Port);
                        if (!success)
                        {
                            Console.WriteLine("[AutoStart] Tunnel failed, falling back to direct sharing");
                            StartDirectSharingIfEnabled(connSettings);
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[AutoStart] Tunnel error: {ex.Message}");
                        StartDirectSharingIfEnabled(connSettings);
                    }
                });
            }
            else
            {
                // No tunnel auto-start ‚Äî try direct sharing
                StartDirectSharingIfEnabled(connSettings);
            }

            GitAutoUpdate.Initialize();
            
            _initializationComplete = true; // Allow RefreshState to process changes now
        }
        catch (Exception ex)
        {
            initError = Models.ErrorMessageHelper.Humanize(ex);
            Console.WriteLine($"Init error: {ex}");
            _initializationComplete = true; // Even on error, allow normal operation
        }

        RefreshState();
    }

    private void StartDirectSharingIfEnabled(ConnectionSettings connSettings)
    {
        if (connSettings.DirectSharingEnabled && !string.IsNullOrEmpty(connSettings.ServerPassword)
            && !WsBridgeServer.IsRunning && DevTunnelService.State != TunnelState.Running)
        {
            WsBridgeServer.ServerPassword = connSettings.ServerPassword;
            WsBridgeServer.SetCopilotService(CopilotService);
            WsBridgeServer.Start(DevTunnelService.BridgePort, connSettings.Port);
        }
    }

    private void GoToSettings()
    {
        Nav.NavigateTo("/settings");
    }

    private void DismissFallbackNotice()
    {
        CopilotService.ClearFallbackNotice();
        StateHasChanged();
    }

    private async Task DashboardScanQr()
    {
        var result = await QrScanner.ScanAsync();
        if (string.IsNullOrEmpty(result)) return;

        try
        {
            // Try JSON format first: { "url": "...", "token": "..." }
            var doc = System.Text.Json.JsonDocument.Parse(result);
            if (doc.RootElement.TryGetProperty("url", out var urlProp))
                mobileRemoteUrl = urlProp.GetString() ?? "";
            if (doc.RootElement.TryGetProperty("token", out var tokenProp))
                mobileRemoteToken = tokenProp.GetString() ?? "";
        }
        catch
        {
            // Try polypilot:// URI format: polypilot://connect?url=...&token=...
            if (result.StartsWith("polypilot://", StringComparison.OrdinalIgnoreCase)
                && Uri.TryCreate(result, UriKind.Absolute, out var uri))
            {
                var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
                mobileRemoteUrl = query["url"] ?? "";
                mobileRemoteToken = query["token"] ?? "";
            }
            else
            {
                mobileRemoteUrl = result;
            }
        }

        // Auto-connect after scan
        await DashboardConnect();
    }

    private async Task DashboardConnect()
    {
        if (string.IsNullOrWhiteSpace(mobileRemoteUrl)) return;
        mobileConnecting = true;
        mobileConnectError = null;
        StateHasChanged();

        try
        {
            var connSettings = ConnectionSettings.Load();
            connSettings.Mode = ConnectionMode.Remote;
            connSettings.RemoteUrl = mobileRemoteUrl;
            connSettings.RemoteToken = mobileRemoteToken;
            connSettings.Save();
            await CopilotService.ReconnectAsync(connSettings);
        }
        catch (Exception ex)
        {
            mobileConnectError = ex.Message;
        }

        mobileConnecting = false;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("eval", @"
                if (!window.__dashboardKeydownRegistered) {
                    window.__dashboardKeydownRegistered = true;
                    document.addEventListener('keydown', function(e) {
                        var sel = '.card-input input, .card-input textarea, .input-row textarea';
                        var isInput = e.target.matches && e.target.matches(sel);
                        if (e.key === 'Enter' && !e.shiftKey && isInput) {
                            e.preventDefault();
                            if (window.__sendPending) return;
                            window.__sendPending = true;
                            setTimeout(function() { window.__sendPending = false; }, 500);
                            var container = e.target.closest('.card-input') || e.target.closest('.input-row');
                            if (container) {
                                var btn = container.querySelector('.send-btn:not(.stop-btn)') || container.querySelectorAll('button')[container.querySelectorAll('button').length - 1];
                                if (btn) btn.click();
                            }
                        }
                        // ArrowUp/Down: command history navigation
                        if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && isInput && !e.shiftKey && !e.metaKey && !e.ctrlKey) {
                            var ta = e.target;
                            var atStart = ta.selectionStart === 0 && ta.selectionEnd === 0;
                            var atEnd = ta.selectionStart === ta.value.length;
                            if ((e.key === 'ArrowUp' && atStart) || (e.key === 'ArrowDown' && atEnd)) {
                                var card = ta.closest('[data-session]');
                                var sessionName = card ? card.dataset.session : '';
                                if (sessionName && window.__dashRef) {
                                    e.preventDefault();
                                    window.__dashRef.invokeMethodAsync('JsNavigateHistory', sessionName, e.key === 'ArrowUp');
                                }
                            }
                        }
                        if (e.key === 'Tab' && isInput) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            var expandedCard = document.querySelector('.expanded-card');
                            if (expandedCard && window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsCycleExpandedSession', e.shiftKey);
                                return;
                            }
                            var inputs = Array.from(document.querySelectorAll(sel));
                            if (inputs.length < 2) return;
                            var idx = inputs.indexOf(e.target);
                            if (idx < 0) idx = 0;
                            idx = e.shiftKey ? (idx - 1 + inputs.length) % inputs.length : (idx + 1) % inputs.length;
                            inputs[idx].focus();
                            var card = inputs[idx].closest('.session-card');
                            if (card && card.dataset.session && window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsSelectSession', card.dataset.session);
                            }
                        }
                        if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
                            e.preventDefault();
                            var collapseBtn = document.querySelector('.collapse-card-btn');
                            if (collapseBtn) { collapseBtn.click(); return; }
                            var card = isInput ? e.target.closest('.session-card') : document.querySelector('.session-card');
                            if (card && card.dataset.session && window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsExpandSession', card.dataset.session);
                            }
                        }
                        if (e.key === 'Escape') {
                            var collapseBtn = document.querySelector('.collapse-card-btn');
                            if (collapseBtn) collapseBtn.click();
                        }
                        // ‚åò1-9 / Ctrl+1-9: switch to session by index
                        if ((e.metaKey || e.ctrlKey) && e.key >= '1' && e.key <= '9') {
                            e.preventDefault();
                            if (window.__dashRef) {
                                window.__dashRef.invokeMethodAsync('JsSwitchToSessionByIndex', parseInt(e.key));
                            }
                        }
                        // ‚åò+/‚åò- / Ctrl+=/Ctrl+-: font size, ‚åò0 reset
                        if ((e.metaKey || e.ctrlKey) && (e.key === '=' || e.key === '+' || e.key === '-' || e.key === '0')) {
                            e.preventDefault();
                            if (window.__dashRef) {
                                var delta = (e.key === '=' || e.key === '+') ? 1 : e.key === '-' ? -1 : 0;
                                window.__dashRef.invokeMethodAsync('JsChangeFontSize', delta);
                            }
                        }
                        // Ctrl+C: interrupt running session (only when no text selected)
                        if (e.ctrlKey && e.key === 'c' && !e.metaKey && !e.shiftKey) {
                            var selection = window.getSelection();
                            if (!selection || selection.toString().length === 0) {
                                e.preventDefault();
                                if (window.__dashRef) {
                                    window.__dashRef.invokeMethodAsync('JsInterruptSession');
                                }
                            }
                        }
                    });
                }
            ");
            try
            {
                var dotNetRef = DotNetObjectReference.Create(this);
                if (_disposed) { dotNetRef.Dispose(); return; }
                await JS.InvokeVoidAsync("eval", "window.__dashRef = null;");
                _dotNetRef = dotNetRef;
                await JS.InvokeVoidAsync("eval", "window.__setDashRef = function(ref) { window.__dashRef = ref; };");
                if (_disposed) return;
                await JS.InvokeVoidAsync("__setDashRef", _dotNetRef);
                await JS.InvokeVoidAsync("eval", @"
                if (!window.__textareaAutoResize) {
                    window.__textareaAutoResize = true;
                    document.addEventListener('input', function(e) {
                        if (e.target.tagName === 'TEXTAREA' && e.target.closest('.input-row')) {
                            e.target.style.height = 'auto';
                            e.target.style.height = Math.min(e.target.scrollHeight, 150) + 'px';
                        }
                    });
                }
            ");
            }
            catch (ObjectDisposedException) { }
        }

        // Auto-scroll all card message containers to bottom
        // Restore draft text, focus, and cursor position ‚Äî all in ONE JS call
        var draftsJson = "{}";
        if (draftBySession.Count > 0)
        {
            var draftMap = new Dictionary<string, string>();
            foreach (var (name, draft) in draftBySession)
            {
                if (!string.IsNullOrEmpty(draft))
                    draftMap[$"input-{name.Replace(" ", "-")}"] = draft;
            }
            draftsJson = System.Text.Json.JsonSerializer.Serialize(draftMap);
        }
        var focusId = _focusedInputId ?? "";
        var selStart = _cursorStart;
        var selEnd = _cursorEnd;
        _focusedInputId = null;

        var forceScroll = _needsScrollToBottom;
        _needsScrollToBottom = false;

        // Restore drafts, focus, and scroll position ‚Äî fire-and-forget to avoid blocking render pipeline
        _ = JS.InvokeVoidAsync("restoreDraftsAndFocus", draftsJson, focusId, selStart, selEnd, forceScroll);

        // Set initial active slot on first render (MutationObserver will maintain it after user interactions)
        if (expandedSession != null)
        {
            _ = JS.InvokeVoidAsync("switchKeepAliveSlot", $"slot-{expandedSession.Replace(" ", "-")}", expandedSession);
        }

        // Set up load-more observer only when needed (new .load-more-btn elements may appear)
        if (!_loadMoreObserverInitialized || forceScroll)
        {
            _loadMoreObserverInitialized = true;
            _ = JS.InvokeVoidAsync("eval", @"
                if (!window.__loadMoreObserver) {
                    window.__loadMoreObserver = new IntersectionObserver(function(entries) {
                        entries.forEach(function(entry) {
                            if (entry.isIntersecting) entry.target.click();
                        });
                    }, { threshold: 0.1 });
                }
                document.querySelectorAll('.messages .load-more-btn').forEach(function(btn) {
                    if (!btn.__observed) { btn.__observed = true; window.__loadMoreObserver.observe(btn); }
                });
            ");
        }
    }

    private DateTime _lastRefresh = DateTime.MinValue;
    private volatile bool _renderDirty;
    private Timer? _renderTimer;
    private long _switchCooldownUntil; // TickCount64 value: suppress renders until this time
    private readonly RenderThrottle _refreshThrottle = new(500);

    private void ScheduleRender()
    {
        if (_disposed) return;
        _renderDirty = true;
        // Throttle: only reset timer if not already scheduled (avoid starving rapid updates)
        try { _renderTimer?.Change(50, Timeout.Infinite); } catch (ObjectDisposedException) { }
    }

    private async Task SafeRefreshAsync()
    {
        if (_disposed) return;
        // During switch cooldown, skip render to let browser paint the CSS toggle uninterrupted
        var cooldownUntil = Interlocked.Read(ref _switchCooldownUntil);
        if (Environment.TickCount64 < cooldownUntil)
        {
            // Re-schedule to try again after cooldown expires
            var remaining = (int)(cooldownUntil - Environment.TickCount64);
            if (remaining > 0)
                try { _renderTimer?.Change(remaining + 10, Timeout.Infinite); } catch (ObjectDisposedException) { }
            return;
        }

        // During a session switch, drafts were already saved ‚Äî skip the expensive JS round-trip
        if (!_sessionSwitching)
        {
            // Capture all card input values before re-render wipes them
            try
            {
                var json = await JS.InvokeAsync<string>("eval", @"
                    (function() {
                        var result = {};
                        var active = document.activeElement;
                        document.querySelectorAll('.card-input input, .card-input textarea, .expanded-card .input-area textarea').forEach(function(el) {
                            if (el.id && el.value) result[el.id] = el.value;
                        });
                        if (active && active.id) result['__focused'] = active.id;
                        if (active) { result['__selStart'] = active.selectionStart || 0; result['__selEnd'] = active.selectionEnd || 0; }
                        return JSON.stringify(result);
                    })();
                ");
                if (!string.IsNullOrEmpty(json))
                {
                    var saved = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, string>>(json);
                    if (saved != null)
                    {
                        foreach (var (id, val) in saved)
                        {
                            if (id.StartsWith("__")) continue;
                            var sessionName = id.Replace("input-", "").Replace("-", " ");
                            if (!string.IsNullOrEmpty(val))
                                draftBySession[sessionName] = val;
                        }
                        if (saved.TryGetValue("__focused", out var fid))
                            _focusedInputId = fid;
                        if (saved.TryGetValue("__selStart", out var ss) && int.TryParse(ss, out var start))
                            _cursorStart = start;
                        if (saved.TryGetValue("__selEnd", out var se) && int.TryParse(se, out var end))
                            _cursorEnd = end;
                    }
                }
            }
            catch { }
        }
        _sessionSwitching = false;
        StateHasChanged();
    }

    private bool _explicitlyCollapsed;
    private bool _initialGridSet;
    private bool _refreshing;

    private void RefreshState()
    {
        if (_refreshing) return;
        if (!_initializationComplete) return;
        _refreshing = true;
        try
        {
            var active = CopilotService.ActiveSessionName;
            bool sessionSwitched = active != null && active != _lastActiveSession && _lastActiveSession != null;
            
            // Throttle non-switch state changes to max 2/sec, but always allow completed sessions through
            if (!_refreshThrottle.ShouldRefresh(sessionSwitched, completedSessions.Count > 0))
                return;

            sessions = CopilotService.GetAllSessions().ToList();

            if (!_initialGridSet && sessions.Count > 1)
            {
                _initialGridSet = true;
                var selected = CopilotService.ActiveSessionName;
                if (selected != null && sessions.Any(s => s.Name == selected))
                {
                    expandedSession = selected;
                    _lastActiveSession = selected;
                    _focusedInputId = $"input-{selected.Replace(" ", "-")}";
                }
                else
                {
                    expandedSession = null;
                    _lastActiveSession = selected;
                    if (selected != null)
                        CopilotService.SetActiveSession(null);
                }
                InvokeAsync(SafeRefreshAsync);
                return;
            }

            if (sessions.Count == 1 && expandedSession == null && !_explicitlyCollapsed)
            {
                expandedSession = sessions[0].Name;
                CopilotService.SwitchSession(sessions[0].Name);
            }
            if (sessionSwitched && sessions.Any(s => s.Name == active))
            {
                _lastActiveSession = active;
                expandedSession = active;
                _focusedInputId = $"input-{active!.Replace(" ", "-")}";
                _needsScrollToBottom = true;
                CopilotService.SaveUiState("/dashboard", activeSession: active, expandedSession: active, expandedGrid: !isCompactGrid);
            }
            // Ensure expandedSession stays in sync with active session (e.g., sidebar flyout selection on mobile)
            else if (active != null && expandedSession != null && expandedSession != active && sessions.Any(s => s.Name == active))
            {
                _lastActiveSession = active;
                expandedSession = active;
                _needsScrollToBottom = true;
            }
            
            if (_lastActiveSession == null && active != null)
            {
                _lastActiveSession = active;
            }
            foreach (var s in sessions)
            {
                if (!s.IsProcessing && streamingBySession.ContainsKey(s.Name))
                    streamingBySession.Remove(s.Name);
            }
            if (sessionSwitched)
            {
                // _sessionSwitching stays true until SafeRefreshAsync reads it ‚Äî 
                // this skips the expensive JS draft capture round-trip during switches
                _needsScrollToBottom = true;
                // CSS toggle already done by sidebar/ExpandSession ‚Äî suppress renders during cooldown
                var newCooldown = Environment.TickCount64 + 300;
                long current;
                do { current = Interlocked.Read(ref _switchCooldownUntil); }
                while (newCooldown > current && Interlocked.CompareExchange(ref _switchCooldownUntil, newCooldown, current) != current);
                ScheduleRender(); // Will be deferred past cooldown by SafeRefreshAsync
            }
            else
                ScheduleRender();
        }
        finally { _refreshing = false; }
    }

    private void HandleComplete(string sessionName, string summary)
    {
        // Already on UI thread (called from CompleteResponse via Invoke/SynchronizationContext.Post).
        // Must be synchronous ‚Äî InvokeAsync defers and causes stale renders.
        if (_disposed) return;
        completedSessions.Add(sessionName);
        streamingBySession.Remove(sessionName);
        activityBySession.Remove(sessionName);
        sessions = CopilotService.GetAllSessions().ToList();
        StateHasChanged();
        // This callback runs on thread-pool ‚Äî DOES need InvokeAsync.
        _ = Task.Delay(10000).ContinueWith(_ =>
            InvokeAsync(() =>
            {
                if (_disposed) return;
                completedSessions.Remove(sessionName);
                StateHasChanged();
            }));
    }

    private void HandleContent(string sessionName, string content)
    {
        if (!streamingBySession.ContainsKey(sessionName))
            streamingBySession[sessionName] = "";
        streamingBySession[sessionName] += content;
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleActivity(string sessionName, string activity)
    {
        activityBySession[sessionName] = activity;
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleToolStarted(string sessionName, string toolName, string callId, string? inputSummary)
    {
        // Clear streaming content when tool starts - the text was flushed to history
        streamingBySession.Remove(sessionName);
        
        currentToolBySession[sessionName] = toolName;
        if (!toolActivitiesBySession.ContainsKey(sessionName))
            toolActivitiesBySession[sessionName] = new();
        // Deduplicate: update existing activity if replayed
        var existing = toolActivitiesBySession[sessionName].FirstOrDefault(a => a.CallId == callId);
        if (existing != null)
        {
            if (!string.IsNullOrEmpty(inputSummary)) existing.Input = inputSummary;
            return;
        }
        toolActivitiesBySession[sessionName].Add(new ToolActivity
        {
            Name = toolName,
            CallId = callId,
            Input = inputSummary,
            StartedAt = DateTime.Now
        });
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleToolCompleted(string sessionName, string callId, string result, bool success)
    {
        if (toolActivitiesBySession.TryGetValue(sessionName, out var activities))
        {
            var activity = activities.LastOrDefault(a => a.CallId == callId);
            if (activity != null)
            {
                activity.IsComplete = true;
                activity.IsSuccess = success;
                activity.Result = result;
                activity.CompletedAt = DateTime.Now;
            }
        }
        currentToolBySession.Remove(sessionName);
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleIntentChanged(string sessionName, string intent)
    {
        intentBySession[sessionName] = intent;
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleReasoningReceived(string sessionName, string reasoningId, string content)
    {
        if (!string.IsNullOrEmpty(sessionName) && !string.IsNullOrEmpty(content))
            _needsScrollToBottom = true;
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleReasoningComplete(string sessionName, string reasoningId)
    {
        if (!string.IsNullOrEmpty(sessionName) && !string.IsNullOrEmpty(reasoningId))
            _needsScrollToBottom = true;
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (usageBySession.TryGetValue(sessionName, out var current))
        {
            usageBySession[sessionName] = new SessionUsageInfo(
                info.Model ?? current.Model,
                info.CurrentTokens ?? current.CurrentTokens,
                info.TokenLimit ?? current.TokenLimit,
                info.InputTokens ?? current.InputTokens,
                info.OutputTokens ?? current.OutputTokens,
                info.PremiumQuota ?? current.PremiumQuota);
        }
        else
        {
            usageBySession[sessionName] = info;
        }
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleError(string sessionName, string error)
    {
        if (error.Contains("cancell", StringComparison.OrdinalIgnoreCase)) return;
        errorBySession[sessionName] = Models.ErrorMessageHelper.HumanizeMessage(error);
        ScheduleRender();
    }

    private void HandleTurnStart(string sessionName)
    {
        streamingBySession.Remove(sessionName);
        currentToolBySession.Remove(sessionName);
        toolActivitiesBySession[sessionName] = new();
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleTurnEnd(string sessionName)
    {
        intentBySession.Remove(sessionName);
        currentToolBySession.Remove(sessionName);
        if (sessionName == expandedSession || expandedSession == null)
            ScheduleRender();
    }

    private void HandleOrchestratorPhaseChanged(string groupId, OrchestratorPhase phase, string? detail)
    {
        if (phase == OrchestratorPhase.Complete)
            _groupPhases.Remove(groupId);
        else
            _groupPhases[groupId] = (phase, detail);
        ScheduleRender();
    }

    private static string PhaseLabel(OrchestratorPhase phase, string? detail) => phase switch
    {
        OrchestratorPhase.Planning => "üéØ Planning...",
        OrchestratorPhase.Dispatching => "üì° Dispatching..." + (detail != null ? $" {detail}" : ""),
        OrchestratorPhase.WaitingForWorkers => "‚è≥ Waiting for workers...",
        OrchestratorPhase.Synthesizing => "üîÑ Synthesizing...",
        _ => ""
    };

    private void DismissError(string sessionName)
    {
        errorBySession.Remove(sessionName);
    }

    private async Task SendFromCard(string sessionName, string? explicitText = null)
    {
        var inputId = $"input-{sessionName.Replace(" ", "-")}";
        var prompt = explicitText ?? await JS.InvokeAsync<string>("getElementValue", inputId);
        var hasImages = pendingImagesBySession.TryGetValue(sessionName, out var pendingSendImages) && pendingSendImages.Count > 0;
        if (string.IsNullOrWhiteSpace(prompt) && !hasImages) return;

        if (explicitText == null) // Only clear if we read from DOM, otherwise child component cleared it
            await JS.InvokeVoidAsync("clearElementValue", inputId);
        draftBySession.Remove(sessionName);

        var finalPrompt = (prompt ?? "").Trim();

        // Record in command history
        if (!string.IsNullOrWhiteSpace(finalPrompt))
        {
            if (!commandHistoryBySession.ContainsKey(sessionName))
                commandHistoryBySession[sessionName] = new();
            var history = commandHistoryBySession[sessionName];
            // Avoid consecutive duplicates
            if (history.Count == 0 || history[^1] != finalPrompt)
            {
                history.Add(finalPrompt);
                if (history.Count > 50) history.RemoveAt(0);
            }
            historyIndexBySession[sessionName] = history.Count; // past the end = "no selection"
        }

        // Handle ! shell commands
        if (finalPrompt.StartsWith("!") && finalPrompt.Length > 1)
        {
            var shellCmd = finalPrompt.Substring(1).TrimStart();
            await ExecuteShellCommand(sessionName, shellCmd);
            return;
        }

        // Handle / slash commands
        if (finalPrompt.StartsWith("/"))
        {
            await HandleSlashCommand(sessionName, finalPrompt);
            return;
        }

        var inputMode = GetInputMode(sessionName);
        if (inputMode == "plan")
            finalPrompt = $"[[PLAN]] {finalPrompt}";
        else if (inputMode == "autopilot")
            finalPrompt = $"[[AUTOPILOT]] {finalPrompt}";

        var dispatch = await FiestaService.DispatchMentionedWorkAsync(sessionName, finalPrompt);
        if (dispatch.MentionsFound)
        {
            var hostSession = sessions.FirstOrDefault(s => s.Name == sessionName);
            hostSession?.History.Add(ChatMessage.UserMessage(finalPrompt));
            if (hostSession != null)
            {
                hostSession.MessageCount = hostSession.History.Count;
                if (dispatch.DispatchCount > 0)
                {
                    hostSession.History.Add(ChatMessage.SystemMessage(
                        $"üéâ Dispatched to {dispatch.DispatchCount} worker{(dispatch.DispatchCount == 1 ? "" : "s")} in Fiesta mode."));
                    hostSession.MessageCount = hostSession.History.Count;
                }
            }
            _needsScrollToBottom = true;
            await InvokeAsync(SafeRefreshAsync);
            return;
        }

        var session = sessions.FirstOrDefault(s => s.Name == sessionName);
        if (session?.IsProcessing == true)
        {
            List<string>? queueImagePaths = null;
            if (hasImages)
            {
                queueImagePaths = pendingSendImages!.Select(i => i.TempPath).ToList();
                pendingImagesBySession.Remove(sessionName);
            }
            CopilotService.EnqueueMessage(sessionName, finalPrompt, queueImagePaths);
            return;
        }

        List<string>? imagePaths = null;
        if (hasImages)
        {
            imagePaths = pendingSendImages!.Select(i => i.TempPath).ToList();
            pendingImagesBySession.Remove(sessionName);
        }

        _needsScrollToBottom = true;
        streamingBySession.Remove(sessionName);
        activityBySession.Remove(sessionName);

        // Force scroll to bottom immediately after sending
        await JS.InvokeVoidAsync("eval", @"
            document.querySelectorAll('.card-messages, .messages').forEach(function(el) {
                el.scrollTop = el.scrollHeight;
            });
            setTimeout(function() {
                document.querySelectorAll('.card-messages, .messages').forEach(function(el) {
                    el.scrollTop = el.scrollHeight;
                });
            }, 100);
        ");

        try
        {
            _ = CopilotService.SendPromptAsync(sessionName, finalPrompt, imagePaths).ContinueWith(t =>
            {
                if (t.IsFaulted)
                {
                    InvokeAsync(() =>
                    {
                        Console.WriteLine($"Error sending to {sessionName}: {t.Exception?.InnerException?.Message}");
                    });
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending to {sessionName}: {ex.Message}");
        }
    }

    private string GetShellCwd(string sessionName)
    {
        if (!shellCwdBySession.TryGetValue(sessionName, out var cwd))
        {
            // Default to the session's working directory if available
            var session = CopilotService.GetAllSessions().FirstOrDefault(s => s.Name == sessionName);
            cwd = session?.WorkingDirectory ?? Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        }
        return cwd;
    }

    private async Task ExecuteShellCommand(string sessionName, string command)
    {
        var session = CopilotService.GetAllSessions().FirstOrDefault(s => s.Name == sessionName);
        if (session == null) return;

        session.History.Add(ChatMessage.UserMessage($"!{command}"));
        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);

        // Handle cd as a built-in: resolve the path and update the tracked cwd
        var trimmed = command.Trim();
        if (trimmed == "cd" || trimmed.StartsWith("cd "))
        {
            var arg = trimmed == "cd" ? "~" : trimmed.Substring(3).Trim();
            if (string.IsNullOrEmpty(arg) || arg == "~")
                arg = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            else if (arg.StartsWith("~/"))
                arg = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), arg.Substring(2));

            var cwd = GetShellCwd(sessionName);
            var resolved = Path.GetFullPath(Path.Combine(cwd, arg));

            if (Directory.Exists(resolved))
            {
                shellCwdBySession[sessionName] = resolved;
                session.History.Add(ChatMessage.SystemMessage(resolved));
            }
            else
            {
                session.History.Add(ChatMessage.ErrorMessage($"cd: no such directory: {resolved}"));
            }

            session.MessageCount = session.History.Count;
            _needsScrollToBottom = true;
            await InvokeAsync(SafeRefreshAsync);
            return;
        }

        try
        {
            var cwd = GetShellCwd(sessionName);
            using var process = new System.Diagnostics.Process();
            process.StartInfo = new System.Diagnostics.ProcessStartInfo
            {
                FileName = "/bin/bash",
                Arguments = $"-c \"{command.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = cwd
            };
            process.Start();
            var stdout = await process.StandardOutput.ReadToEndAsync();
            var stderr = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();

            var output = stdout;
            if (!string.IsNullOrEmpty(stderr))
                output = string.IsNullOrEmpty(output) ? stderr : $"{output}\n{stderr}";
            if (string.IsNullOrEmpty(output))
                output = $"(exit code {process.ExitCode})";

            session.History.Add(ChatMessage.ShellOutputMessage(output.TrimEnd(), process.ExitCode));
        }
        catch (Exception ex)
        {
            session.History.Add(ChatMessage.ErrorMessage($"Shell error: {ex.Message}"));
        }

        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private async Task HandleSlashCommand(string sessionName, string input)
    {
        var session = sessions.FirstOrDefault(s => s.Name == sessionName);
        if (session == null) return;

        var parts = input.TrimStart('/').Split(' ', 2, StringSplitOptions.TrimEntries);
        var cmd = parts[0].ToLowerInvariant();
        var arg = parts.Length > 1 ? parts[1] : "";

        session.History.Add(ChatMessage.UserMessage(input));
        session.MessageCount = session.History.Count;

        switch (cmd)
        {
            case "help":
                session.History.Add(ChatMessage.SystemMessage(
                    "**Available commands:**\n" +
                    "- `/help` ‚Äî Show this help\n" +
                    "- `/clear` ‚Äî Clear chat history\n" +
                    "- `/compact` ‚Äî Summarize conversation and start fresh\n" +
                    "- `/new [name]` ‚Äî Create a new session\n" +
                    "- `/sessions` ‚Äî List all sessions\n" +
                    "- `/rename <name>` ‚Äî Rename current session\n" +
                    "- `/version` ‚Äî Show version info\n" +
                    "- `/diff [args]` ‚Äî Show git diff\n" +
                    "- `/status` ‚Äî Show git status\n" +
                    "- `/mcp` ‚Äî List MCP servers (enable/disable with `/mcp enable|disable <name>`)\n" +
                    "- `/plugin` ‚Äî List installed plugins (enable/disable with `/plugin enable|disable <name>`)\n" +
                    "- `/reflect <goal>` ‚Äî Start a reflection cycle (`/reflect help` for details)\n" +
                    "- `!<command>` ‚Äî Run a shell command"));
                break;

            case "clear":
                CopilotService.ClearHistory(sessionName);
                session.History.Add(ChatMessage.SystemMessage("Chat history cleared."));
                break;

            case "version":
                var appVersion = AppInfo.Current.VersionString;
                var buildVersion = AppInfo.Current.BuildString;
                var sdkVersion = typeof(GitHub.Copilot.SDK.CopilotClient).Assembly.GetName().Version?.ToString() ?? "unknown";
                var runtime = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription;
                var gitCommit = "";
                try
                {
                    var gitDir = Path.GetDirectoryName(AppContext.BaseDirectory);
                    for (int i = 0; i < 20 && gitDir != null; i++)
                    {
                        gitDir = Path.GetDirectoryName(gitDir);
                        if (gitDir != null && Directory.Exists(Path.Combine(gitDir, ".git")))
                        {
                            var headFile = Path.Combine(gitDir, ".git", "HEAD");
                            if (File.Exists(headFile))
                            {
                                var head = File.ReadAllText(headFile).Trim();
                                if (head.StartsWith("ref: "))
                                {
                                    var refPath = Path.Combine(gitDir, ".git", head[5..]);
                                    if (File.Exists(refPath))
                                        gitCommit = File.ReadAllText(refPath).Trim()[..7];
                                }
                                else if (head.Length >= 7)
                                    gitCommit = head[..7];
                            }
                            break;
                        }
                    }
                }
                catch { }
                var versionText = $"**PolyPilot** v{appVersion} (build {buildVersion})\n" +
                    $"**SDK:** GitHub.Copilot.SDK {sdkVersion}\n" +
                    $"**Runtime:** {runtime}" +
                    (string.IsNullOrEmpty(gitCommit) ? "" : $"\n**Git:** {gitCommit}");
                session.History.Add(ChatMessage.SystemMessage(versionText));
                break;

            case "compact":
                session.History.Add(ChatMessage.SystemMessage("Compacting conversation..."));
                session.MessageCount = session.History.Count;
                _needsScrollToBottom = true;
                await InvokeAsync(SafeRefreshAsync);
                _ = CopilotService.SendPromptAsync(sessionName,
                    "Summarize our conversation so far into a concise context block, then we'll continue from there. Keep key decisions, file paths, and code snippets. Drop routine chatter.");
                return;

            case "new":
                var newName = string.IsNullOrWhiteSpace(arg)
                    ? $"Session {CopilotService.SessionCount + 1}"
                    : arg;
                await CopilotService.CreateSessionAsync(newName);
                sessions = CopilotService.GetAllSessions().ToList();
                var created = sessions.LastOrDefault();
                if (created != null)
                {
                    CopilotService.SetActiveSession(created.Name);
                    expandedSession = created.Name;
                    _explicitlyCollapsed = false;
                }
                await InvokeAsync(SafeRefreshAsync);
                return;

            case "sessions":
                var allSessions = CopilotService.GetAllSessions().ToList();
                var listing = string.Join("\n", allSessions.Select((s, i) =>
                    $"- {(s.Name == sessionName ? "**" : "")}{s.Name}{(s.Name == sessionName ? "** (current)" : "")}" +
                    $" ‚Äî {s.MessageCount} messages" +
                    $"{(s.IsProcessing ? " ‚è≥" : "")}"));
                session.History.Add(ChatMessage.SystemMessage(
                    $"**{allSessions.Count} session{(allSessions.Count != 1 ? "s" : "")}:**\n{listing}"));
                break;

            case "rename":
                if (string.IsNullOrWhiteSpace(arg))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: /rename <new name>"));
                }
                else
                {
                    var success = CopilotService.RenameSession(sessionName, arg);
                    if (success)
                    {
                        if (expandedSession == sessionName)
                            expandedSession = arg;
                        sessions = CopilotService.GetAllSessions().ToList();
                        session = sessions.FirstOrDefault(s => s.Name == arg);
                        session?.History.Add(ChatMessage.SystemMessage($"Session renamed to **{arg}**."));
                    }
                    else
                    {
                        session.History.Add(ChatMessage.ErrorMessage($"Failed to rename ‚Äî \"{arg}\" may already exist."));
                    }
                }
                break;

            case "diff":
            case "status":
                var gitCmd = string.IsNullOrWhiteSpace(arg) ? cmd : $"{cmd} {arg}";
                await RunGitCommand(sessionName, session, gitCmd);
                return;

            case "mcp":
                HandleMcpCommand(session, arg);
                break;

            case "plugin":
            case "plugins":
                HandlePluginCommand(session, arg);
                break;

            case "reflect":
                await HandleReflectCommand(session, sessionName, arg);
                break;

            default:
                // Unknown command ‚Äî pass through to the SDK as a regular prompt
                _ = CopilotService.SendPromptAsync(sessionName, input);
                return;
        }

        if (session != null)
            session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private async Task RunGitCommand(string sessionName, AgentSessionInfo session, string gitArgs)
    {
        var cwd = GetShellCwd(sessionName);
        var isDiff = gitArgs.StartsWith("diff");
        session.History.Add(ChatMessage.UserMessage($"/{gitArgs}"));
        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);

        try
        {
            using var process = new System.Diagnostics.Process();
            process.StartInfo = new System.Diagnostics.ProcessStartInfo
            {
                FileName = "git",
                Arguments = $"--no-pager {gitArgs}",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                WorkingDirectory = cwd
            };
            process.Start();

            var stdout = await process.StandardOutput.ReadToEndAsync();
            var stderr = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();

            var output = !string.IsNullOrEmpty(stdout) ? stdout : stderr;
            if (string.IsNullOrWhiteSpace(output))
            {
                session.History.Add(ChatMessage.SystemMessage("(no changes)"));
            }
            else if (isDiff)
            {
                session.History.Add(ChatMessage.DiffMessage(output));
            }
            else
            {
                var wrapped = $"```\n{output.TrimEnd()}\n```";
                session.History.Add(ChatMessage.SystemMessage(wrapped));
            }
        }
        catch (Exception ex)
        {
            session.History.Add(ChatMessage.ErrorMessage($"git error: {ex.Message}"));
        }

        session.MessageCount = session.History.Count;
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private void HandleMcpCommand(AgentSessionInfo session, string arg)
    {
        var parts = arg.Split(' ', 2, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        var subcommand = parts.Length > 0 ? parts[0].ToLowerInvariant() : "";
        var target = parts.Length > 1 ? parts[1] : "";

        switch (subcommand)
        {
            case "enable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/mcp enable <server-name>`"));
                    return;
                }
                ToggleMcpServer(target, enabled: true);
                session.History.Add(ChatMessage.SystemMessage($"‚úÖ MCP server **{target}** enabled. Create a new session to pick up the change."));
                break;

            case "disable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/mcp disable <server-name>`"));
                    return;
                }
                ToggleMcpServer(target, enabled: false);
                session.History.Add(ChatMessage.SystemMessage($"üö´ MCP server **{target}** disabled. Create a new session to pick up the change."));
                break;

            default:
                session.History.Add(ChatMessage.SystemMessage(GetMcpServerInfo()));
                break;
        }
    }

    private void HandlePluginCommand(AgentSessionInfo session, string arg)
    {
        var parts = arg.Split(' ', 2, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        var subcommand = parts.Length > 0 ? parts[0].ToLowerInvariant() : "";
        var target = parts.Length > 1 ? parts[1] : "";

        switch (subcommand)
        {
            case "enable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/plugin enable <plugin-name>`"));
                    return;
                }
                TogglePlugin(target, enabled: true);
                session.History.Add(ChatMessage.SystemMessage($"‚úÖ Plugin **{target}** enabled. Create a new session to pick up the change."));
                break;

            case "disable":
                if (string.IsNullOrEmpty(target))
                {
                    session.History.Add(ChatMessage.ErrorMessage("Usage: `/plugin disable <plugin-name>`"));
                    return;
                }
                TogglePlugin(target, enabled: false);
                session.History.Add(ChatMessage.SystemMessage($"üö´ Plugin **{target}** disabled. Create a new session to pick up the change."));
                break;

            default:
                session.History.Add(ChatMessage.SystemMessage(GetPluginInfo()));
                break;
        }
    }

    private async Task HandleReflectCommand(AgentSessionInfo session, string sessionName, string arg)
    {
        var subParts = arg.Split(' ', 2, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        var sub = subParts.Length > 0 ? subParts[0].ToLowerInvariant() : "";

        if (sub == "stop")
        {
            CopilotService.StopReflectionCycle(sessionName);
            session.History.Add(ChatMessage.SystemMessage("üõë Reflection cycle stopped."));
            return;
        }

        if (sub == "pause")
        {
            if (session.ReflectionCycle is { IsActive: true, IsPaused: false })
            {
                session.ReflectionCycle.IsPaused = true;
                session.History.Add(ChatMessage.SystemMessage("‚è∏Ô∏è Reflection paused. Use `/reflect resume` to continue."));
            }
            else
            {
                session.History.Add(ChatMessage.ErrorMessage("No active reflection cycle to pause."));
            }
            return;
        }

        if (sub == "resume")
        {
            if (session.ReflectionCycle is { IsActive: true, IsPaused: true })
            {
                session.ReflectionCycle.IsPaused = false;
                session.ReflectionCycle.ResetStallDetection();
                session.History.Add(ChatMessage.SystemMessage("‚ñ∂Ô∏è Reflection resumed."));
                // Re-queue a follow-up to continue the cycle
                var followUp = session.ReflectionCycle.BuildFollowUpPrompt("");
                if (session.IsProcessing)
                {
                    session.MessageQueue.Add(followUp);
                }
                else
                {
                    // Dispatch immediately if session is idle
                    _ = CopilotService.SendPromptAsync(sessionName, followUp, skipHistoryMessage: true);
                }
            }
            else
            {
                session.History.Add(ChatMessage.ErrorMessage("No paused reflection cycle to resume."));
            }
            return;
        }

        if (sub == "status")
        {
            if (session.ReflectionCycle is { IsActive: true } rc)
            {
                var status = rc.IsPaused ? "‚è∏Ô∏è Paused" : "üîÑ Running";
                var evalInfo = !string.IsNullOrEmpty(rc.EvaluatorSessionName) ? "independent evaluator" : "self-evaluation";
                var feedback = !string.IsNullOrEmpty(rc.EvaluatorFeedback) ? $"\n**Last feedback:** {rc.EvaluatorFeedback}" : "";
                session.History.Add(ChatMessage.SystemMessage(
                    $"{status} ‚Äî **{rc.Goal}**\n" +
                    $"Iteration {rc.CurrentIteration}/{rc.MaxIterations} ¬∑ {evalInfo}{feedback}"));
            }
            else
            {
                session.History.Add(ChatMessage.SystemMessage("No active reflection cycle."));
            }
            return;
        }

        if (string.IsNullOrWhiteSpace(arg) || sub == "help")
        {
            session.History.Add(ChatMessage.SystemMessage(
                "üîÑ **Reflection Cycles** ‚Äî Iterative goal-driven refinement\n\n" +
                "**Usage:**\n" +
                "```\n" +
                "/reflect <goal>            Start a cycle (default 5 iterations)\n" +
                "/reflect <goal> --max N    Set max iterations (default 5)\n" +
                "/reflect stop              Cancel active cycle\n" +
                "/reflect pause             Pause without cancelling\n" +
                "/reflect resume            Resume paused cycle\n" +
                "/reflect status            Show current cycle progress\n" +
                "/reflect help              Show this help\n" +
                "```\n\n" +
                "**How it works:**\n" +
                "1. You set a goal ‚Üí the worker starts iterating\n" +
                "2. After each response, an **independent evaluator** judges the result\n" +
                "3. If the evaluator says FAIL, its feedback is sent back to the worker\n" +
                "4. Cycle ends when: ‚úÖ evaluator says PASS | ‚ö†Ô∏è stalled | ‚è±Ô∏è max iterations\n\n" +
                "**Examples:**\n" +
                "```\n" +
                "/reflect write a haiku about rain --max 4\n" +
                "/reflect fix the login bug and add tests --max 8\n" +
                "/reflect refactor this function for readability\n" +
                "```\n\n" +
                "**Tips:**\n" +
                "- Send messages during a cycle to steer the worker\n" +
                "- Click the üîÑ pill in the header to stop\n" +
                "- The evaluator is strict early on, lenient on the final iteration"));
            return;
        }

        // Parse --max N from the goal text (accept em-dash ‚Äî which macOS auto-substitutes for --)
        int maxIterations = 5;
        var goal = arg;
        var maxMatch = System.Text.RegularExpressions.Regex.Match(arg, @"(?:--|‚Äî|\u2014)max\s+(\d+)");
        if (maxMatch.Success)
        {
            if (int.TryParse(maxMatch.Groups[1].Value, out var parsed) && parsed > 0)
                maxIterations = parsed;
            goal = arg.Remove(maxMatch.Index, maxMatch.Length).Trim();
        }

        if (string.IsNullOrWhiteSpace(goal))
        {
            session.History.Add(ChatMessage.ErrorMessage("Please provide a goal for the reflection cycle."));
            return;
        }

        await CopilotService.StartReflectionCycleAsync(sessionName, goal, maxIterations);
        session.History.Add(ChatMessage.SystemMessage($"üîÑ Reflection cycle started ‚Äî **{goal}** (max {maxIterations} iterations)"));
        if (session.IsProcessing)
        {
            CopilotService.EnqueueMessage(sessionName, goal);
            session.History.Add(ChatMessage.SystemMessage("‚è≥ Current turn is still running ‚Äî queued reflection goal to run next."));
            return;
        }

        // Send the goal as the initial prompt to kick off the first iteration
        _ = CopilotService.SendPromptAsync(sessionName, goal);
    }

    private void ToggleMcpServer(string name, bool enabled)
    {
        var settings = ConnectionSettings.Load();
        if (enabled)
            settings.DisabledMcpServers.Remove(name);
        else if (!settings.DisabledMcpServers.Contains(name))
            settings.DisabledMcpServers.Add(name);
        settings.Save();
    }

    private void TogglePlugin(string name, bool enabled)
    {
        var settings = ConnectionSettings.Load();
        if (enabled)
            settings.DisabledPlugins.Remove(name);
        else if (!settings.DisabledPlugins.Contains(name))
            settings.DisabledPlugins.Add(name);
        settings.Save();
    }

    private string GetMcpServerInfo()
    {
        var sb = new System.Text.StringBuilder();
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var copilotDir = Path.Combine(home, ".copilot");
        var servers = new List<(string name, string command, string[] args)>();

        // Read ~/.copilot/mcp-servers.json (simple format)
        try
        {
            var path = Path.Combine(copilotDir, "mcp-servers.json");
            if (File.Exists(path))
            {
                var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(path));
                foreach (var prop in doc.RootElement.EnumerateObject())
                {
                    var command = prop.Value.TryGetProperty("command", out var c) ? c.GetString() ?? "" : "";
                    var args = prop.Value.TryGetProperty("args", out var a)
                        ? a.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                        : Array.Empty<string>();
                    servers.Add((prop.Name, command, args));
                }
            }
        }
        catch { }

        // Read ~/.copilot/mcp-config.json (wrapped format)
        try
        {
            var path = Path.Combine(copilotDir, "mcp-config.json");
            if (File.Exists(path))
            {
                var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(path));
                if (doc.RootElement.TryGetProperty("mcpServers", out var mcpServers))
                {
                    foreach (var prop in mcpServers.EnumerateObject())
                    {
                        if (servers.Any(s => s.name == prop.Name)) continue;
                        var command = prop.Value.TryGetProperty("command", out var c) ? c.GetString() ?? "" : "";
                        var args = prop.Value.TryGetProperty("args", out var a)
                            ? a.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                            : Array.Empty<string>();
                        servers.Add((prop.Name, command, args));
                    }
                }
            }
        }
        catch { }

        // Read plugin .mcp.json files
        try
        {
            var pluginsDir = Path.Combine(copilotDir, "installed-plugins");
            if (Directory.Exists(pluginsDir))
            {
                foreach (var marketDir in Directory.GetDirectories(pluginsDir))
                {
                    foreach (var pluginDir in Directory.GetDirectories(marketDir))
                    {
                        var mcpFile = Path.Combine(pluginDir, ".mcp.json");
                        if (!File.Exists(mcpFile)) continue;
                        try
                        {
                            var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(mcpFile));
                            if (doc.RootElement.TryGetProperty("mcpServers", out var mcpServers))
                            {
                                foreach (var prop in mcpServers.EnumerateObject())
                                {
                                    if (servers.Any(s => s.name == prop.Name)) continue;
                                    var command = prop.Value.TryGetProperty("command", out var c) ? c.GetString() ?? "" : "";
                                    var args = prop.Value.TryGetProperty("args", out var a)
                                        ? a.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                                        : Array.Empty<string>();
                                    servers.Add((prop.Name, command, args));
                                }
                            }
                        }
                        catch { }
                    }
                }
            }
        }
        catch { }

        if (servers.Count == 0)
            return "**No MCP servers configured.**\n\nAdd servers to `~/.copilot/mcp-servers.json` or `~/.copilot/mcp-config.json`.";

        var settings = ConnectionSettings.Load();
        var disabledCount = servers.Count(s => settings.DisabledMcpServers.Contains(s.name));
        var enabledCount = servers.Count - disabledCount;
        sb.AppendLine($"**{servers.Count} MCP server{(servers.Count != 1 ? "s" : "")}** ({enabledCount} enabled):\n");
        foreach (var (name, command, args) in servers)
        {
            var lastArg = args.LastOrDefault() ?? "";
            var script = Path.GetFileName(lastArg);
            var display = !string.IsNullOrEmpty(script) ? $"`{command} {script}`" : $"`{command}`";
            var isDisabled = settings.DisabledMcpServers.Contains(name);
            var status = isDisabled ? "üö´" : "‚úÖ";
            sb.AppendLine($"- {status} **{name}** ‚Äî {display}");
        }
        sb.AppendLine();
        sb.AppendLine("Use `/mcp enable <name>` or `/mcp disable <name>` to toggle.");

        return sb.ToString().TrimEnd();
    }

    private async Task StopSession(string sessionName)
    {
        await CopilotService.AbortSessionAsync(sessionName);
    }

    private IReadOnlyList<FiestaLinkedWorker> GetFiestaWorkersForSession(string sessionName)
    {
        var linked = FiestaService.LinkedWorkers;
        var state = FiestaService.GetFiestaState(sessionName);
        if (state == null || state.WorkerIds.Count == 0)
            return linked;

        var selected = linked
            .Where(w => state.WorkerIds.Contains(w.Id, StringComparer.Ordinal))
            .ToList();
        return selected.Count > 0 ? selected : linked;
    }

    private async Task StartFiestaForSession(string sessionName, FiestaStartRequest request)
    {
        var workerIds = request.WorkerIds.Where(id => !string.IsNullOrWhiteSpace(id)).Distinct(StringComparer.Ordinal).ToList();
        if (workerIds.Count == 0)
        {
            var noWorkerSession = CopilotService.GetSession(sessionName);
            if (noWorkerSession != null)
            {
                noWorkerSession.History.Add(ChatMessage.ErrorMessage("Select at least one worker to start Fiesta."));
                noWorkerSession.MessageCount = noWorkerSession.History.Count;
            }
            _needsScrollToBottom = true;
            await InvokeAsync(SafeRefreshAsync);
            return;
        }

        var started = FiestaService.StartFiesta(sessionName, request.FiestaName, workerIds);
        if (started)
        {
            var session = CopilotService.GetSession(sessionName);
            if (session != null)
            {
                var fiestaName = string.IsNullOrWhiteSpace(request.FiestaName) ? "Fiesta" : request.FiestaName.Trim();
                var workers = FiestaService.LinkedWorkers
                    .Where(w => workerIds.Contains(w.Id, StringComparer.Ordinal))
                    .OrderBy(w => w.Name)
                    .Select(w => $"@{w.Name}")
                    .ToList();
                var workerText = workers.Count > 0 ? string.Join(", ", workers) : "(none)";
                session.History.Add(ChatMessage.SystemMessage(
                    $"üéâ Fiesta **{fiestaName}** started with {workerText}. Mention workers to dispatch work."));
                session.MessageCount = session.History.Count;
            }
        }
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private async Task StopFiestaForSession(string sessionName)
    {
        FiestaService.StopFiesta(sessionName);
        var session = CopilotService.GetSession(sessionName);
        if (session != null)
        {
            session.History.Add(ChatMessage.SystemMessage("Fiesta stopped for this session."));
            session.MessageCount = session.History.Count;
        }
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private async Task StopReflectionForSession(string sessionName)
    {
        CopilotService.StopReflectionCycle(sessionName);
        var session = CopilotService.GetSession(sessionName);
        if (session != null)
        {
            var goal = session.ReflectionCycle?.Goal ?? "unknown";
            session.History.Add(ChatMessage.SystemMessage($"üõë Reflection cycle stopped ‚Äî **{goal}**"));
            session.MessageCount = session.History.Count;
        }
        _needsScrollToBottom = true;
        await InvokeAsync(SafeRefreshAsync);
    }

    private void HandleFiestaStateChanged()
    {
        ScheduleRender();
    }

    private void HandleFiestaTaskUpdate(string sessionName, FiestaTaskUpdate update)
    {
        _ = InvokeAsync(async () =>
        {
            var session = CopilotService.GetSession(sessionName);
            if (session == null)
                return;

            var key = $"{sessionName}:{update.TaskId}";
            if (!_fiestaStreamingMessages.TryGetValue(key, out var liveMessage))
            {
                liveMessage = ChatMessage.SystemMessage($"üéâ @{update.WorkerName}: ");
                session.History.Add(liveMessage);
                _fiestaStreamingMessages[key] = liveMessage;
            }

            switch (update.Kind)
            {
                case FiestaTaskUpdateKind.Started:
                    liveMessage.Content = $"üéâ @{update.WorkerName}: {update.Content}";
                    break;
                case FiestaTaskUpdateKind.Delta:
                    liveMessage.Content += update.Content;
                    break;
                case FiestaTaskUpdateKind.Completed:
                    if (!string.IsNullOrWhiteSpace(update.Content))
                        liveMessage.Content += $"\n\n‚úÖ {update.Content}";
                    else
                        liveMessage.Content += "\n\n‚úÖ Completed.";
                    _fiestaStreamingMessages.Remove(key);
                    break;
                case FiestaTaskUpdateKind.Error:
                    liveMessage.Content += $"\n\n‚ùå {update.Content}";
                    _fiestaStreamingMessages.Remove(key);
                    break;
                default:
                    if (!string.IsNullOrWhiteSpace(update.Content))
                        liveMessage.Content += $"\n{update.Content}";
                    break;
            }

            session.MessageCount = session.History.Count;
            _needsScrollToBottom = true;
            await SafeRefreshAsync();
        });
    }

    private string GetPluginInfo()
    {
        var sb = new System.Text.StringBuilder();
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var pluginsDir = Path.Combine(home, ".copilot", "installed-plugins");

        if (!Directory.Exists(pluginsDir))
            return "**No plugins installed.**\n\nInstall plugins with `copilot plugin install <source>`.";

        var plugins = new List<(string name, string marketplace, string type, string detail)>();

        foreach (var marketDir in Directory.GetDirectories(pluginsDir))
        {
            var marketplace = Path.GetFileName(marketDir);
            foreach (var pluginDir in Directory.GetDirectories(marketDir))
            {
                var pluginName = Path.GetFileName(pluginDir);
                var type = "plugin";
                var detail = "";

                // Check for MCP config
                var mcpFile = Path.Combine(pluginDir, ".mcp.json");
                if (File.Exists(mcpFile))
                {
                    type = "mcp";
                    try
                    {
                        var doc = System.Text.Json.JsonDocument.Parse(File.ReadAllText(mcpFile));
                        if (doc.RootElement.TryGetProperty("mcpServers", out var servers))
                        {
                            var names = servers.EnumerateObject().Select(p => p.Name).ToList();
                            detail = string.Join(", ", names);
                        }
                    }
                    catch { }
                }

                // Check for skills
                var skillDirs = Directory.GetDirectories(pluginDir, "skills", SearchOption.AllDirectories).FirstOrDefault();
                if (skillDirs != null)
                {
                    var skills = Directory.GetDirectories(skillDirs).Select(Path.GetFileName).ToList();
                    if (skills.Count > 0)
                    {
                        type = type == "mcp" ? "mcp+skills" : "skills";
                        detail = string.IsNullOrEmpty(detail)
                            ? string.Join(", ", skills!)
                            : $"{detail} | skills: {string.Join(", ", skills!)}";
                    }
                }

                plugins.Add((pluginName, marketplace, type, detail));
            }
        }

        if (plugins.Count == 0)
            return "**No plugins installed.**\n\nInstall plugins with `copilot plugin install <source>`.";

        var settings = ConnectionSettings.Load();
        var disabledCount = plugins.Count(p => settings.DisabledPlugins.Contains(p.name));
        var enabledCount = plugins.Count - disabledCount;
        sb.AppendLine($"**{plugins.Count} plugin{(plugins.Count != 1 ? "s" : "")} installed** ({enabledCount} enabled):\n");
        foreach (var (name, marketplace, type, detail) in plugins)
        {
            var badge = type switch { "mcp" => "üîå", "skills" => "üõ†Ô∏è", "mcp+skills" => "üîåüõ†Ô∏è", _ => "üì¶" };
            var isDisabled = settings.DisabledPlugins.Contains(name);
            var status = isDisabled ? "üö´" : "‚úÖ";
            var detailStr = !string.IsNullOrEmpty(detail) ? $" ‚Äî {detail}" : "";
            sb.AppendLine($"- {status} {badge} **{name}** `{marketplace}`{detailStr}");
        }
        sb.AppendLine();
        sb.AppendLine("Use `/plugin enable <name>` or `/plugin disable <name>` to toggle.");

        return sb.ToString().TrimEnd();
    }

    [JSInvokable]
    public async Task JsInterruptSession()
    {
        var target = expandedSession ?? CopilotService.ActiveSessionName;
        if (target == null) return;
        var session = sessions.FirstOrDefault(s => s.Name == target);
        if (session?.IsProcessing == true)
            await StopSession(target);
    }

    private async Task TriggerAttach(string sessionName)
    {
        var fileId = $"file-{sessionName.Replace(" ", "-")}";
        await JS.InvokeVoidAsync("clickElement", fileId);
    }

    private async Task ExpandSession(string sessionName)
    {
        // Fire-and-forget draft save ‚Äî don't block the switch on JS interop
        _ = SaveDraftsAndCursor();
        expandedSession = sessionName;
        _needsScrollToBottom = true;
        _sessionSwitching = true; // tells RefreshState to skip redundant work
        // Suppress Blazor renders for 300ms to let browser paint the CSS toggle uninterrupted
        Interlocked.Exchange(ref _switchCooldownUntil, Environment.TickCount64 + 300);
        // CSS visibility already toggled by JS capture-phase click handler
        CopilotService.SwitchSession(sessionName);
        var session = CopilotService.GetSession(sessionName);
        if (session != null) session.LastReadMessageCount = session.History.Count;
        // Defer UI state persistence to avoid blocking on file I/O
        CopilotService.SaveUiState("/dashboard", activeSession: sessionName, expandedSession: sessionName, expandedGrid: !isCompactGrid);
    }

    private async Task CollapseExpanded()
    {
        await SaveDraftsAndCursor();
        expandedSession = null;
        _needsScrollToBottom = true;
        _lastActiveSession = null;
        _explicitlyCollapsed = true;
        CopilotService.SetActiveSession(null);
        CopilotService.SaveUiState("/dashboard", activeSession: null, expandedSession: null, expandedGrid: !isCompactGrid);
    }

    private void ToggleGridDensity()
    {
        isCompactGrid = !isCompactGrid;
        CopilotService.SaveUiState("/dashboard", expandedGrid: !isCompactGrid, expandedSession: expandedSession);
    }

    private void ToggleCardMenu(string sessionName)
    {
        cardMenuSession = cardMenuSession == sessionName ? null : sessionName;
    }

    private void StartCardRename(string sessionName)
    {
        cardRenamingSession = sessionName;
        _ = FocusCardRenameInput();
    }

    private async Task FocusCardRenameInput()
    {
        await Task.Yield();
        StateHasChanged();
        await Task.Yield();
        await JS.InvokeVoidAsync("eval", @"
            var el = document.getElementById('cardRenameInput');
            if (el) { el.focus(); el.select(); }
        ");
    }

    private async Task CommitCardRename()
    {
        if (cardRenamingSession == null) return;
        var oldName = cardRenamingSession;
        cardRenamingSession = null;

        var newName = await JS.InvokeAsync<string>("getElementValue", "cardRenameInput");
        if (!string.IsNullOrWhiteSpace(newName) && newName.Trim() != oldName)
        {
            CopilotService.RenameSession(oldName, newName.Trim());
        }
    }

    private async Task HandleCardRenameKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CommitCardRename();
        else if (e.Key == "Escape") cardRenamingSession = null;
    }

    private void OnSortModeChanged(ChangeEventArgs e)
    {
        if (e.Value is string val && Enum.TryParse<SessionSortMode>(val, out var mode))
        {
            CopilotService.SetSortMode(mode);
        }
    }

    private async Task CommitDashGroup()
    {
        var name = await JS.InvokeAsync<string>("getElementValue", "dashNewGroupInput");
        isAddingDashGroup = false;
        if (!string.IsNullOrWhiteSpace(name))
        {
            CopilotService.CreateGroup(name.Trim());
        }
    }

    private async Task HandleDashGroupKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CommitDashGroup();
        else if (e.Key == "Escape") isAddingDashGroup = false;
    }

    private async Task CommitMultiAgentGroup()
    {
        var name = await JS.InvokeAsync<string>("getElementValue", "dashNewMultiAgentGroupInput");
        isAddingMultiAgentGroup = false;
        if (!string.IsNullOrWhiteSpace(name))
        {
            CopilotService.CreateMultiAgentGroup(name.Trim());
        }
    }

    private async Task HandleMultiAgentGroupKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CommitMultiAgentGroup();
        else if (e.Key == "Escape") isAddingMultiAgentGroup = false;
    }

    private void OnMultiAgentModeChanged(string groupId, ChangeEventArgs e)
    {
        if (e.Value is string val && Enum.TryParse<MultiAgentMode>(val, out var mode))
        {
            CopilotService.SetMultiAgentMode(groupId, mode);
        }
    }

    private static string GetInputPlaceholder(MultiAgentMode mode) => mode switch
    {
        MultiAgentMode.Broadcast => "Send to all agents...",
        MultiAgentMode.Sequential => "Send to agents in sequence...",
        MultiAgentMode.Orchestrator => "Describe task for orchestrator...",
        MultiAgentMode.OrchestratorReflect => "Describe goal for reflection cycle...",
        _ => "Enter prompt..."
    };

    private void AutoStartReflectionIfNeeded(string groupId, string prompt)
    {
        var group = CopilotService.Organization.Groups.FirstOrDefault(g => g.Id == groupId);
        if (group?.OrchestratorMode == MultiAgentMode.OrchestratorReflect)
        {
            var maxIter = GetMaxIterations(groupId);
            CopilotService.StartGroupReflection(groupId, prompt, maxIter);
        }
    }

    private Dictionary<string, int> _groupMaxIterations = new();

    private int GetMaxIterations(string groupId)
    {
        if (_groupMaxIterations.TryGetValue(groupId, out var val)) return val;
        return 5;
    }

    private void SetMaxIterations(string groupId, ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var val) && val >= 1)
            _groupMaxIterations[groupId] = val;
    }

    private async Task SendToMultiAgentGroup(string groupId)
    {
        var inputId = $"ma-input-{groupId}";
        var prompt = await JS.InvokeAsync<string>("getElementValue", inputId);
        if (string.IsNullOrWhiteSpace(prompt)) return;

        await JS.InvokeVoidAsync("clearElementValue", inputId);
        AutoStartReflectionIfNeeded(groupId, prompt.Trim());

        try
        {
            _ = CopilotService.SendToMultiAgentGroupAsync(groupId, prompt.Trim()).ContinueWith(t =>
            {
                if (t.IsFaulted)
                {
                    InvokeAsync(() =>
                    {
                        Console.WriteLine($"Error sending to multi-agent group: {t.Exception?.InnerException?.Message}");
                    });
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending to multi-agent group: {ex.Message}");
        }
    }

    private async Task SendToExpandedMultiAgentGroup(string groupId)
    {
        var inputId = $"ma-input-expanded-{groupId}";
        var prompt = await JS.InvokeAsync<string>("getElementValue", inputId);
        if (string.IsNullOrWhiteSpace(prompt)) return;

        await JS.InvokeVoidAsync("clearElementValue", inputId);
        AutoStartReflectionIfNeeded(groupId, prompt.Trim());

        try
        {
            _ = CopilotService.SendToMultiAgentGroupAsync(groupId, prompt.Trim()).ContinueWith(t =>
            {
                if (t.IsFaulted)
                {
                    InvokeAsync(() =>
                    {
                        Console.WriteLine($"Error sending to multi-agent group: {t.Exception?.InnerException?.Message}");
                    });
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending to multi-agent group: {ex.Message}");
        }
    }

    private async Task SaveDraftsAndCursor()
    {
        var json = await JS.InvokeAsync<string>("eval", @"
            (function() {
                var focused = document.activeElement;
                var sel = '.card-input input, .card-input textarea, .input-row textarea';
                var focusId = (focused && focused.id && focused.matches(sel)) ? focused.id : null;
                var selStart = focusId ? (focused.selectionStart || 0) : 0;
                var selEnd = focusId ? (focused.selectionEnd || 0) : 0;
                var items = Array.from(document.querySelectorAll(sel))
                    .filter(el => el.id)
                    .map(el => ({ id: el.id, value: el.value || '' }));
                return JSON.stringify({ focusId: focusId, selStart: selStart, selEnd: selEnd, items: items });
            })()
        ");
        if (!string.IsNullOrEmpty(json))
        {
            try
            {
                var state = System.Text.Json.JsonSerializer.Deserialize<DraftState>(json);
                if (state != null)
                {
                    _focusedInputId = state.FocusId;
                    _cursorStart = state.SelStart;
                    _cursorEnd = state.SelEnd;
                    draftBySession.Clear();
                    foreach (var item in state.Items ?? [])
                    {
                        var name = item.Id.Replace("input-", "").Replace("-", " ");
                        draftBySession[name] = item.Value;
                    }
                }
            }
            catch { }
        }
    }

    private record DraftItem(
        [property: System.Text.Json.Serialization.JsonPropertyName("id")] string Id,
        [property: System.Text.Json.Serialization.JsonPropertyName("value")] string Value);

    private record DraftState(
        [property: System.Text.Json.Serialization.JsonPropertyName("focusId")] string? FocusId,
        [property: System.Text.Json.Serialization.JsonPropertyName("selStart")] int SelStart,
        [property: System.Text.Json.Serialization.JsonPropertyName("selEnd")] int SelEnd,
        [property: System.Text.Json.Serialization.JsonPropertyName("items")] List<DraftItem>? Items);

    [JSInvokable]
    public async Task JsImagePasted(string base64, string fileName, string extension, string inputId)
    {
        var rawName = inputId.Replace("input-", "");
        var sessionName = sessions.FirstOrDefault(s => s.Name.Replace(" ", "-") == rawName)?.Name;
        if (string.IsNullOrEmpty(sessionName)) return;

        try
        {
            var tempDir = Path.Combine(Path.GetTempPath(), "PolyPilot-images");
            Directory.CreateDirectory(tempDir);
            var tempPath = Path.Combine(tempDir, $"{Guid.NewGuid()}.{extension}");
            var bytes = Convert.FromBase64String(base64);
            await File.WriteAllBytesAsync(tempPath, bytes);

            var mime = extension.ToLowerInvariant() switch
            {
                "png" => "image/png",
                "jpg" or "jpeg" => "image/jpeg",
                "gif" => "image/gif",
                "webp" => "image/webp",
                "svg" => "image/svg+xml",
                "bmp" => "image/bmp",
                _ => "image/png"
            };
            var dataUri = $"data:{mime};base64,{base64}";

            if (!pendingImagesBySession.ContainsKey(sessionName))
                pendingImagesBySession[sessionName] = new();
            pendingImagesBySession[sessionName].Add(new PendingImage(tempPath, fileName, dataUri));

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving pasted image: {ex.Message}");
        }
    }

    private void RemovePendingImage(string sessionName, int index)
    {
        if (pendingImagesBySession.TryGetValue(sessionName, out var images) && index >= 0 && index < images.Count)
        {
            try { File.Delete(images[index].TempPath); } catch { }
            images.RemoveAt(index);
            if (images.Count == 0) pendingImagesBySession.Remove(sessionName);
        }
    }

    private static string TruncateFileName(string name, int maxLen)
    {
        if (name.Length <= maxLen) return name;
        var ext = Path.GetExtension(name);
        var stem = Path.GetFileNameWithoutExtension(name);
        var maxStem = maxLen - ext.Length - 1;
        if (maxStem < 3) return name[..maxLen];
        return stem[..maxStem] + "‚Ä¶" + ext;
    }

    private async Task CloseSession(string sessionName)
    {
        await CopilotService.CloseSessionAsync(sessionName);
        if (expandedSession == sessionName)
        {
            expandedSession = null;
            CopilotService.SaveUiState("/dashboard", activeSession: null, expandedSession: null, expandedGrid: !isCompactGrid);
        }
    }

    private void ClearQueue(string sessionName)
    {
        CopilotService.ClearQueue(sessionName);
    }

    private async Task GoToSession(string sessionName)
    {
        CopilotService.SwitchSession(sessionName);
        await SaveDraftsAndCursor();
        expandedSession = sessionName;
        _needsScrollToBottom = true;
        _focusedInputId = $"input-{sessionName.Replace(" ", "-")}";
        _cursorStart = 0;
        _cursorEnd = 0;
    }

    private static string ShortenPath(string path)
    {
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(home) && path.StartsWith(home))
            return "~" + path[home.Length..];
        var parts = path.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        return parts.Length > 3 ? string.Join("/", parts[^3..]) : path;
    }

    private void OpenSessionFolder(string sessionId)
    {
        var path = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            ".copilot", "session-state", sessionId);
        if (Directory.Exists(path))
        {
#if MACCATALYST
            System.Diagnostics.Process.Start("open", path);
#elif WINDOWS
            System.Diagnostics.Process.Start("explorer.exe", path);
#endif
        }
    }

    [JSInvokable]
    public async Task JsExpandSession(string sessionName)
    {
        await SaveDraftsAndCursor();
        expandedSession = sessionName;
        CopilotService.SwitchSession(sessionName);
        var s = CopilotService.GetSession(sessionName);
        if (s != null) s.LastReadMessageCount = s.History.Count;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task JsCollapseToGrid()
    {
        await SaveDraftsAndCursor();
        expandedSession = null;
        _lastActiveSession = null;
        _explicitlyCollapsed = true;
        CopilotService.SetActiveSession(null);
        CopilotService.SaveUiState("/dashboard", activeSession: null, expandedSession: null, expandedGrid: !isCompactGrid);
        StateHasChanged();
    }

    [JSInvokable]
    public async Task JsCycleExpandedSession(bool reverse)
    {
        if (expandedSession == null || sessions.Count < 2) return;
        await SaveDraftsAndCursor();
        var idx = sessions.FindIndex(s => s.Name == expandedSession);
        if (idx < 0) idx = 0;
        idx = reverse ? (idx - 1 + sessions.Count) % sessions.Count : (idx + 1) % sessions.Count;
        expandedSession = sessions[idx].Name;
        CopilotService.SwitchSession(expandedSession);
        var cs = CopilotService.GetSession(expandedSession);
        if (cs != null) cs.LastReadMessageCount = cs.History.Count;
        _focusedInputId = $"input-{expandedSession.Replace(" ", "-")}";
        _cursorStart = 0;
        _cursorEnd = 0;
        StateHasChanged();
    }

    [JSInvokable]
    public void JsSelectSession(string sessionName)
    {
        _lastActiveSession = sessionName;
        CopilotService.SwitchSession(sessionName);
    }

    [JSInvokable]
    public async Task JsNavigateHistory(string sessionName, bool up)
    {
        if (!commandHistoryBySession.TryGetValue(sessionName, out var history) || history.Count == 0)
            return;

        if (!historyIndexBySession.ContainsKey(sessionName))
            historyIndexBySession[sessionName] = history.Count;

        var idx = historyIndexBySession[sessionName];
        if (up)
            idx = Math.Max(0, idx - 1);
        else
            idx = Math.Min(history.Count, idx + 1);

        historyIndexBySession[sessionName] = idx;
        var inputId = $"input-{sessionName.Replace(" ", "-")}";
        var text = idx < history.Count ? history[idx] : "";
        await JS.InvokeVoidAsync("eval", $"(function(){{ var el = document.getElementById('{inputId}'); if(el){{ el.value = {System.Text.Json.JsonSerializer.Serialize(text)}; el.setSelectionRange(el.value.length, el.value.length); }} }})()");
    }

    [JSInvokable]
    public async Task JsSwitchToSessionByIndex(int index)
    {
        // Use organized sessions to match sidebar badge ordering
        var organized = CopilotService.GetOrganizedSessions();
        var sessionIndex = 0;
        foreach (var (group, groupSessions) in organized)
        {
            if (group.IsCollapsed && CopilotService.HasMultipleGroups) continue;
            foreach (var session in groupSessions)
            {
                sessionIndex++;
                if (sessionIndex == index)
                {
                    if (expandedSession != null)
                    {
                        await SaveDraftsAndCursor();
                        expandedSession = session.Name;
                        _focusedInputId = $"input-{session.Name.Replace(" ", "-")}";
                    }
                    CopilotService.SwitchSession(session.Name);
                    StateHasChanged();
                    return;
                }
            }
        }
    }

    private const int DefaultMessageWindow = 25;
    private const int DefaultCardMessageWindow = 10;
    private Dictionary<string, int> cardMessageCounts = new();

    private List<ChatMessage> GetWindowedMessages(string sessionName, IReadOnlyList<ChatMessage> history)
    {
        var limit = expandedMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultMessageWindow;
        try
        {
            if (history.Count <= limit) return history.ToList();
            return history.Skip(history.Count - limit).ToList();
        }
        catch (InvalidOperationException)
        {
            return history.ToArray().TakeLast(limit).ToList();
        }
    }

    private List<ChatMessage> GetCardMessages(string sessionName, IReadOnlyList<ChatMessage> history)
    {
        var limit = cardMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultCardMessageWindow;
        try
        {
            if (history.Count <= limit) return history.ToList();
            return history.Skip(history.Count - limit).ToList();
        }
        catch (InvalidOperationException)
        {
            return history.ToArray().TakeLast(limit).ToList();
        }
    }

    private void LoadMoreCardMessages(string sessionName)
    {
        var current = cardMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultCardMessageWindow;
        cardMessageCounts[sessionName] = current + 15;
    }

    private void LoadMoreExpandedMessages(string sessionName)
    {
        var current = expandedMessageCounts.TryGetValue(sessionName, out var c) ? c : DefaultMessageWindow;
        expandedMessageCounts[sessionName] = current + 25;
    }

    // === Model, plan mode, font, token helpers ===

    private static readonly string[] _fallbackModels = new[]
    {
        "claude-opus-4.6", "claude-opus-4.6-fast", "claude-opus-4.5", "claude-sonnet-4.5", "claude-sonnet-4", "claude-haiku-4.5",
        "gpt-5.2", "gpt-5.2-codex", "gpt-5.1", "gpt-5.1-codex", "gpt-5.1-codex-max", "gpt-5.1-codex-mini", "gpt-5", "gpt-5-mini", "gpt-4.1",
        "gemini-3-pro-preview",
    };
    private IReadOnlyList<string> availableModels =>
        CopilotService.AvailableModels.Count > 0 ? CopilotService.AvailableModels : _fallbackModels;

    private string GetSessionModel(AgentSessionInfo session)
    {
        // Priority: 1) Usage info (TRUTH) - what the backend is actually using
        if (usageBySession.TryGetValue(session.Name, out var u) && !string.IsNullOrEmpty(u.Model))
            return u.Model;

        // Priority: 2) Session model property (initial configuration)
        if (!string.IsNullOrEmpty(session.Model) && session.Model != "resumed")
            return session.Model;

        return availableModels[0];
    }

    private string GetExpandedModel(AgentSessionInfo session)
    {
        return GetSessionModel(session);
    }

    private async Task SetExpandedModel(AgentSessionInfo session, string? model)
    {
        if (string.IsNullOrEmpty(model)) return;

        // If the session has no history, recreate it to "switch" the model effectively
        if (session.History.Count == 0)
        {
            await CopilotService.RecreateSessionAsync(session.Name, model);
            sessions = CopilotService.GetAllSessions().ToList();
            await InvokeAsync(SafeRefreshAsync);
            return;
        }

        // For active sessions with history, resume with the new model
        var success = await CopilotService.ChangeModelAsync(session.Name, model);
        if (success)
        {
            sessions = CopilotService.GetAllSessions().ToList();
            await InvokeAsync(SafeRefreshAsync);
        }
    }

    private static bool IsValidInputMode(string mode) =>
        mode is "chat" or "plan" or "autopilot";

    private string GetInputMode(string sessionName) =>
        inputModeBySession.TryGetValue(sessionName, out var mode) && IsValidInputMode(mode)
            ? mode
            : "chat";

    private void SetInputMode(string sessionName, string mode)
    {
        inputModeBySession[sessionName] = IsValidInputMode(mode) ? mode : "chat";
        CopilotService.SaveUiState("/dashboard", inputModes: inputModeBySession);
    }

    private void IncreaseFontSize() { if (fontSize < 24) { fontSize += 2; ApplyFontSize(); ShowFontBubble(); } }
    private void DecreaseFontSize() { if (fontSize > 12) { fontSize -= 2; ApplyFontSize(); ShowFontBubble(); } }
    private void ResetFontSize() { fontSize = 20; ApplyFontSize(); ShowFontBubble(); }
    private void HandleFontSizeChange(int delta)
    {
        if (delta == 0) ResetFontSize();
        else if (delta > 0) IncreaseFontSize();
        else DecreaseFontSize();
    }

    [JSInvokable]
    public void JsChangeFontSize(int delta)
    {
        HandleFontSizeChange(delta);
        InvokeAsync(StateHasChanged);
    }

    private bool _showFontBubble;
    private CancellationTokenSource? _fontBubbleCts;

    private void ShowFontBubble()
    {
        _fontBubbleCts?.Cancel();
        _showFontBubble = true;
        _fontBubbleCts = new CancellationTokenSource();
        var cts = _fontBubbleCts;
        _ = Task.Delay(1500, cts.Token).ContinueWith(_ =>
        {
            if (!cts.Token.IsCancellationRequested)
            {
                _showFontBubble = false;
                InvokeAsync(StateHasChanged);
            }
        }, TaskScheduler.Default);
    }
    private void ApplyFontSize()
    {
        _ = JS.InvokeVoidAsync("setAppFontSize", fontSize);
        CopilotService.SaveUiState("/dashboard", fontSize: fontSize);
    }

    private static string FormatTokenCount(int count) =>
        count >= 1000 ? $"{count / 1000}k" : count.ToString();

    private static string Truncate(string s, int max) =>
        s.Length <= max ? s : s[..max] + "‚Ä¶";

    private void RemoveQueuedMessage(string sessionName, int index)
    {
        var session = sessions.FirstOrDefault(s => s.Name == sessionName);
        if (session != null && index >= 0 && index < session.MessageQueue.Count)
            session.MessageQueue.RemoveAt(index);
    }

    private async Task CopyToClipboard(string text)
    {
        try { await JS.InvokeVoidAsync("navigator.clipboard.writeText", text); } catch { }
    }

    private bool _disposed;

    // Tuple-based adapter methods for EventCallbacks (avoids lambda allocations per render)
    private Task HandleSend(string sessionName) => SendFromCard(sessionName, null);
    private Task StartFiestaForSession((string SessionName, FiestaStartRequest Request) args) => StartFiestaForSession(args.SessionName, args.Request);
    private void RemoveQueuedMessage((string SessionName, int Index) args) => RemoveQueuedMessage(args.SessionName, args.Index);
    private void RemovePendingImage((string SessionName, int Index) args) => RemovePendingImage(args.SessionName, args.Index);

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        CopilotService.OnStateChanged -= RefreshState;
        CopilotService.OnSessionComplete -= HandleComplete;
        CopilotService.OnContentReceived -= HandleContent;
        CopilotService.OnActivity -= HandleActivity;
        CopilotService.OnToolStarted -= HandleToolStarted;
        CopilotService.OnToolCompleted -= HandleToolCompleted;
        CopilotService.OnReasoningReceived -= HandleReasoningReceived;
        CopilotService.OnReasoningComplete -= HandleReasoningComplete;
        CopilotService.OnIntentChanged -= HandleIntentChanged;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        CopilotService.OnError -= HandleError;
        CopilotService.OnTurnStart -= HandleTurnStart;
        CopilotService.OnTurnEnd -= HandleTurnEnd;
        CopilotService.OnOrchestratorPhaseChanged -= HandleOrchestratorPhaseChanged;
        FiestaService.OnStateChanged -= HandleFiestaStateChanged;
        FiestaService.OnHostTaskUpdate -= HandleFiestaTaskUpdate;
        _renderTimer?.Dispose();
        _renderTimer = null;
        foreach (var images in pendingImagesBySession.Values)
            foreach (var img in images)
                try { File.Delete(img.TempPath); } catch { }
        try { await JS.InvokeVoidAsync("eval", "window.__dashRef = null;"); } catch { }
        _dotNetRef?.Dispose();
    }
}
