{
  "description": "Multi-agent orchestration scenarios for PolyPilot. Tests cover the OrchestratorReflect loop, stall detection, reconciliation stability, group lifecycle, and Squad integration. Each scenario can be executed against a running app using MauiDevFlow CDP commands. See docs/multi-agent-orchestration.md for the architecture spec.",
  "prerequisites": {
    "build": "cd PolyPilot && .\\relaunch.ps1",
    "waitForAgent": "maui-devflow MAUI status",
    "initialMode": "Persistent",
    "notes": "App must be in Persistent or Demo mode. Multi-agent features require at least one worktree configured. Squad scenarios require a worktree with a .squad/ directory."
  },
  "scenarios": [
    {
      "id": "reflect-loop-completes-goal-met",
      "name": "OrchestratorReflect loop runs to goal completion",
      "description": "Verifies the full plan-dispatch-collect-evaluate loop runs and exits when the evaluator signals [[GROUP_REFLECT_COMPLETE]] or scores >= 0.9.",
      "invariants": [
        "ReflectionState.GoalMet == true on exit",
        "ReflectionState.IsActive == false on exit",
        "ReflectionState.CurrentIteration >= 1",
        "All workers received prompts containing the original user request"
      ],
      "steps": [
        { "action": "navigate", "route": "/multi-agent" },
        { "action": "createGroup", "mode": "OrchestratorReflect", "workers": 2, "maxIterations": 3 },
        { "action": "sendPrompt", "text": "Analyze the project structure and suggest improvements" },
        { "action": "waitForPhase", "phase": "Planning", "timeout": 30 },
        { "action": "waitForPhase", "phase": "Dispatching", "timeout": 60 },
        { "action": "waitForPhase", "phase": "WaitingForWorkers", "timeout": 120 },
        { "action": "waitForPhase", "phase": "Synthesizing", "timeout": 60 },
        { "action": "waitForPhase", "phase": "Complete", "timeout": 600 },
        { "action": "assertReflectionState", "field": "IsActive", "expected": false },
        { "action": "assertReflectionState", "field": "CurrentIteration", "operator": ">=", "value": 1 }
      ]
    },
    {
      "id": "reflect-loop-max-iterations",
      "name": "OrchestratorReflect stops at MaxIterations",
      "description": "Verifies the loop exits when MaxIterations is reached without the goal being met.",
      "invariants": [
        "ReflectionState.CurrentIteration == MaxIterations on exit",
        "ReflectionState.GoalMet == false",
        "ReflectionState.IsActive == false"
      ],
      "steps": [
        { "action": "createGroup", "mode": "OrchestratorReflect", "workers": 1, "maxIterations": 2 },
        { "action": "sendPrompt", "text": "Write a perfect novel (intentionally impossible in 2 iterations)" },
        { "action": "waitForPhase", "phase": "Complete", "timeout": 600 },
        { "action": "assertReflectionState", "field": "CurrentIteration", "expected": 2 },
        { "action": "assertReflectionState", "field": "GoalMet", "expected": false }
      ]
    },
    {
      "id": "stall-detection-triggers",
      "name": "Stall detection fires after 2 consecutive similar responses",
      "description": "Verifies that if the orchestrator synthesis is >90% similar (Jaccard) for 2 consecutive iterations, the loop stops with IsStalled=true.",
      "invariants": [
        "ReflectionState.IsStalled == true on exit",
        "ReflectionState.ConsecutiveStalls >= 2",
        "ReflectionState.LastSimilarity > 0.9"
      ],
      "steps": [
        { "action": "createGroup", "mode": "OrchestratorReflect", "workers": 1, "maxIterations": 10 },
        { "action": "sendPrompt", "text": "Repeat the same analysis over and over" },
        { "action": "waitForPhase", "phase": "Complete", "timeout": 600 },
        { "action": "assertReflectionState", "field": "IsStalled", "expected": true }
      ]
    },
    {
      "id": "group-survives-restart",
      "name": "Multi-agent group persists across app restart",
      "description": "Verifies that after creating a multi-agent group, killing the app, and relaunching, the group still exists with all sessions correctly assigned.",
      "invariants": [
        "Group.IsMultiAgent == true after restart",
        "All sessions retain their GroupId",
        "Orchestrator session retains Role == Orchestrator",
        "Worker sessions retain PreferredModel values",
        "No sessions scattered to repo groups"
      ],
      "steps": [
        { "action": "createGroup", "mode": "OrchestratorReflect", "name": "Restart Test", "workers": 2 },
        { "action": "captureGroupState", "capture": "beforeRestart" },
        { "action": "restartApp" },
        { "action": "waitForAgent", "timeout": 120 },
        { "action": "captureGroupState", "capture": "afterRestart" },
        { "action": "assertEqual", "left": "beforeRestart.groupCount", "right": "afterRestart.groupCount" },
        { "action": "assertEqual", "left": "beforeRestart.sessionNames", "right": "afterRestart.sessionNames" },
        { "action": "assertOrgJson", "check": "noSessionsInDefaultWithMultiAgentMarkers" }
      ]
    },
    {
      "id": "reconciliation-protects-multi-agent",
      "name": "Reconciliation does not scatter multi-agent sessions",
      "description": "Verifies that ReconcileOrganization() does not move sessions with Role=Orchestrator or PreferredModel!=null out of their multi-agent group into repo groups.",
      "invariants": [
        "Sessions with IsMultiAgent group membership are never auto-moved",
        "Orphaned sessions with Role==Orchestrator or PreferredModel!=null stay in _default",
        "Regular sessions (no markers) ARE auto-moved to repo groups normally"
      ],
      "steps": [
        { "action": "createGroup", "mode": "Orchestrator", "workers": 2 },
        { "action": "readOrgJson", "capture": "orgBefore" },
        { "action": "restartApp" },
        { "action": "readOrgJson", "capture": "orgAfter" },
        { "action": "assertGroupMembership", "unchanged": true }
      ]
    },
    {
      "id": "delete-group-no-contamination",
      "name": "Deleted group sessions don't contaminate new groups",
      "description": "Verifies that deleting a multi-agent group and creating a new one produces a clean group with no leftover sessions from the old one.",
      "steps": [
        { "action": "createGroup", "mode": "OrchestratorReflect", "name": "Group A", "workers": 2 },
        { "action": "captureGroupState", "capture": "groupA" },
        { "action": "deleteGroup", "name": "Group A" },
        { "action": "createGroup", "mode": "OrchestratorReflect", "name": "Group B", "workers": 2 },
        { "action": "captureGroupState", "capture": "groupB" },
        { "action": "assertNoOverlap", "left": "groupA.sessionNames", "right": "groupB.sessionNames" }
      ]
    },
    {
      "id": "delete-multi-agent-group-closes-sessions",
      "name": "Deleting multi-agent group removes sessions entirely",
      "description": "Verifies that deleting a multi-agent group closes all its sessions and removes them from the organization, rather than orphaning them in the default Sessions group.",
      "invariants": [
        "No sessions with the deleted group's ID remain in organization.json",
        "No orphaned orchestrator/worker sessions appear in the default Sessions group",
        "Non-multi-agent group deletion still moves sessions to default (different behavior)"
      ],
      "steps": [
        { "action": "createGroup", "mode": "OrchestratorReflect", "name": "Temp Team", "workers": 2 },
        { "action": "captureGroupState", "capture": "beforeDelete" },
        { "action": "deleteGroup", "name": "Temp Team" },
        { "action": "readOrgJson", "capture": "orgAfter" },
        { "action": "assertNoSessionsWithGroupId", "groupId": "beforeDelete.groupId" },
        { "action": "assertNoSessionsInDefault", "nameContains": "Temp Team", "note": "Sessions should be gone, not orphaned" }
      ]
    },
    {
      "id": "broadcast-mode-all-receive",
      "name": "Broadcast mode sends to all sessions",
      "description": "Verifies that in Broadcast mode, the same prompt is sent to all sessions simultaneously.",
      "steps": [
        { "action": "createGroup", "mode": "Broadcast", "workers": 3 },
        { "action": "sendPrompt", "text": "Hello from broadcast" },
        { "action": "waitForAllSessions", "state": "idle", "timeout": 120 },
        { "action": "assertAllSessionsReceived", "text": "Hello from broadcast" }
      ]
    },
    {
      "id": "orchestrator-single-pass",
      "name": "Orchestrator mode runs one pass without iteration",
      "description": "Verifies that Orchestrator (non-reflect) mode plans, dispatches, collects, and synthesizes exactly once.",
      "steps": [
        { "action": "createGroup", "mode": "Orchestrator", "workers": 2 },
        { "action": "sendPrompt", "text": "Review this code" },
        { "action": "waitForPhase", "phase": "Complete", "timeout": 300 },
        { "action": "assertOrchestratorSynthesized" },
        { "action": "assertNoReflectionLoop", "note": "Should not have iterated" }
      ]
    },
    {
      "id": "tcs-ordering-reflection-continues",
      "name": "Reflection loop continues past iteration 1 (TCS ordering invariant)",
      "description": "Regression test for the bug where IsProcessing was set to false AFTER TrySetResult, causing the next SendPromptAsync to throw. The loop must reach at least iteration 2.",
      "invariants": [
        "IsProcessing = false BEFORE TrySetResult in CompleteResponse",
        "ReflectionState.CurrentIteration >= 2 (proves loop continued)"
      ],
      "steps": [
        { "action": "createGroup", "mode": "OrchestratorReflect", "workers": 1, "maxIterations": 3 },
        { "action": "sendPrompt", "text": "Iterate on this multiple times" },
        { "action": "waitForPhase", "phase": "Complete", "timeout": 600 },
        { "action": "assertReflectionState", "field": "CurrentIteration", "operator": ">=", "value": 2 }
      ]
    },
    {
      "id": "preset-creates-correct-markers",
      "name": "Group preset sets Role and PreferredModel on all sessions",
      "description": "Verifies that CreateGroupFromPresetAsync correctly sets Role=Orchestrator on the orchestrator session and PreferredModel on all sessions.",
      "invariants": [
        "Orchestrator session has Role == Orchestrator",
        "Orchestrator session has PreferredModel == preset.OrchestratorModel",
        "Worker sessions have PreferredModel == preset.WorkerModels[i]",
        "All sessions have GroupId matching the new group"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Quick Reflection Cycle" },
        { "action": "readOrgJson", "capture": "org" },
        { "action": "assertSessionMeta", "role": "Orchestrator", "hasPreferredModel": true },
        { "action": "assertAllWorkers", "havePreferredModel": true }
      ]
    },
    {
      "id": "squad-discovery-creates-preset",
      "name": "Squad directory discovered as repo-level preset",
      "description": "Verifies that when a worktree contains a .squad/ directory with team.md and agent charters, PolyPilot discovers it and presents it as a selectable preset in the multi-agent group creation flow.",
      "invariants": [
        "Squad preset appears in 'From Repo' section of preset picker",
        "Preset has IsRepoLevel == true",
        "Preset worker count matches number of non-scribe agents in .squad/agents/"
      ],
      "steps": [
        { "action": "shell", "command": "mkdir -p .squad/agents/reviewer && echo '# Team\n| Member | Role |\n|--------|------|\n| reviewer | Code Reviewer |' > .squad/team.md && echo 'You are a code reviewer.' > .squad/agents/reviewer/charter.md" },
        { "action": "navigate", "route": "/multi-agent" },
        { "action": "selectWorktree", "worktree": "current" },
        { "action": "assertPresetVisible", "section": "From Repo", "name": "Squad Team" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "squad-charter-becomes-system-prompt",
      "name": "Squad agent charter.md becomes worker system prompt",
      "description": "Verifies that when creating a group from a Squad-discovered preset, each agent's charter.md content is set as the worker's SessionMeta.SystemPrompt.",
      "invariants": [
        "Worker SystemPrompt contains charter.md content",
        "Orchestrator planning prompt includes worker specializations"
      ],
      "steps": [
        { "action": "shell", "command": "mkdir -p .squad/agents/security .squad/agents/perf && echo '# Team\n| Member | Role |\n|--------|------|\n| security | Security Auditor |\n| perf | Performance Analyst |' > .squad/team.md && echo 'You are a security auditor. Focus on OWASP Top 10.' > .squad/agents/security/charter.md && echo 'You are a performance analyst. Focus on latency and throughput.' > .squad/agents/perf/charter.md" },
        { "action": "createGroupFromPreset", "preset": "Squad Team", "source": "repo" },
        { "action": "readOrgJson", "capture": "org" },
        { "action": "assertSessionMeta", "sessionNameContains": "security", "systemPromptContains": "OWASP Top 10" },
        { "action": "assertSessionMeta", "sessionNameContains": "perf", "systemPromptContains": "latency and throughput" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "squad-decisions-shared-context",
      "name": "Squad decisions.md injected as shared context",
      "description": "Verifies that .squad/decisions.md content is prepended to all worker prompts as shared team knowledge.",
      "invariants": [
        "All workers receive decisions.md content in their prompt context",
        "Decisions content appears before the worker's assigned task"
      ],
      "steps": [
        { "action": "shell", "command": "mkdir -p .squad/agents/worker1 && echo '# Team\n| Member | Role |\n|--------|------|\n| worker1 | Developer |' > .squad/team.md && echo 'Always use TypeScript. Never use any.' > .squad/decisions.md && echo 'You are a developer.' > .squad/agents/worker1/charter.md" },
        { "action": "createGroupFromPreset", "preset": "Squad Team", "source": "repo" },
        { "action": "sendPrompt", "text": "Write a hello world" },
        { "action": "waitForAllSessions", "state": "idle", "timeout": 120 },
        { "action": "assertWorkerPromptContains", "text": "Always use TypeScript" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "squad-legacy-ai-team-compat",
      "name": "Legacy .ai-team/ directory also discovered",
      "description": "Verifies backward compatibility: .ai-team/ is discovered if .squad/ doesn't exist (Squad v0.4.x compat).",
      "steps": [
        { "action": "shell", "command": "mkdir -p .ai-team/agents/dev && echo '# Team\n| Member | Role |\n|--------|------|\n| dev | Developer |' > .ai-team/team.md && echo 'You are a developer.' > .ai-team/agents/dev/charter.md" },
        { "action": "selectWorktree", "worktree": "current" },
        { "action": "assertPresetVisible", "section": "From Repo", "name": "Squad Team" },
        { "action": "shell", "command": "rm -rf .ai-team" }
      ]
    },
    {
      "id": "squad-preset-priority-over-builtin",
      "name": "Squad preset shadows built-in with same name",
      "description": "Verifies that if a Squad team has the same name as a built-in preset, the Squad version takes priority within that worktree.",
      "steps": [
        { "action": "shell", "command": "mkdir -p .squad/agents/reviewer && echo '# Team\nCode Review Team\n| Member | Role |\n|--------|------|\n| reviewer | Reviewer |' > .squad/team.md && echo 'Custom repo reviewer.' > .squad/agents/reviewer/charter.md" },
        { "action": "selectWorktree", "worktree": "current" },
        { "action": "assertPresetInSection", "name": "Code Review Team", "section": "From Repo", "note": "Repo version should shadow built-in" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "squad-missing-files-graceful",
      "name": "Missing Squad files handled gracefully",
      "description": "Verifies that partial .squad/ directories (missing team.md, missing charter.md) are handled without errors.",
      "steps": [
        { "action": "shell", "command": "mkdir -p .squad/agents/orphan" },
        { "action": "selectWorktree", "worktree": "current" },
        { "action": "assertNoPresetInSection", "section": "From Repo", "note": "No team.md = no preset" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "worker-system-prompt-in-orchestrator-plan",
      "name": "Worker system prompts visible in orchestrator planning",
      "description": "Verifies that BuildOrchestratorPlanningPrompt includes each worker's SystemPrompt description so the orchestrator can route tasks based on expertise.",
      "invariants": [
        "Orchestrator planning prompt lists worker names with their specializations",
        "Workers with no SystemPrompt are listed as generic workers"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Code Review Team" },
        { "action": "sendPrompt", "text": "Review the authentication module" },
        { "action": "waitForPhase", "phase": "Planning", "timeout": 30 },
        { "action": "assertOrchestratorReceivedWorkerDescriptions" }
      ]
    },
    {
      "id": "save-preset-creates-squad-dir",
      "name": "Saving preset writes .squad/ directory",
      "description": "Verifies that SaveGroupAsPreset creates a .squad/ directory with team.md, agent charters, and optional decisions.md/routing.md in the worktree root.",
      "invariants": [
        ".squad/team.md is created with team name and roster table",
        ".squad/agents/{name}/charter.md is created for each worker",
        "Agent names are sanitized (lowercase, hyphens)",
        "Preset is also saved to presets.json as backup"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Code Review Team" },
        { "action": "saveGroupAsPreset", "name": "My Code Review" },
        { "action": "assertFileExists", "path": ".squad/team.md" },
        { "action": "assertFileContains", "path": ".squad/team.md", "text": "My Code Review" },
        { "action": "assertDirectoryExists", "path": ".squad/agents" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "round-trip-squad-write-read",
      "name": "Round-trip: write then discover Squad team",
      "description": "Verifies that a team saved via SquadWriter can be discovered back via SquadDiscovery with matching data.",
      "invariants": [
        "Written team.md can be parsed back by SquadDiscovery",
        "Written charter.md content matches original system prompts",
        "decisions.md and routing.md survive the round-trip"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Code Review Team" },
        { "action": "saveGroupAsPreset", "name": "Round Trip Test" },
        { "action": "assertFileExists", "path": ".squad/team.md" },
        { "action": "selectWorktree", "worktree": "current" },
        { "action": "assertPresetInSection", "section": "From Repo", "name": "Round Trip Test" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "squad-write-sanitizes-names",
      "name": "Squad writer sanitizes agent names",
      "description": "Verifies that SquadWriter strips team-name prefixes and sanitizes agent directory names (lowercase, hyphens instead of special chars).",
      "invariants": [
        "Team-name prefix stripped from session names",
        "Directory names are lowercase with hyphens",
        "No spaces or special characters in directory names"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Code Review Team" },
        { "action": "saveGroupAsPreset", "name": "Test Team" },
        { "action": "assertNoDirectoryContains", "path": ".squad/agents", "pattern": " " },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    },
    {
      "id": "sequential-mode-processes-in-order",
      "name": "Sequential mode sends to sessions one-by-one",
      "description": "Verifies that Sequential mode dispatches prompts to sessions one at a time in order, not in parallel.",
      "invariants": [
        "Sessions receive prompts sequentially, not simultaneously",
        "Each session processes before the next receives its prompt"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Multi-Perspective Analysis" },
        { "action": "setMode", "mode": "Sequential" },
        { "action": "sendPrompt", "text": "Explain dependency injection" },
        { "action": "waitForAllResponses", "timeout": 120 },
        { "action": "assertAllSessionsResponded" }
      ]
    },
    {
      "id": "pause-resume-reflection-cycle",
      "name": "Pause and resume an active reflection loop",
      "description": "Verifies that pausing a running OrchestratorReflect loop halts iteration dispatch without losing state, and resuming continues from where it left off.",
      "invariants": [
        "IsPaused flag prevents new iterations from dispatching",
        "Resuming continues from the current iteration count",
        "Reflection state (CurrentIteration, goal) is preserved"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Quick Reflection Cycle" },
        { "action": "sendPrompt", "text": "Implement a binary search function" },
        { "action": "waitForPhase", "phase": "Reflecting", "timeout": 30 },
        { "action": "pauseReflection" },
        { "action": "assertReflectionPaused" },
        { "action": "resumeReflection" },
        { "action": "waitForCompletion", "timeout": 120 }
      ]
    },
    {
      "id": "dedicated-evaluator-session",
      "name": "OrchestratorReflect with separate evaluator",
      "description": "Verifies that when an EvaluatorSessionName is set, the evaluator independently scores each iteration instead of the orchestrator self-evaluating.",
      "invariants": [
        "Evaluator session receives synthesis output for scoring",
        "Evaluator PASS/FAIL determines iteration continuation",
        "Orchestrator and evaluator are different sessions"
      ],
      "steps": [
        { "action": "createGroupFromPreset", "preset": "Code Review Team" },
        { "action": "setEvaluator", "sessionName": "worker-1" },
        { "action": "sendPrompt", "text": "Review error handling in the auth module" },
        { "action": "waitForCompletion", "timeout": 120 },
        { "action": "assertEvaluatorWasUsed" }
      ]
    },
    {
      "id": "routing-context-in-orchestrator-plan",
      "name": "Routing context from routing.md injected into orchestrator",
      "description": "Verifies that a Squad-discovered preset's routing.md content appears in the orchestrator's planning prompt.",
      "invariants": [
        "RoutingContext from routing.md is prepended to orchestrator planning",
        "Orchestrator uses routing hints to assign tasks to appropriate workers"
      ],
      "steps": [
        { "action": "createSquadDir", "agents": ["security-reviewer", "code-optimizer"], "routing": "Route security tasks to security-reviewer" },
        { "action": "selectWorktree", "worktree": "current" },
        { "action": "createGroupFromPreset", "preset": "PolyPilot Review Squad" },
        { "action": "sendPrompt", "text": "Review this code for security and performance" },
        { "action": "waitForPhase", "phase": "Planning", "timeout": 30 },
        { "action": "assertOrchestratorReceivedRoutingContext" },
        { "action": "shell", "command": "rm -rf .squad" }
      ]
    }
  ]
}
